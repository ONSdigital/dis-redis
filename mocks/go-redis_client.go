// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/ONSdigital/dis-redis/interfaces"
	redis "github.com/redis/go-redis/v9"
	"sync"
	"time"
)

// Ensure, that GoRedisClientMock does implement interfaces.GoRedisClient.
// If this is not the case, regenerate this file with moq.
var _ interfaces.GoRedisClient = &GoRedisClientMock{}

// GoRedisClientMock is a mock implementation of interfaces.GoRedisClient.
//
//	func TestSomethingThatUsesGoRedisClient(t *testing.T) {
//
//		// make and configure a mocked interfaces.GoRedisClient
//		mockedGoRedisClient := &GoRedisClientMock{
//			ACLCatFunc: func(ctx context.Context) *redis.StringSliceCmd {
//				panic("mock out the ACLCat method")
//			},
//			ACLCatArgsFunc: func(ctx context.Context, options *redis.ACLCatArgs) *redis.StringSliceCmd {
//				panic("mock out the ACLCatArgs method")
//			},
//			ACLDelUserFunc: func(ctx context.Context, username string) *redis.IntCmd {
//				panic("mock out the ACLDelUser method")
//			},
//			ACLDryRunFunc: func(ctx context.Context, username string, command ...interface{}) *redis.StringCmd {
//				panic("mock out the ACLDryRun method")
//			},
//			ACLListFunc: func(ctx context.Context) *redis.StringSliceCmd {
//				panic("mock out the ACLList method")
//			},
//			ACLLogFunc: func(ctx context.Context, count int64) *redis.ACLLogCmd {
//				panic("mock out the ACLLog method")
//			},
//			ACLLogResetFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ACLLogReset method")
//			},
//			ACLSetUserFunc: func(ctx context.Context, username string, rules ...string) *redis.StatusCmd {
//				panic("mock out the ACLSetUser method")
//			},
//			AddHookFunc: func(hook redis.Hook)  {
//				panic("mock out the AddHook method")
//			},
//			AppendFunc: func(ctx context.Context, key string, value string) *redis.IntCmd {
//				panic("mock out the Append method")
//			},
//			BFAddFunc: func(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
//				panic("mock out the BFAdd method")
//			},
//			BFCardFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the BFCard method")
//			},
//			BFExistsFunc: func(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
//				panic("mock out the BFExists method")
//			},
//			BFInfoFunc: func(ctx context.Context, key string) *redis.BFInfoCmd {
//				panic("mock out the BFInfo method")
//			},
//			BFInfoArgFunc: func(ctx context.Context, key string, option string) *redis.BFInfoCmd {
//				panic("mock out the BFInfoArg method")
//			},
//			BFInfoCapacityFunc: func(ctx context.Context, key string) *redis.BFInfoCmd {
//				panic("mock out the BFInfoCapacity method")
//			},
//			BFInfoExpansionFunc: func(ctx context.Context, key string) *redis.BFInfoCmd {
//				panic("mock out the BFInfoExpansion method")
//			},
//			BFInfoFiltersFunc: func(ctx context.Context, key string) *redis.BFInfoCmd {
//				panic("mock out the BFInfoFilters method")
//			},
//			BFInfoItemsFunc: func(ctx context.Context, key string) *redis.BFInfoCmd {
//				panic("mock out the BFInfoItems method")
//			},
//			BFInfoSizeFunc: func(ctx context.Context, key string) *redis.BFInfoCmd {
//				panic("mock out the BFInfoSize method")
//			},
//			BFInsertFunc: func(ctx context.Context, key string, options *redis.BFInsertOptions, elements ...interface{}) *redis.BoolSliceCmd {
//				panic("mock out the BFInsert method")
//			},
//			BFLoadChunkFunc: func(ctx context.Context, key string, iterator int64, data interface{}) *redis.StatusCmd {
//				panic("mock out the BFLoadChunk method")
//			},
//			BFMAddFunc: func(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd {
//				panic("mock out the BFMAdd method")
//			},
//			BFMExistsFunc: func(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd {
//				panic("mock out the BFMExists method")
//			},
//			BFReserveFunc: func(ctx context.Context, key string, errorRate float64, capacity int64) *redis.StatusCmd {
//				panic("mock out the BFReserve method")
//			},
//			BFReserveExpansionFunc: func(ctx context.Context, key string, errorRate float64, capacity int64, expansion int64) *redis.StatusCmd {
//				panic("mock out the BFReserveExpansion method")
//			},
//			BFReserveNonScalingFunc: func(ctx context.Context, key string, errorRate float64, capacity int64) *redis.StatusCmd {
//				panic("mock out the BFReserveNonScaling method")
//			},
//			BFReserveWithArgsFunc: func(ctx context.Context, key string, options *redis.BFReserveOptions) *redis.StatusCmd {
//				panic("mock out the BFReserveWithArgs method")
//			},
//			BFScanDumpFunc: func(ctx context.Context, key string, iterator int64) *redis.ScanDumpCmd {
//				panic("mock out the BFScanDump method")
//			},
//			BLMPopFunc: func(ctx context.Context, timeout time.Duration, direction string, count int64, keys ...string) *redis.KeyValuesCmd {
//				panic("mock out the BLMPop method")
//			},
//			BLMoveFunc: func(ctx context.Context, source string, destination string, srcpos string, destpos string, timeout time.Duration) *redis.StringCmd {
//				panic("mock out the BLMove method")
//			},
//			BLPopFunc: func(ctx context.Context, timeout time.Duration, keys ...string) *redis.StringSliceCmd {
//				panic("mock out the BLPop method")
//			},
//			BRPopFunc: func(ctx context.Context, timeout time.Duration, keys ...string) *redis.StringSliceCmd {
//				panic("mock out the BRPop method")
//			},
//			BRPopLPushFunc: func(ctx context.Context, source string, destination string, timeout time.Duration) *redis.StringCmd {
//				panic("mock out the BRPopLPush method")
//			},
//			BZMPopFunc: func(ctx context.Context, timeout time.Duration, order string, count int64, keys ...string) *redis.ZSliceWithKeyCmd {
//				panic("mock out the BZMPop method")
//			},
//			BZPopMaxFunc: func(ctx context.Context, timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
//				panic("mock out the BZPopMax method")
//			},
//			BZPopMinFunc: func(ctx context.Context, timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
//				panic("mock out the BZPopMin method")
//			},
//			BgRewriteAOFFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the BgRewriteAOF method")
//			},
//			BgSaveFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the BgSave method")
//			},
//			BitCountFunc: func(ctx context.Context, key string, bitCount *redis.BitCount) *redis.IntCmd {
//				panic("mock out the BitCount method")
//			},
//			BitFieldFunc: func(ctx context.Context, key string, values ...interface{}) *redis.IntSliceCmd {
//				panic("mock out the BitField method")
//			},
//			BitFieldROFunc: func(ctx context.Context, key string, values ...interface{}) *redis.IntSliceCmd {
//				panic("mock out the BitFieldRO method")
//			},
//			BitOpAndFunc: func(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
//				panic("mock out the BitOpAnd method")
//			},
//			BitOpNotFunc: func(ctx context.Context, destKey string, key string) *redis.IntCmd {
//				panic("mock out the BitOpNot method")
//			},
//			BitOpOrFunc: func(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
//				panic("mock out the BitOpOr method")
//			},
//			BitOpXorFunc: func(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
//				panic("mock out the BitOpXor method")
//			},
//			BitPosFunc: func(ctx context.Context, key string, bit int64, pos ...int64) *redis.IntCmd {
//				panic("mock out the BitPos method")
//			},
//			BitPosSpanFunc: func(ctx context.Context, key string, bit int8, start int64, end int64, span string) *redis.IntCmd {
//				panic("mock out the BitPosSpan method")
//			},
//			CFAddFunc: func(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
//				panic("mock out the CFAdd method")
//			},
//			CFAddNXFunc: func(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
//				panic("mock out the CFAddNX method")
//			},
//			CFCountFunc: func(ctx context.Context, key string, element interface{}) *redis.IntCmd {
//				panic("mock out the CFCount method")
//			},
//			CFDelFunc: func(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
//				panic("mock out the CFDel method")
//			},
//			CFExistsFunc: func(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
//				panic("mock out the CFExists method")
//			},
//			CFInfoFunc: func(ctx context.Context, key string) *redis.CFInfoCmd {
//				panic("mock out the CFInfo method")
//			},
//			CFInsertFunc: func(ctx context.Context, key string, options *redis.CFInsertOptions, elements ...interface{}) *redis.BoolSliceCmd {
//				panic("mock out the CFInsert method")
//			},
//			CFInsertNXFunc: func(ctx context.Context, key string, options *redis.CFInsertOptions, elements ...interface{}) *redis.IntSliceCmd {
//				panic("mock out the CFInsertNX method")
//			},
//			CFLoadChunkFunc: func(ctx context.Context, key string, iterator int64, data interface{}) *redis.StatusCmd {
//				panic("mock out the CFLoadChunk method")
//			},
//			CFMExistsFunc: func(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd {
//				panic("mock out the CFMExists method")
//			},
//			CFReserveFunc: func(ctx context.Context, key string, capacity int64) *redis.StatusCmd {
//				panic("mock out the CFReserve method")
//			},
//			CFReserveBucketSizeFunc: func(ctx context.Context, key string, capacity int64, bucketsize int64) *redis.StatusCmd {
//				panic("mock out the CFReserveBucketSize method")
//			},
//			CFReserveExpansionFunc: func(ctx context.Context, key string, capacity int64, expansion int64) *redis.StatusCmd {
//				panic("mock out the CFReserveExpansion method")
//			},
//			CFReserveMaxIterationsFunc: func(ctx context.Context, key string, capacity int64, maxiterations int64) *redis.StatusCmd {
//				panic("mock out the CFReserveMaxIterations method")
//			},
//			CFReserveWithArgsFunc: func(ctx context.Context, key string, options *redis.CFReserveOptions) *redis.StatusCmd {
//				panic("mock out the CFReserveWithArgs method")
//			},
//			CFScanDumpFunc: func(ctx context.Context, key string, iterator int64) *redis.ScanDumpCmd {
//				panic("mock out the CFScanDump method")
//			},
//			CMSIncrByFunc: func(ctx context.Context, key string, elements ...interface{}) *redis.IntSliceCmd {
//				panic("mock out the CMSIncrBy method")
//			},
//			CMSInfoFunc: func(ctx context.Context, key string) *redis.CMSInfoCmd {
//				panic("mock out the CMSInfo method")
//			},
//			CMSInitByDimFunc: func(ctx context.Context, key string, width int64, height int64) *redis.StatusCmd {
//				panic("mock out the CMSInitByDim method")
//			},
//			CMSInitByProbFunc: func(ctx context.Context, key string, errorRate float64, probability float64) *redis.StatusCmd {
//				panic("mock out the CMSInitByProb method")
//			},
//			CMSMergeFunc: func(ctx context.Context, destKey string, sourceKeys ...string) *redis.StatusCmd {
//				panic("mock out the CMSMerge method")
//			},
//			CMSMergeWithWeightFunc: func(ctx context.Context, destKey string, sourceKeys map[string]int64) *redis.StatusCmd {
//				panic("mock out the CMSMergeWithWeight method")
//			},
//			CMSQueryFunc: func(ctx context.Context, key string, elements ...interface{}) *redis.IntSliceCmd {
//				panic("mock out the CMSQuery method")
//			},
//			ClientGetNameFunc: func(ctx context.Context) *redis.StringCmd {
//				panic("mock out the ClientGetName method")
//			},
//			ClientIDFunc: func(ctx context.Context) *redis.IntCmd {
//				panic("mock out the ClientID method")
//			},
//			ClientInfoFunc: func(ctx context.Context) *redis.ClientInfoCmd {
//				panic("mock out the ClientInfo method")
//			},
//			ClientKillFunc: func(ctx context.Context, ipPort string) *redis.StatusCmd {
//				panic("mock out the ClientKill method")
//			},
//			ClientKillByFilterFunc: func(ctx context.Context, keys ...string) *redis.IntCmd {
//				panic("mock out the ClientKillByFilter method")
//			},
//			ClientListFunc: func(ctx context.Context) *redis.StringCmd {
//				panic("mock out the ClientList method")
//			},
//			ClientPauseFunc: func(ctx context.Context, dur time.Duration) *redis.BoolCmd {
//				panic("mock out the ClientPause method")
//			},
//			ClientUnblockFunc: func(ctx context.Context, id int64) *redis.IntCmd {
//				panic("mock out the ClientUnblock method")
//			},
//			ClientUnblockWithErrorFunc: func(ctx context.Context, id int64) *redis.IntCmd {
//				panic("mock out the ClientUnblockWithError method")
//			},
//			ClientUnpauseFunc: func(ctx context.Context) *redis.BoolCmd {
//				panic("mock out the ClientUnpause method")
//			},
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			ClusterAddSlotsFunc: func(ctx context.Context, slots ...int) *redis.StatusCmd {
//				panic("mock out the ClusterAddSlots method")
//			},
//			ClusterAddSlotsRangeFunc: func(ctx context.Context, min int, max int) *redis.StatusCmd {
//				panic("mock out the ClusterAddSlotsRange method")
//			},
//			ClusterCountFailureReportsFunc: func(ctx context.Context, nodeID string) *redis.IntCmd {
//				panic("mock out the ClusterCountFailureReports method")
//			},
//			ClusterCountKeysInSlotFunc: func(ctx context.Context, slot int) *redis.IntCmd {
//				panic("mock out the ClusterCountKeysInSlot method")
//			},
//			ClusterDelSlotsFunc: func(ctx context.Context, slots ...int) *redis.StatusCmd {
//				panic("mock out the ClusterDelSlots method")
//			},
//			ClusterDelSlotsRangeFunc: func(ctx context.Context, min int, max int) *redis.StatusCmd {
//				panic("mock out the ClusterDelSlotsRange method")
//			},
//			ClusterFailoverFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ClusterFailover method")
//			},
//			ClusterForgetFunc: func(ctx context.Context, nodeID string) *redis.StatusCmd {
//				panic("mock out the ClusterForget method")
//			},
//			ClusterGetKeysInSlotFunc: func(ctx context.Context, slot int, count int) *redis.StringSliceCmd {
//				panic("mock out the ClusterGetKeysInSlot method")
//			},
//			ClusterInfoFunc: func(ctx context.Context) *redis.StringCmd {
//				panic("mock out the ClusterInfo method")
//			},
//			ClusterKeySlotFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the ClusterKeySlot method")
//			},
//			ClusterLinksFunc: func(ctx context.Context) *redis.ClusterLinksCmd {
//				panic("mock out the ClusterLinks method")
//			},
//			ClusterMeetFunc: func(ctx context.Context, host string, port string) *redis.StatusCmd {
//				panic("mock out the ClusterMeet method")
//			},
//			ClusterMyIDFunc: func(ctx context.Context) *redis.StringCmd {
//				panic("mock out the ClusterMyID method")
//			},
//			ClusterMyShardIDFunc: func(ctx context.Context) *redis.StringCmd {
//				panic("mock out the ClusterMyShardID method")
//			},
//			ClusterNodesFunc: func(ctx context.Context) *redis.StringCmd {
//				panic("mock out the ClusterNodes method")
//			},
//			ClusterReplicateFunc: func(ctx context.Context, nodeID string) *redis.StatusCmd {
//				panic("mock out the ClusterReplicate method")
//			},
//			ClusterResetHardFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ClusterResetHard method")
//			},
//			ClusterResetSoftFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ClusterResetSoft method")
//			},
//			ClusterSaveConfigFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ClusterSaveConfig method")
//			},
//			ClusterShardsFunc: func(ctx context.Context) *redis.ClusterShardsCmd {
//				panic("mock out the ClusterShards method")
//			},
//			ClusterSlavesFunc: func(ctx context.Context, nodeID string) *redis.StringSliceCmd {
//				panic("mock out the ClusterSlaves method")
//			},
//			ClusterSlotsFunc: func(ctx context.Context) *redis.ClusterSlotsCmd {
//				panic("mock out the ClusterSlots method")
//			},
//			CommandFunc: func(ctx context.Context) *redis.CommandsInfoCmd {
//				panic("mock out the Command method")
//			},
//			CommandGetKeysFunc: func(ctx context.Context, commands ...interface{}) *redis.StringSliceCmd {
//				panic("mock out the CommandGetKeys method")
//			},
//			CommandGetKeysAndFlagsFunc: func(ctx context.Context, commands ...interface{}) *redis.KeyFlagsCmd {
//				panic("mock out the CommandGetKeysAndFlags method")
//			},
//			CommandListFunc: func(ctx context.Context, filter *redis.FilterBy) *redis.StringSliceCmd {
//				panic("mock out the CommandList method")
//			},
//			ConfigGetFunc: func(ctx context.Context, parameter string) *redis.MapStringStringCmd {
//				panic("mock out the ConfigGet method")
//			},
//			ConfigResetStatFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ConfigResetStat method")
//			},
//			ConfigRewriteFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ConfigRewrite method")
//			},
//			ConfigSetFunc: func(ctx context.Context, parameter string, value string) *redis.StatusCmd {
//				panic("mock out the ConfigSet method")
//			},
//			CopyFunc: func(ctx context.Context, sourceKey string, destKey string, db int, replace bool) *redis.IntCmd {
//				panic("mock out the Copy method")
//			},
//			DBSizeFunc: func(ctx context.Context) *redis.IntCmd {
//				panic("mock out the DBSize method")
//			},
//			DebugObjectFunc: func(ctx context.Context, key string) *redis.StringCmd {
//				panic("mock out the DebugObject method")
//			},
//			DecrFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the Decr method")
//			},
//			DecrByFunc: func(ctx context.Context, key string, decrement int64) *redis.IntCmd {
//				panic("mock out the DecrBy method")
//			},
//			DelFunc: func(ctx context.Context, keys ...string) *redis.IntCmd {
//				panic("mock out the Del method")
//			},
//			DoFunc: func(ctx context.Context, args ...interface{}) *redis.Cmd {
//				panic("mock out the Do method")
//			},
//			DumpFunc: func(ctx context.Context, key string) *redis.StringCmd {
//				panic("mock out the Dump method")
//			},
//			EchoFunc: func(ctx context.Context, message interface{}) *redis.StringCmd {
//				panic("mock out the Echo method")
//			},
//			EvalFunc: func(ctx context.Context, script string, keys []string, args ...interface{}) *redis.Cmd {
//				panic("mock out the Eval method")
//			},
//			EvalROFunc: func(ctx context.Context, script string, keys []string, args ...interface{}) *redis.Cmd {
//				panic("mock out the EvalRO method")
//			},
//			EvalShaFunc: func(ctx context.Context, sha1 string, keys []string, args ...interface{}) *redis.Cmd {
//				panic("mock out the EvalSha method")
//			},
//			EvalShaROFunc: func(ctx context.Context, sha1 string, keys []string, args ...interface{}) *redis.Cmd {
//				panic("mock out the EvalShaRO method")
//			},
//			ExistsFunc: func(ctx context.Context, keys ...string) *redis.IntCmd {
//				panic("mock out the Exists method")
//			},
//			ExpireFunc: func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
//				panic("mock out the Expire method")
//			},
//			ExpireAtFunc: func(ctx context.Context, key string, tm time.Time) *redis.BoolCmd {
//				panic("mock out the ExpireAt method")
//			},
//			ExpireGTFunc: func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
//				panic("mock out the ExpireGT method")
//			},
//			ExpireLTFunc: func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
//				panic("mock out the ExpireLT method")
//			},
//			ExpireNXFunc: func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
//				panic("mock out the ExpireNX method")
//			},
//			ExpireTimeFunc: func(ctx context.Context, key string) *redis.DurationCmd {
//				panic("mock out the ExpireTime method")
//			},
//			ExpireXXFunc: func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
//				panic("mock out the ExpireXX method")
//			},
//			FCallFunc: func(ctx context.Context, function string, keys []string, args ...interface{}) *redis.Cmd {
//				panic("mock out the FCall method")
//			},
//			FCallROFunc: func(ctx context.Context, function string, keys []string, args ...interface{}) *redis.Cmd {
//				panic("mock out the FCallRO method")
//			},
//			FCallRoFunc: func(ctx context.Context, function string, keys []string, args ...interface{}) *redis.Cmd {
//				panic("mock out the FCallRo method")
//			},
//			FTAggregateFunc: func(ctx context.Context, index string, query string) *redis.MapStringInterfaceCmd {
//				panic("mock out the FTAggregate method")
//			},
//			FTAggregateWithArgsFunc: func(ctx context.Context, index string, query string, options *redis.FTAggregateOptions) *redis.AggregateCmd {
//				panic("mock out the FTAggregateWithArgs method")
//			},
//			FTAliasAddFunc: func(ctx context.Context, index string, alias string) *redis.StatusCmd {
//				panic("mock out the FTAliasAdd method")
//			},
//			FTAliasDelFunc: func(ctx context.Context, alias string) *redis.StatusCmd {
//				panic("mock out the FTAliasDel method")
//			},
//			FTAliasUpdateFunc: func(ctx context.Context, index string, alias string) *redis.StatusCmd {
//				panic("mock out the FTAliasUpdate method")
//			},
//			FTAlterFunc: func(ctx context.Context, index string, skipInitialScan bool, definition []interface{}) *redis.StatusCmd {
//				panic("mock out the FTAlter method")
//			},
//			FTConfigGetFunc: func(ctx context.Context, option string) *redis.MapMapStringInterfaceCmd {
//				panic("mock out the FTConfigGet method")
//			},
//			FTConfigSetFunc: func(ctx context.Context, option string, value interface{}) *redis.StatusCmd {
//				panic("mock out the FTConfigSet method")
//			},
//			FTCreateFunc: func(ctx context.Context, index string, options *redis.FTCreateOptions, schema ...*redis.FieldSchema) *redis.StatusCmd {
//				panic("mock out the FTCreate method")
//			},
//			FTCursorDelFunc: func(ctx context.Context, index string, cursorId int) *redis.StatusCmd {
//				panic("mock out the FTCursorDel method")
//			},
//			FTCursorReadFunc: func(ctx context.Context, index string, cursorId int, count int) *redis.MapStringInterfaceCmd {
//				panic("mock out the FTCursorRead method")
//			},
//			FTDictAddFunc: func(ctx context.Context, dict string, term ...interface{}) *redis.IntCmd {
//				panic("mock out the FTDictAdd method")
//			},
//			FTDictDelFunc: func(ctx context.Context, dict string, term ...interface{}) *redis.IntCmd {
//				panic("mock out the FTDictDel method")
//			},
//			FTDictDumpFunc: func(ctx context.Context, dict string) *redis.StringSliceCmd {
//				panic("mock out the FTDictDump method")
//			},
//			FTDropIndexFunc: func(ctx context.Context, index string) *redis.StatusCmd {
//				panic("mock out the FTDropIndex method")
//			},
//			FTDropIndexWithArgsFunc: func(ctx context.Context, index string, options *redis.FTDropIndexOptions) *redis.StatusCmd {
//				panic("mock out the FTDropIndexWithArgs method")
//			},
//			FTExplainFunc: func(ctx context.Context, index string, query string) *redis.StringCmd {
//				panic("mock out the FTExplain method")
//			},
//			FTExplainWithArgsFunc: func(ctx context.Context, index string, query string, options *redis.FTExplainOptions) *redis.StringCmd {
//				panic("mock out the FTExplainWithArgs method")
//			},
//			FTInfoFunc: func(ctx context.Context, index string) *redis.FTInfoCmd {
//				panic("mock out the FTInfo method")
//			},
//			FTSearchFunc: func(ctx context.Context, index string, query string) *redis.FTSearchCmd {
//				panic("mock out the FTSearch method")
//			},
//			FTSearchWithArgsFunc: func(ctx context.Context, index string, query string, options *redis.FTSearchOptions) *redis.FTSearchCmd {
//				panic("mock out the FTSearchWithArgs method")
//			},
//			FTSpellCheckFunc: func(ctx context.Context, index string, query string) *redis.FTSpellCheckCmd {
//				panic("mock out the FTSpellCheck method")
//			},
//			FTSpellCheckWithArgsFunc: func(ctx context.Context, index string, query string, options *redis.FTSpellCheckOptions) *redis.FTSpellCheckCmd {
//				panic("mock out the FTSpellCheckWithArgs method")
//			},
//			FTSynDumpFunc: func(ctx context.Context, index string) *redis.FTSynDumpCmd {
//				panic("mock out the FTSynDump method")
//			},
//			FTSynUpdateFunc: func(ctx context.Context, index string, synGroupId interface{}, terms []interface{}) *redis.StatusCmd {
//				panic("mock out the FTSynUpdate method")
//			},
//			FTSynUpdateWithArgsFunc: func(ctx context.Context, index string, synGroupId interface{}, options *redis.FTSynUpdateOptions, terms []interface{}) *redis.StatusCmd {
//				panic("mock out the FTSynUpdateWithArgs method")
//			},
//			FTTagValsFunc: func(ctx context.Context, index string, field string) *redis.StringSliceCmd {
//				panic("mock out the FTTagVals method")
//			},
//			FT_ListFunc: func(ctx context.Context) *redis.StringSliceCmd {
//				panic("mock out the FT_List method")
//			},
//			FlushAllFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the FlushAll method")
//			},
//			FlushAllAsyncFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the FlushAllAsync method")
//			},
//			FlushDBFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the FlushDB method")
//			},
//			FlushDBAsyncFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the FlushDBAsync method")
//			},
//			FunctionDeleteFunc: func(ctx context.Context, libName string) *redis.StringCmd {
//				panic("mock out the FunctionDelete method")
//			},
//			FunctionDumpFunc: func(ctx context.Context) *redis.StringCmd {
//				panic("mock out the FunctionDump method")
//			},
//			FunctionFlushFunc: func(ctx context.Context) *redis.StringCmd {
//				panic("mock out the FunctionFlush method")
//			},
//			FunctionFlushAsyncFunc: func(ctx context.Context) *redis.StringCmd {
//				panic("mock out the FunctionFlushAsync method")
//			},
//			FunctionKillFunc: func(ctx context.Context) *redis.StringCmd {
//				panic("mock out the FunctionKill method")
//			},
//			FunctionListFunc: func(ctx context.Context, q redis.FunctionListQuery) *redis.FunctionListCmd {
//				panic("mock out the FunctionList method")
//			},
//			FunctionLoadFunc: func(ctx context.Context, code string) *redis.StringCmd {
//				panic("mock out the FunctionLoad method")
//			},
//			FunctionLoadReplaceFunc: func(ctx context.Context, code string) *redis.StringCmd {
//				panic("mock out the FunctionLoadReplace method")
//			},
//			FunctionRestoreFunc: func(ctx context.Context, libDump string) *redis.StringCmd {
//				panic("mock out the FunctionRestore method")
//			},
//			FunctionStatsFunc: func(ctx context.Context) *redis.FunctionStatsCmd {
//				panic("mock out the FunctionStats method")
//			},
//			GeoAddFunc: func(ctx context.Context, key string, geoLocation ...*redis.GeoLocation) *redis.IntCmd {
//				panic("mock out the GeoAdd method")
//			},
//			GeoDistFunc: func(ctx context.Context, key string, member1 string, member2 string, unit string) *redis.FloatCmd {
//				panic("mock out the GeoDist method")
//			},
//			GeoHashFunc: func(ctx context.Context, key string, members ...string) *redis.StringSliceCmd {
//				panic("mock out the GeoHash method")
//			},
//			GeoPosFunc: func(ctx context.Context, key string, members ...string) *redis.GeoPosCmd {
//				panic("mock out the GeoPos method")
//			},
//			GeoRadiusFunc: func(ctx context.Context, key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
//				panic("mock out the GeoRadius method")
//			},
//			GeoRadiusByMemberFunc: func(ctx context.Context, key string, member string, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
//				panic("mock out the GeoRadiusByMember method")
//			},
//			GeoRadiusByMemberStoreFunc: func(ctx context.Context, key string, member string, query *redis.GeoRadiusQuery) *redis.IntCmd {
//				panic("mock out the GeoRadiusByMemberStore method")
//			},
//			GeoRadiusStoreFunc: func(ctx context.Context, key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.IntCmd {
//				panic("mock out the GeoRadiusStore method")
//			},
//			GeoSearchFunc: func(ctx context.Context, key string, q *redis.GeoSearchQuery) *redis.StringSliceCmd {
//				panic("mock out the GeoSearch method")
//			},
//			GeoSearchLocationFunc: func(ctx context.Context, key string, q *redis.GeoSearchLocationQuery) *redis.GeoSearchLocationCmd {
//				panic("mock out the GeoSearchLocation method")
//			},
//			GeoSearchStoreFunc: func(ctx context.Context, key string, store string, q *redis.GeoSearchStoreQuery) *redis.IntCmd {
//				panic("mock out the GeoSearchStore method")
//			},
//			GetFunc: func(ctx context.Context, key string) *redis.StringCmd {
//				panic("mock out the Get method")
//			},
//			GetBitFunc: func(ctx context.Context, key string, offset int64) *redis.IntCmd {
//				panic("mock out the GetBit method")
//			},
//			GetDelFunc: func(ctx context.Context, key string) *redis.StringCmd {
//				panic("mock out the GetDel method")
//			},
//			GetExFunc: func(ctx context.Context, key string, expiration time.Duration) *redis.StringCmd {
//				panic("mock out the GetEx method")
//			},
//			GetRangeFunc: func(ctx context.Context, key string, start int64, end int64) *redis.StringCmd {
//				panic("mock out the GetRange method")
//			},
//			GetSetFunc: func(ctx context.Context, key string, value interface{}) *redis.StringCmd {
//				panic("mock out the GetSet method")
//			},
//			HDelFunc: func(ctx context.Context, key string, fields ...string) *redis.IntCmd {
//				panic("mock out the HDel method")
//			},
//			HExistsFunc: func(ctx context.Context, key string, field string) *redis.BoolCmd {
//				panic("mock out the HExists method")
//			},
//			HExpireFunc: func(ctx context.Context, key string, expiration time.Duration, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HExpire method")
//			},
//			HExpireAtFunc: func(ctx context.Context, key string, tm time.Time, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HExpireAt method")
//			},
//			HExpireAtWithArgsFunc: func(ctx context.Context, key string, tm time.Time, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HExpireAtWithArgs method")
//			},
//			HExpireTimeFunc: func(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HExpireTime method")
//			},
//			HExpireWithArgsFunc: func(ctx context.Context, key string, expiration time.Duration, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HExpireWithArgs method")
//			},
//			HGetFunc: func(ctx context.Context, key string, field string) *redis.StringCmd {
//				panic("mock out the HGet method")
//			},
//			HGetAllFunc: func(ctx context.Context, key string) *redis.MapStringStringCmd {
//				panic("mock out the HGetAll method")
//			},
//			HGetDelFunc: func(ctx context.Context, key string, fields ...string) *redis.StringSliceCmd {
//				panic("mock out the HGetDel method")
//			},
//			HGetEXFunc: func(ctx context.Context, key string, fields ...string) *redis.StringSliceCmd {
//				panic("mock out the HGetEX method")
//			},
//			HGetEXWithArgsFunc: func(ctx context.Context, key string, options *redis.HGetEXOptions, fields ...string) *redis.StringSliceCmd {
//				panic("mock out the HGetEXWithArgs method")
//			},
//			HIncrByFunc: func(ctx context.Context, key string, field string, incr int64) *redis.IntCmd {
//				panic("mock out the HIncrBy method")
//			},
//			HIncrByFloatFunc: func(ctx context.Context, key string, field string, incr float64) *redis.FloatCmd {
//				panic("mock out the HIncrByFloat method")
//			},
//			HKeysFunc: func(ctx context.Context, key string) *redis.StringSliceCmd {
//				panic("mock out the HKeys method")
//			},
//			HLenFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the HLen method")
//			},
//			HMGetFunc: func(ctx context.Context, key string, fields ...string) *redis.SliceCmd {
//				panic("mock out the HMGet method")
//			},
//			HMSetFunc: func(ctx context.Context, key string, values ...interface{}) *redis.BoolCmd {
//				panic("mock out the HMSet method")
//			},
//			HPExpireFunc: func(ctx context.Context, key string, expiration time.Duration, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HPExpire method")
//			},
//			HPExpireAtFunc: func(ctx context.Context, key string, tm time.Time, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HPExpireAt method")
//			},
//			HPExpireAtWithArgsFunc: func(ctx context.Context, key string, tm time.Time, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HPExpireAtWithArgs method")
//			},
//			HPExpireTimeFunc: func(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HPExpireTime method")
//			},
//			HPExpireWithArgsFunc: func(ctx context.Context, key string, expiration time.Duration, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HPExpireWithArgs method")
//			},
//			HPTTLFunc: func(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HPTTL method")
//			},
//			HPersistFunc: func(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HPersist method")
//			},
//			HRandFieldFunc: func(ctx context.Context, key string, count int) *redis.StringSliceCmd {
//				panic("mock out the HRandField method")
//			},
//			HRandFieldWithValuesFunc: func(ctx context.Context, key string, count int) *redis.KeyValueSliceCmd {
//				panic("mock out the HRandFieldWithValues method")
//			},
//			HScanFunc: func(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
//				panic("mock out the HScan method")
//			},
//			HScanNoValuesFunc: func(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
//				panic("mock out the HScanNoValues method")
//			},
//			HSetFunc: func(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
//				panic("mock out the HSet method")
//			},
//			HSetEXFunc: func(ctx context.Context, key string, fieldsAndValues ...string) *redis.IntCmd {
//				panic("mock out the HSetEX method")
//			},
//			HSetEXWithArgsFunc: func(ctx context.Context, key string, options *redis.HSetEXOptions, fieldsAndValues ...string) *redis.IntCmd {
//				panic("mock out the HSetEXWithArgs method")
//			},
//			HSetNXFunc: func(ctx context.Context, key string, field string, value interface{}) *redis.BoolCmd {
//				panic("mock out the HSetNX method")
//			},
//			HStrLenFunc: func(ctx context.Context, key string, field string) *redis.IntCmd {
//				panic("mock out the HStrLen method")
//			},
//			HTTLFunc: func(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
//				panic("mock out the HTTL method")
//			},
//			HValsFunc: func(ctx context.Context, key string) *redis.StringSliceCmd {
//				panic("mock out the HVals method")
//			},
//			IncrFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the Incr method")
//			},
//			IncrByFunc: func(ctx context.Context, key string, value int64) *redis.IntCmd {
//				panic("mock out the IncrBy method")
//			},
//			IncrByFloatFunc: func(ctx context.Context, key string, value float64) *redis.FloatCmd {
//				panic("mock out the IncrByFloat method")
//			},
//			InfoFunc: func(ctx context.Context, section ...string) *redis.StringCmd {
//				panic("mock out the Info method")
//			},
//			JSONArrAppendFunc: func(ctx context.Context, key string, path string, values ...interface{}) *redis.IntSliceCmd {
//				panic("mock out the JSONArrAppend method")
//			},
//			JSONArrIndexFunc: func(ctx context.Context, key string, path string, value ...interface{}) *redis.IntSliceCmd {
//				panic("mock out the JSONArrIndex method")
//			},
//			JSONArrIndexWithArgsFunc: func(ctx context.Context, key string, path string, options *redis.JSONArrIndexArgs, value ...interface{}) *redis.IntSliceCmd {
//				panic("mock out the JSONArrIndexWithArgs method")
//			},
//			JSONArrInsertFunc: func(ctx context.Context, key string, path string, index int64, values ...interface{}) *redis.IntSliceCmd {
//				panic("mock out the JSONArrInsert method")
//			},
//			JSONArrLenFunc: func(ctx context.Context, key string, path string) *redis.IntSliceCmd {
//				panic("mock out the JSONArrLen method")
//			},
//			JSONArrPopFunc: func(ctx context.Context, key string, path string, index int) *redis.StringSliceCmd {
//				panic("mock out the JSONArrPop method")
//			},
//			JSONArrTrimFunc: func(ctx context.Context, key string, path string) *redis.IntSliceCmd {
//				panic("mock out the JSONArrTrim method")
//			},
//			JSONArrTrimWithArgsFunc: func(ctx context.Context, key string, path string, options *redis.JSONArrTrimArgs) *redis.IntSliceCmd {
//				panic("mock out the JSONArrTrimWithArgs method")
//			},
//			JSONClearFunc: func(ctx context.Context, key string, path string) *redis.IntCmd {
//				panic("mock out the JSONClear method")
//			},
//			JSONDebugMemoryFunc: func(ctx context.Context, key string, path string) *redis.IntCmd {
//				panic("mock out the JSONDebugMemory method")
//			},
//			JSONDelFunc: func(ctx context.Context, key string, path string) *redis.IntCmd {
//				panic("mock out the JSONDel method")
//			},
//			JSONForgetFunc: func(ctx context.Context, key string, path string) *redis.IntCmd {
//				panic("mock out the JSONForget method")
//			},
//			JSONGetFunc: func(ctx context.Context, key string, paths ...string) *redis.JSONCmd {
//				panic("mock out the JSONGet method")
//			},
//			JSONGetWithArgsFunc: func(ctx context.Context, key string, options *redis.JSONGetArgs, paths ...string) *redis.JSONCmd {
//				panic("mock out the JSONGetWithArgs method")
//			},
//			JSONMGetFunc: func(ctx context.Context, path string, keys ...string) *redis.JSONSliceCmd {
//				panic("mock out the JSONMGet method")
//			},
//			JSONMSetFunc: func(ctx context.Context, params ...interface{}) *redis.StatusCmd {
//				panic("mock out the JSONMSet method")
//			},
//			JSONMSetArgsFunc: func(ctx context.Context, docs []redis.JSONSetArgs) *redis.StatusCmd {
//				panic("mock out the JSONMSetArgs method")
//			},
//			JSONMergeFunc: func(ctx context.Context, key string, path string, value string) *redis.StatusCmd {
//				panic("mock out the JSONMerge method")
//			},
//			JSONNumIncrByFunc: func(ctx context.Context, key string, path string, value float64) *redis.JSONCmd {
//				panic("mock out the JSONNumIncrBy method")
//			},
//			JSONObjKeysFunc: func(ctx context.Context, key string, path string) *redis.SliceCmd {
//				panic("mock out the JSONObjKeys method")
//			},
//			JSONObjLenFunc: func(ctx context.Context, key string, path string) *redis.IntPointerSliceCmd {
//				panic("mock out the JSONObjLen method")
//			},
//			JSONSetFunc: func(ctx context.Context, key string, path string, value interface{}) *redis.StatusCmd {
//				panic("mock out the JSONSet method")
//			},
//			JSONSetModeFunc: func(ctx context.Context, key string, path string, value interface{}, mode string) *redis.StatusCmd {
//				panic("mock out the JSONSetMode method")
//			},
//			JSONStrAppendFunc: func(ctx context.Context, key string, path string, value string) *redis.IntPointerSliceCmd {
//				panic("mock out the JSONStrAppend method")
//			},
//			JSONStrLenFunc: func(ctx context.Context, key string, path string) *redis.IntPointerSliceCmd {
//				panic("mock out the JSONStrLen method")
//			},
//			JSONToggleFunc: func(ctx context.Context, key string, path string) *redis.IntPointerSliceCmd {
//				panic("mock out the JSONToggle method")
//			},
//			JSONTypeFunc: func(ctx context.Context, key string, path string) *redis.JSONSliceCmd {
//				panic("mock out the JSONType method")
//			},
//			KeysFunc: func(ctx context.Context, pattern string) *redis.StringSliceCmd {
//				panic("mock out the Keys method")
//			},
//			LCSFunc: func(ctx context.Context, q *redis.LCSQuery) *redis.LCSCmd {
//				panic("mock out the LCS method")
//			},
//			LIndexFunc: func(ctx context.Context, key string, index int64) *redis.StringCmd {
//				panic("mock out the LIndex method")
//			},
//			LInsertFunc: func(ctx context.Context, key string, op string, pivot interface{}, value interface{}) *redis.IntCmd {
//				panic("mock out the LInsert method")
//			},
//			LInsertAfterFunc: func(ctx context.Context, key string, pivot interface{}, value interface{}) *redis.IntCmd {
//				panic("mock out the LInsertAfter method")
//			},
//			LInsertBeforeFunc: func(ctx context.Context, key string, pivot interface{}, value interface{}) *redis.IntCmd {
//				panic("mock out the LInsertBefore method")
//			},
//			LLenFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the LLen method")
//			},
//			LMPopFunc: func(ctx context.Context, direction string, count int64, keys ...string) *redis.KeyValuesCmd {
//				panic("mock out the LMPop method")
//			},
//			LMoveFunc: func(ctx context.Context, source string, destination string, srcpos string, destpos string) *redis.StringCmd {
//				panic("mock out the LMove method")
//			},
//			LPopFunc: func(ctx context.Context, key string) *redis.StringCmd {
//				panic("mock out the LPop method")
//			},
//			LPopCountFunc: func(ctx context.Context, key string, count int) *redis.StringSliceCmd {
//				panic("mock out the LPopCount method")
//			},
//			LPosFunc: func(ctx context.Context, key string, value string, args redis.LPosArgs) *redis.IntCmd {
//				panic("mock out the LPos method")
//			},
//			LPosCountFunc: func(ctx context.Context, key string, value string, count int64, args redis.LPosArgs) *redis.IntSliceCmd {
//				panic("mock out the LPosCount method")
//			},
//			LPushFunc: func(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
//				panic("mock out the LPush method")
//			},
//			LPushXFunc: func(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
//				panic("mock out the LPushX method")
//			},
//			LRangeFunc: func(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd {
//				panic("mock out the LRange method")
//			},
//			LRemFunc: func(ctx context.Context, key string, count int64, value interface{}) *redis.IntCmd {
//				panic("mock out the LRem method")
//			},
//			LSetFunc: func(ctx context.Context, key string, index int64, value interface{}) *redis.StatusCmd {
//				panic("mock out the LSet method")
//			},
//			LTrimFunc: func(ctx context.Context, key string, start int64, stop int64) *redis.StatusCmd {
//				panic("mock out the LTrim method")
//			},
//			LastSaveFunc: func(ctx context.Context) *redis.IntCmd {
//				panic("mock out the LastSave method")
//			},
//			MGetFunc: func(ctx context.Context, keys ...string) *redis.SliceCmd {
//				panic("mock out the MGet method")
//			},
//			MSetFunc: func(ctx context.Context, values ...interface{}) *redis.StatusCmd {
//				panic("mock out the MSet method")
//			},
//			MSetNXFunc: func(ctx context.Context, values ...interface{}) *redis.BoolCmd {
//				panic("mock out the MSetNX method")
//			},
//			MemoryUsageFunc: func(ctx context.Context, key string, samples ...int) *redis.IntCmd {
//				panic("mock out the MemoryUsage method")
//			},
//			MigrateFunc: func(ctx context.Context, host string, port string, key string, db int, timeout time.Duration) *redis.StatusCmd {
//				panic("mock out the Migrate method")
//			},
//			ModuleLoadexFunc: func(ctx context.Context, conf *redis.ModuleLoadexConfig) *redis.StringCmd {
//				panic("mock out the ModuleLoadex method")
//			},
//			MoveFunc: func(ctx context.Context, key string, db int) *redis.BoolCmd {
//				panic("mock out the Move method")
//			},
//			ObjectEncodingFunc: func(ctx context.Context, key string) *redis.StringCmd {
//				panic("mock out the ObjectEncoding method")
//			},
//			ObjectFreqFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the ObjectFreq method")
//			},
//			ObjectIdleTimeFunc: func(ctx context.Context, key string) *redis.DurationCmd {
//				panic("mock out the ObjectIdleTime method")
//			},
//			ObjectRefCountFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the ObjectRefCount method")
//			},
//			PExpireFunc: func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
//				panic("mock out the PExpire method")
//			},
//			PExpireAtFunc: func(ctx context.Context, key string, tm time.Time) *redis.BoolCmd {
//				panic("mock out the PExpireAt method")
//			},
//			PExpireTimeFunc: func(ctx context.Context, key string) *redis.DurationCmd {
//				panic("mock out the PExpireTime method")
//			},
//			PFAddFunc: func(ctx context.Context, key string, els ...interface{}) *redis.IntCmd {
//				panic("mock out the PFAdd method")
//			},
//			PFCountFunc: func(ctx context.Context, keys ...string) *redis.IntCmd {
//				panic("mock out the PFCount method")
//			},
//			PFMergeFunc: func(ctx context.Context, dest string, keys ...string) *redis.StatusCmd {
//				panic("mock out the PFMerge method")
//			},
//			PSubscribeFunc: func(ctx context.Context, channels ...string) *redis.PubSub {
//				panic("mock out the PSubscribe method")
//			},
//			PTTLFunc: func(ctx context.Context, key string) *redis.DurationCmd {
//				panic("mock out the PTTL method")
//			},
//			PersistFunc: func(ctx context.Context, key string) *redis.BoolCmd {
//				panic("mock out the Persist method")
//			},
//			PingFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the Ping method")
//			},
//			PipelineFunc: func() redis.Pipeliner {
//				panic("mock out the Pipeline method")
//			},
//			PipelinedFunc: func(ctx context.Context, fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
//				panic("mock out the Pipelined method")
//			},
//			PoolStatsFunc: func() *redis.PoolStats {
//				panic("mock out the PoolStats method")
//			},
//			ProcessFunc: func(ctx context.Context, cmd redis.Cmder) error {
//				panic("mock out the Process method")
//			},
//			PubSubChannelsFunc: func(ctx context.Context, pattern string) *redis.StringSliceCmd {
//				panic("mock out the PubSubChannels method")
//			},
//			PubSubNumPatFunc: func(ctx context.Context) *redis.IntCmd {
//				panic("mock out the PubSubNumPat method")
//			},
//			PubSubNumSubFunc: func(ctx context.Context, channels ...string) *redis.MapStringIntCmd {
//				panic("mock out the PubSubNumSub method")
//			},
//			PubSubShardChannelsFunc: func(ctx context.Context, pattern string) *redis.StringSliceCmd {
//				panic("mock out the PubSubShardChannels method")
//			},
//			PubSubShardNumSubFunc: func(ctx context.Context, channels ...string) *redis.MapStringIntCmd {
//				panic("mock out the PubSubShardNumSub method")
//			},
//			PublishFunc: func(ctx context.Context, channel string, message interface{}) *redis.IntCmd {
//				panic("mock out the Publish method")
//			},
//			QuitFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the Quit method")
//			},
//			RPopFunc: func(ctx context.Context, key string) *redis.StringCmd {
//				panic("mock out the RPop method")
//			},
//			RPopCountFunc: func(ctx context.Context, key string, count int) *redis.StringSliceCmd {
//				panic("mock out the RPopCount method")
//			},
//			RPopLPushFunc: func(ctx context.Context, source string, destination string) *redis.StringCmd {
//				panic("mock out the RPopLPush method")
//			},
//			RPushFunc: func(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
//				panic("mock out the RPush method")
//			},
//			RPushXFunc: func(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
//				panic("mock out the RPushX method")
//			},
//			RandomKeyFunc: func(ctx context.Context) *redis.StringCmd {
//				panic("mock out the RandomKey method")
//			},
//			ReadOnlyFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ReadOnly method")
//			},
//			ReadWriteFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ReadWrite method")
//			},
//			RenameFunc: func(ctx context.Context, key string, newkey string) *redis.StatusCmd {
//				panic("mock out the Rename method")
//			},
//			RenameNXFunc: func(ctx context.Context, key string, newkey string) *redis.BoolCmd {
//				panic("mock out the RenameNX method")
//			},
//			RestoreFunc: func(ctx context.Context, key string, ttl time.Duration, value string) *redis.StatusCmd {
//				panic("mock out the Restore method")
//			},
//			RestoreReplaceFunc: func(ctx context.Context, key string, ttl time.Duration, value string) *redis.StatusCmd {
//				panic("mock out the RestoreReplace method")
//			},
//			SAddFunc: func(ctx context.Context, key string, members ...interface{}) *redis.IntCmd {
//				panic("mock out the SAdd method")
//			},
//			SCardFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the SCard method")
//			},
//			SDiffFunc: func(ctx context.Context, keys ...string) *redis.StringSliceCmd {
//				panic("mock out the SDiff method")
//			},
//			SDiffStoreFunc: func(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
//				panic("mock out the SDiffStore method")
//			},
//			SInterFunc: func(ctx context.Context, keys ...string) *redis.StringSliceCmd {
//				panic("mock out the SInter method")
//			},
//			SInterCardFunc: func(ctx context.Context, limit int64, keys ...string) *redis.IntCmd {
//				panic("mock out the SInterCard method")
//			},
//			SInterStoreFunc: func(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
//				panic("mock out the SInterStore method")
//			},
//			SIsMemberFunc: func(ctx context.Context, key string, member interface{}) *redis.BoolCmd {
//				panic("mock out the SIsMember method")
//			},
//			SMIsMemberFunc: func(ctx context.Context, key string, members ...interface{}) *redis.BoolSliceCmd {
//				panic("mock out the SMIsMember method")
//			},
//			SMembersFunc: func(ctx context.Context, key string) *redis.StringSliceCmd {
//				panic("mock out the SMembers method")
//			},
//			SMembersMapFunc: func(ctx context.Context, key string) *redis.StringStructMapCmd {
//				panic("mock out the SMembersMap method")
//			},
//			SMoveFunc: func(ctx context.Context, source string, destination string, member interface{}) *redis.BoolCmd {
//				panic("mock out the SMove method")
//			},
//			SPopFunc: func(ctx context.Context, key string) *redis.StringCmd {
//				panic("mock out the SPop method")
//			},
//			SPopNFunc: func(ctx context.Context, key string, count int64) *redis.StringSliceCmd {
//				panic("mock out the SPopN method")
//			},
//			SPublishFunc: func(ctx context.Context, channel string, message interface{}) *redis.IntCmd {
//				panic("mock out the SPublish method")
//			},
//			SRandMemberFunc: func(ctx context.Context, key string) *redis.StringCmd {
//				panic("mock out the SRandMember method")
//			},
//			SRandMemberNFunc: func(ctx context.Context, key string, count int64) *redis.StringSliceCmd {
//				panic("mock out the SRandMemberN method")
//			},
//			SRemFunc: func(ctx context.Context, key string, members ...interface{}) *redis.IntCmd {
//				panic("mock out the SRem method")
//			},
//			SScanFunc: func(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
//				panic("mock out the SScan method")
//			},
//			SSubscribeFunc: func(ctx context.Context, channels ...string) *redis.PubSub {
//				panic("mock out the SSubscribe method")
//			},
//			SUnionFunc: func(ctx context.Context, keys ...string) *redis.StringSliceCmd {
//				panic("mock out the SUnion method")
//			},
//			SUnionStoreFunc: func(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
//				panic("mock out the SUnionStore method")
//			},
//			SaveFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the Save method")
//			},
//			ScanFunc: func(ctx context.Context, cursor uint64, match string, count int64) *redis.ScanCmd {
//				panic("mock out the Scan method")
//			},
//			ScanTypeFunc: func(ctx context.Context, cursor uint64, match string, count int64, keyType string) *redis.ScanCmd {
//				panic("mock out the ScanType method")
//			},
//			ScriptExistsFunc: func(ctx context.Context, hashes ...string) *redis.BoolSliceCmd {
//				panic("mock out the ScriptExists method")
//			},
//			ScriptFlushFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ScriptFlush method")
//			},
//			ScriptKillFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ScriptKill method")
//			},
//			ScriptLoadFunc: func(ctx context.Context, script string) *redis.StringCmd {
//				panic("mock out the ScriptLoad method")
//			},
//			SetFunc: func(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.StatusCmd {
//				panic("mock out the Set method")
//			},
//			SetArgsFunc: func(ctx context.Context, key string, value interface{}, a redis.SetArgs) *redis.StatusCmd {
//				panic("mock out the SetArgs method")
//			},
//			SetBitFunc: func(ctx context.Context, key string, offset int64, value int) *redis.IntCmd {
//				panic("mock out the SetBit method")
//			},
//			SetExFunc: func(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.StatusCmd {
//				panic("mock out the SetEx method")
//			},
//			SetNXFunc: func(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.BoolCmd {
//				panic("mock out the SetNX method")
//			},
//			SetRangeFunc: func(ctx context.Context, key string, offset int64, value string) *redis.IntCmd {
//				panic("mock out the SetRange method")
//			},
//			SetXXFunc: func(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.BoolCmd {
//				panic("mock out the SetXX method")
//			},
//			ShutdownFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the Shutdown method")
//			},
//			ShutdownNoSaveFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ShutdownNoSave method")
//			},
//			ShutdownSaveFunc: func(ctx context.Context) *redis.StatusCmd {
//				panic("mock out the ShutdownSave method")
//			},
//			SlaveOfFunc: func(ctx context.Context, host string, port string) *redis.StatusCmd {
//				panic("mock out the SlaveOf method")
//			},
//			SlowLogGetFunc: func(ctx context.Context, num int64) *redis.SlowLogCmd {
//				panic("mock out the SlowLogGet method")
//			},
//			SortFunc: func(ctx context.Context, key string, sort *redis.Sort) *redis.StringSliceCmd {
//				panic("mock out the Sort method")
//			},
//			SortInterfacesFunc: func(ctx context.Context, key string, sort *redis.Sort) *redis.SliceCmd {
//				panic("mock out the SortInterfaces method")
//			},
//			SortROFunc: func(ctx context.Context, key string, sort *redis.Sort) *redis.StringSliceCmd {
//				panic("mock out the SortRO method")
//			},
//			SortStoreFunc: func(ctx context.Context, key string, store string, sort *redis.Sort) *redis.IntCmd {
//				panic("mock out the SortStore method")
//			},
//			StrLenFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the StrLen method")
//			},
//			SubscribeFunc: func(ctx context.Context, channels ...string) *redis.PubSub {
//				panic("mock out the Subscribe method")
//			},
//			TDigestAddFunc: func(ctx context.Context, key string, elements ...float64) *redis.StatusCmd {
//				panic("mock out the TDigestAdd method")
//			},
//			TDigestByRankFunc: func(ctx context.Context, key string, rank ...uint64) *redis.FloatSliceCmd {
//				panic("mock out the TDigestByRank method")
//			},
//			TDigestByRevRankFunc: func(ctx context.Context, key string, rank ...uint64) *redis.FloatSliceCmd {
//				panic("mock out the TDigestByRevRank method")
//			},
//			TDigestCDFFunc: func(ctx context.Context, key string, elements ...float64) *redis.FloatSliceCmd {
//				panic("mock out the TDigestCDF method")
//			},
//			TDigestCreateFunc: func(ctx context.Context, key string) *redis.StatusCmd {
//				panic("mock out the TDigestCreate method")
//			},
//			TDigestCreateWithCompressionFunc: func(ctx context.Context, key string, compression int64) *redis.StatusCmd {
//				panic("mock out the TDigestCreateWithCompression method")
//			},
//			TDigestInfoFunc: func(ctx context.Context, key string) *redis.TDigestInfoCmd {
//				panic("mock out the TDigestInfo method")
//			},
//			TDigestMaxFunc: func(ctx context.Context, key string) *redis.FloatCmd {
//				panic("mock out the TDigestMax method")
//			},
//			TDigestMergeFunc: func(ctx context.Context, destKey string, options *redis.TDigestMergeOptions, sourceKeys ...string) *redis.StatusCmd {
//				panic("mock out the TDigestMerge method")
//			},
//			TDigestMinFunc: func(ctx context.Context, key string) *redis.FloatCmd {
//				panic("mock out the TDigestMin method")
//			},
//			TDigestQuantileFunc: func(ctx context.Context, key string, elements ...float64) *redis.FloatSliceCmd {
//				panic("mock out the TDigestQuantile method")
//			},
//			TDigestRankFunc: func(ctx context.Context, key string, values ...float64) *redis.IntSliceCmd {
//				panic("mock out the TDigestRank method")
//			},
//			TDigestResetFunc: func(ctx context.Context, key string) *redis.StatusCmd {
//				panic("mock out the TDigestReset method")
//			},
//			TDigestRevRankFunc: func(ctx context.Context, key string, values ...float64) *redis.IntSliceCmd {
//				panic("mock out the TDigestRevRank method")
//			},
//			TDigestTrimmedMeanFunc: func(ctx context.Context, key string, lowCutQuantile float64, highCutQuantile float64) *redis.FloatCmd {
//				panic("mock out the TDigestTrimmedMean method")
//			},
//			TSAddFunc: func(ctx context.Context, key string, timestamp interface{}, value float64) *redis.IntCmd {
//				panic("mock out the TSAdd method")
//			},
//			TSAddWithArgsFunc: func(ctx context.Context, key string, timestamp interface{}, value float64, options *redis.TSOptions) *redis.IntCmd {
//				panic("mock out the TSAddWithArgs method")
//			},
//			TSAlterFunc: func(ctx context.Context, key string, options *redis.TSAlterOptions) *redis.StatusCmd {
//				panic("mock out the TSAlter method")
//			},
//			TSCreateFunc: func(ctx context.Context, key string) *redis.StatusCmd {
//				panic("mock out the TSCreate method")
//			},
//			TSCreateRuleFunc: func(ctx context.Context, sourceKey string, destKey string, aggregator redis.Aggregator, bucketDuration int) *redis.StatusCmd {
//				panic("mock out the TSCreateRule method")
//			},
//			TSCreateRuleWithArgsFunc: func(ctx context.Context, sourceKey string, destKey string, aggregator redis.Aggregator, bucketDuration int, options *redis.TSCreateRuleOptions) *redis.StatusCmd {
//				panic("mock out the TSCreateRuleWithArgs method")
//			},
//			TSCreateWithArgsFunc: func(ctx context.Context, key string, options *redis.TSOptions) *redis.StatusCmd {
//				panic("mock out the TSCreateWithArgs method")
//			},
//			TSDecrByFunc: func(ctx context.Context, Key string, timestamp float64) *redis.IntCmd {
//				panic("mock out the TSDecrBy method")
//			},
//			TSDecrByWithArgsFunc: func(ctx context.Context, key string, timestamp float64, options *redis.TSIncrDecrOptions) *redis.IntCmd {
//				panic("mock out the TSDecrByWithArgs method")
//			},
//			TSDelFunc: func(ctx context.Context, Key string, fromTimestamp int, toTimestamp int) *redis.IntCmd {
//				panic("mock out the TSDel method")
//			},
//			TSDeleteRuleFunc: func(ctx context.Context, sourceKey string, destKey string) *redis.StatusCmd {
//				panic("mock out the TSDeleteRule method")
//			},
//			TSGetFunc: func(ctx context.Context, key string) *redis.TSTimestampValueCmd {
//				panic("mock out the TSGet method")
//			},
//			TSGetWithArgsFunc: func(ctx context.Context, key string, options *redis.TSGetOptions) *redis.TSTimestampValueCmd {
//				panic("mock out the TSGetWithArgs method")
//			},
//			TSIncrByFunc: func(ctx context.Context, Key string, timestamp float64) *redis.IntCmd {
//				panic("mock out the TSIncrBy method")
//			},
//			TSIncrByWithArgsFunc: func(ctx context.Context, key string, timestamp float64, options *redis.TSIncrDecrOptions) *redis.IntCmd {
//				panic("mock out the TSIncrByWithArgs method")
//			},
//			TSInfoFunc: func(ctx context.Context, key string) *redis.MapStringInterfaceCmd {
//				panic("mock out the TSInfo method")
//			},
//			TSInfoWithArgsFunc: func(ctx context.Context, key string, options *redis.TSInfoOptions) *redis.MapStringInterfaceCmd {
//				panic("mock out the TSInfoWithArgs method")
//			},
//			TSMAddFunc: func(ctx context.Context, ktvSlices [][]interface{}) *redis.IntSliceCmd {
//				panic("mock out the TSMAdd method")
//			},
//			TSMGetFunc: func(ctx context.Context, filters []string) *redis.MapStringSliceInterfaceCmd {
//				panic("mock out the TSMGet method")
//			},
//			TSMGetWithArgsFunc: func(ctx context.Context, filters []string, options *redis.TSMGetOptions) *redis.MapStringSliceInterfaceCmd {
//				panic("mock out the TSMGetWithArgs method")
//			},
//			TSMRangeFunc: func(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string) *redis.MapStringSliceInterfaceCmd {
//				panic("mock out the TSMRange method")
//			},
//			TSMRangeWithArgsFunc: func(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string, options *redis.TSMRangeOptions) *redis.MapStringSliceInterfaceCmd {
//				panic("mock out the TSMRangeWithArgs method")
//			},
//			TSMRevRangeFunc: func(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string) *redis.MapStringSliceInterfaceCmd {
//				panic("mock out the TSMRevRange method")
//			},
//			TSMRevRangeWithArgsFunc: func(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string, options *redis.TSMRevRangeOptions) *redis.MapStringSliceInterfaceCmd {
//				panic("mock out the TSMRevRangeWithArgs method")
//			},
//			TSQueryIndexFunc: func(ctx context.Context, filterExpr []string) *redis.StringSliceCmd {
//				panic("mock out the TSQueryIndex method")
//			},
//			TSRangeFunc: func(ctx context.Context, key string, fromTimestamp int, toTimestamp int) *redis.TSTimestampValueSliceCmd {
//				panic("mock out the TSRange method")
//			},
//			TSRangeWithArgsFunc: func(ctx context.Context, key string, fromTimestamp int, toTimestamp int, options *redis.TSRangeOptions) *redis.TSTimestampValueSliceCmd {
//				panic("mock out the TSRangeWithArgs method")
//			},
//			TSRevRangeFunc: func(ctx context.Context, key string, fromTimestamp int, toTimestamp int) *redis.TSTimestampValueSliceCmd {
//				panic("mock out the TSRevRange method")
//			},
//			TSRevRangeWithArgsFunc: func(ctx context.Context, key string, fromTimestamp int, toTimestamp int, options *redis.TSRevRangeOptions) *redis.TSTimestampValueSliceCmd {
//				panic("mock out the TSRevRangeWithArgs method")
//			},
//			TTLFunc: func(ctx context.Context, key string) *redis.DurationCmd {
//				panic("mock out the TTL method")
//			},
//			TimeFunc: func(ctx context.Context) *redis.TimeCmd {
//				panic("mock out the Time method")
//			},
//			TopKAddFunc: func(ctx context.Context, key string, elements ...interface{}) *redis.StringSliceCmd {
//				panic("mock out the TopKAdd method")
//			},
//			TopKCountFunc: func(ctx context.Context, key string, elements ...interface{}) *redis.IntSliceCmd {
//				panic("mock out the TopKCount method")
//			},
//			TopKIncrByFunc: func(ctx context.Context, key string, elements ...interface{}) *redis.StringSliceCmd {
//				panic("mock out the TopKIncrBy method")
//			},
//			TopKInfoFunc: func(ctx context.Context, key string) *redis.TopKInfoCmd {
//				panic("mock out the TopKInfo method")
//			},
//			TopKListFunc: func(ctx context.Context, key string) *redis.StringSliceCmd {
//				panic("mock out the TopKList method")
//			},
//			TopKListWithCountFunc: func(ctx context.Context, key string) *redis.MapStringIntCmd {
//				panic("mock out the TopKListWithCount method")
//			},
//			TopKQueryFunc: func(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd {
//				panic("mock out the TopKQuery method")
//			},
//			TopKReserveFunc: func(ctx context.Context, key string, k int64) *redis.StatusCmd {
//				panic("mock out the TopKReserve method")
//			},
//			TopKReserveWithOptionsFunc: func(ctx context.Context, key string, k int64, width int64, depth int64, decay float64) *redis.StatusCmd {
//				panic("mock out the TopKReserveWithOptions method")
//			},
//			TouchFunc: func(ctx context.Context, keys ...string) *redis.IntCmd {
//				panic("mock out the Touch method")
//			},
//			TxPipelineFunc: func() redis.Pipeliner {
//				panic("mock out the TxPipeline method")
//			},
//			TxPipelinedFunc: func(ctx context.Context, fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
//				panic("mock out the TxPipelined method")
//			},
//			TypeFunc: func(ctx context.Context, key string) *redis.StatusCmd {
//				panic("mock out the Type method")
//			},
//			UnlinkFunc: func(ctx context.Context, keys ...string) *redis.IntCmd {
//				panic("mock out the Unlink method")
//			},
//			WatchFunc: func(ctx context.Context, fn func(*redis.Tx) error, keys ...string) error {
//				panic("mock out the Watch method")
//			},
//			XAckFunc: func(ctx context.Context, stream string, group string, ids ...string) *redis.IntCmd {
//				panic("mock out the XAck method")
//			},
//			XAddFunc: func(ctx context.Context, a *redis.XAddArgs) *redis.StringCmd {
//				panic("mock out the XAdd method")
//			},
//			XAutoClaimFunc: func(ctx context.Context, a *redis.XAutoClaimArgs) *redis.XAutoClaimCmd {
//				panic("mock out the XAutoClaim method")
//			},
//			XAutoClaimJustIDFunc: func(ctx context.Context, a *redis.XAutoClaimArgs) *redis.XAutoClaimJustIDCmd {
//				panic("mock out the XAutoClaimJustID method")
//			},
//			XClaimFunc: func(ctx context.Context, a *redis.XClaimArgs) *redis.XMessageSliceCmd {
//				panic("mock out the XClaim method")
//			},
//			XClaimJustIDFunc: func(ctx context.Context, a *redis.XClaimArgs) *redis.StringSliceCmd {
//				panic("mock out the XClaimJustID method")
//			},
//			XDelFunc: func(ctx context.Context, stream string, ids ...string) *redis.IntCmd {
//				panic("mock out the XDel method")
//			},
//			XGroupCreateFunc: func(ctx context.Context, stream string, group string, start string) *redis.StatusCmd {
//				panic("mock out the XGroupCreate method")
//			},
//			XGroupCreateConsumerFunc: func(ctx context.Context, stream string, group string, consumer string) *redis.IntCmd {
//				panic("mock out the XGroupCreateConsumer method")
//			},
//			XGroupCreateMkStreamFunc: func(ctx context.Context, stream string, group string, start string) *redis.StatusCmd {
//				panic("mock out the XGroupCreateMkStream method")
//			},
//			XGroupDelConsumerFunc: func(ctx context.Context, stream string, group string, consumer string) *redis.IntCmd {
//				panic("mock out the XGroupDelConsumer method")
//			},
//			XGroupDestroyFunc: func(ctx context.Context, stream string, group string) *redis.IntCmd {
//				panic("mock out the XGroupDestroy method")
//			},
//			XGroupSetIDFunc: func(ctx context.Context, stream string, group string, start string) *redis.StatusCmd {
//				panic("mock out the XGroupSetID method")
//			},
//			XInfoConsumersFunc: func(ctx context.Context, key string, group string) *redis.XInfoConsumersCmd {
//				panic("mock out the XInfoConsumers method")
//			},
//			XInfoGroupsFunc: func(ctx context.Context, key string) *redis.XInfoGroupsCmd {
//				panic("mock out the XInfoGroups method")
//			},
//			XInfoStreamFunc: func(ctx context.Context, key string) *redis.XInfoStreamCmd {
//				panic("mock out the XInfoStream method")
//			},
//			XInfoStreamFullFunc: func(ctx context.Context, key string, count int) *redis.XInfoStreamFullCmd {
//				panic("mock out the XInfoStreamFull method")
//			},
//			XLenFunc: func(ctx context.Context, stream string) *redis.IntCmd {
//				panic("mock out the XLen method")
//			},
//			XPendingFunc: func(ctx context.Context, stream string, group string) *redis.XPendingCmd {
//				panic("mock out the XPending method")
//			},
//			XPendingExtFunc: func(ctx context.Context, a *redis.XPendingExtArgs) *redis.XPendingExtCmd {
//				panic("mock out the XPendingExt method")
//			},
//			XRangeFunc: func(ctx context.Context, stream string, start string, stop string) *redis.XMessageSliceCmd {
//				panic("mock out the XRange method")
//			},
//			XRangeNFunc: func(ctx context.Context, stream string, start string, stop string, count int64) *redis.XMessageSliceCmd {
//				panic("mock out the XRangeN method")
//			},
//			XReadFunc: func(ctx context.Context, a *redis.XReadArgs) *redis.XStreamSliceCmd {
//				panic("mock out the XRead method")
//			},
//			XReadGroupFunc: func(ctx context.Context, a *redis.XReadGroupArgs) *redis.XStreamSliceCmd {
//				panic("mock out the XReadGroup method")
//			},
//			XReadStreamsFunc: func(ctx context.Context, streams ...string) *redis.XStreamSliceCmd {
//				panic("mock out the XReadStreams method")
//			},
//			XRevRangeFunc: func(ctx context.Context, stream string, start string, stop string) *redis.XMessageSliceCmd {
//				panic("mock out the XRevRange method")
//			},
//			XRevRangeNFunc: func(ctx context.Context, stream string, start string, stop string, count int64) *redis.XMessageSliceCmd {
//				panic("mock out the XRevRangeN method")
//			},
//			XTrimMaxLenFunc: func(ctx context.Context, key string, maxLen int64) *redis.IntCmd {
//				panic("mock out the XTrimMaxLen method")
//			},
//			XTrimMaxLenApproxFunc: func(ctx context.Context, key string, maxLen int64, limit int64) *redis.IntCmd {
//				panic("mock out the XTrimMaxLenApprox method")
//			},
//			XTrimMinIDFunc: func(ctx context.Context, key string, minID string) *redis.IntCmd {
//				panic("mock out the XTrimMinID method")
//			},
//			XTrimMinIDApproxFunc: func(ctx context.Context, key string, minID string, limit int64) *redis.IntCmd {
//				panic("mock out the XTrimMinIDApprox method")
//			},
//			ZAddFunc: func(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
//				panic("mock out the ZAdd method")
//			},
//			ZAddArgsFunc: func(ctx context.Context, key string, args redis.ZAddArgs) *redis.IntCmd {
//				panic("mock out the ZAddArgs method")
//			},
//			ZAddArgsIncrFunc: func(ctx context.Context, key string, args redis.ZAddArgs) *redis.FloatCmd {
//				panic("mock out the ZAddArgsIncr method")
//			},
//			ZAddGTFunc: func(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
//				panic("mock out the ZAddGT method")
//			},
//			ZAddLTFunc: func(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
//				panic("mock out the ZAddLT method")
//			},
//			ZAddNXFunc: func(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
//				panic("mock out the ZAddNX method")
//			},
//			ZAddXXFunc: func(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
//				panic("mock out the ZAddXX method")
//			},
//			ZCardFunc: func(ctx context.Context, key string) *redis.IntCmd {
//				panic("mock out the ZCard method")
//			},
//			ZCountFunc: func(ctx context.Context, key string, min string, max string) *redis.IntCmd {
//				panic("mock out the ZCount method")
//			},
//			ZDiffFunc: func(ctx context.Context, keys ...string) *redis.StringSliceCmd {
//				panic("mock out the ZDiff method")
//			},
//			ZDiffStoreFunc: func(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
//				panic("mock out the ZDiffStore method")
//			},
//			ZDiffWithScoresFunc: func(ctx context.Context, keys ...string) *redis.ZSliceCmd {
//				panic("mock out the ZDiffWithScores method")
//			},
//			ZIncrByFunc: func(ctx context.Context, key string, increment float64, member string) *redis.FloatCmd {
//				panic("mock out the ZIncrBy method")
//			},
//			ZInterFunc: func(ctx context.Context, store *redis.ZStore) *redis.StringSliceCmd {
//				panic("mock out the ZInter method")
//			},
//			ZInterCardFunc: func(ctx context.Context, limit int64, keys ...string) *redis.IntCmd {
//				panic("mock out the ZInterCard method")
//			},
//			ZInterStoreFunc: func(ctx context.Context, destination string, store *redis.ZStore) *redis.IntCmd {
//				panic("mock out the ZInterStore method")
//			},
//			ZInterWithScoresFunc: func(ctx context.Context, store *redis.ZStore) *redis.ZSliceCmd {
//				panic("mock out the ZInterWithScores method")
//			},
//			ZLexCountFunc: func(ctx context.Context, key string, min string, max string) *redis.IntCmd {
//				panic("mock out the ZLexCount method")
//			},
//			ZMPopFunc: func(ctx context.Context, order string, count int64, keys ...string) *redis.ZSliceWithKeyCmd {
//				panic("mock out the ZMPop method")
//			},
//			ZMScoreFunc: func(ctx context.Context, key string, members ...string) *redis.FloatSliceCmd {
//				panic("mock out the ZMScore method")
//			},
//			ZPopMaxFunc: func(ctx context.Context, key string, count ...int64) *redis.ZSliceCmd {
//				panic("mock out the ZPopMax method")
//			},
//			ZPopMinFunc: func(ctx context.Context, key string, count ...int64) *redis.ZSliceCmd {
//				panic("mock out the ZPopMin method")
//			},
//			ZRandMemberFunc: func(ctx context.Context, key string, count int) *redis.StringSliceCmd {
//				panic("mock out the ZRandMember method")
//			},
//			ZRandMemberWithScoresFunc: func(ctx context.Context, key string, count int) *redis.ZSliceCmd {
//				panic("mock out the ZRandMemberWithScores method")
//			},
//			ZRangeFunc: func(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd {
//				panic("mock out the ZRange method")
//			},
//			ZRangeArgsFunc: func(ctx context.Context, z redis.ZRangeArgs) *redis.StringSliceCmd {
//				panic("mock out the ZRangeArgs method")
//			},
//			ZRangeArgsWithScoresFunc: func(ctx context.Context, z redis.ZRangeArgs) *redis.ZSliceCmd {
//				panic("mock out the ZRangeArgsWithScores method")
//			},
//			ZRangeByLexFunc: func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
//				panic("mock out the ZRangeByLex method")
//			},
//			ZRangeByScoreFunc: func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
//				panic("mock out the ZRangeByScore method")
//			},
//			ZRangeByScoreWithScoresFunc: func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.ZSliceCmd {
//				panic("mock out the ZRangeByScoreWithScores method")
//			},
//			ZRangeStoreFunc: func(ctx context.Context, dst string, z redis.ZRangeArgs) *redis.IntCmd {
//				panic("mock out the ZRangeStore method")
//			},
//			ZRangeWithScoresFunc: func(ctx context.Context, key string, start int64, stop int64) *redis.ZSliceCmd {
//				panic("mock out the ZRangeWithScores method")
//			},
//			ZRankFunc: func(ctx context.Context, key string, member string) *redis.IntCmd {
//				panic("mock out the ZRank method")
//			},
//			ZRankWithScoreFunc: func(ctx context.Context, key string, member string) *redis.RankWithScoreCmd {
//				panic("mock out the ZRankWithScore method")
//			},
//			ZRemFunc: func(ctx context.Context, key string, members ...interface{}) *redis.IntCmd {
//				panic("mock out the ZRem method")
//			},
//			ZRemRangeByLexFunc: func(ctx context.Context, key string, min string, max string) *redis.IntCmd {
//				panic("mock out the ZRemRangeByLex method")
//			},
//			ZRemRangeByRankFunc: func(ctx context.Context, key string, start int64, stop int64) *redis.IntCmd {
//				panic("mock out the ZRemRangeByRank method")
//			},
//			ZRemRangeByScoreFunc: func(ctx context.Context, key string, min string, max string) *redis.IntCmd {
//				panic("mock out the ZRemRangeByScore method")
//			},
//			ZRevRangeFunc: func(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd {
//				panic("mock out the ZRevRange method")
//			},
//			ZRevRangeByLexFunc: func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
//				panic("mock out the ZRevRangeByLex method")
//			},
//			ZRevRangeByScoreFunc: func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
//				panic("mock out the ZRevRangeByScore method")
//			},
//			ZRevRangeByScoreWithScoresFunc: func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.ZSliceCmd {
//				panic("mock out the ZRevRangeByScoreWithScores method")
//			},
//			ZRevRangeWithScoresFunc: func(ctx context.Context, key string, start int64, stop int64) *redis.ZSliceCmd {
//				panic("mock out the ZRevRangeWithScores method")
//			},
//			ZRevRankFunc: func(ctx context.Context, key string, member string) *redis.IntCmd {
//				panic("mock out the ZRevRank method")
//			},
//			ZRevRankWithScoreFunc: func(ctx context.Context, key string, member string) *redis.RankWithScoreCmd {
//				panic("mock out the ZRevRankWithScore method")
//			},
//			ZScanFunc: func(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
//				panic("mock out the ZScan method")
//			},
//			ZScoreFunc: func(ctx context.Context, key string, member string) *redis.FloatCmd {
//				panic("mock out the ZScore method")
//			},
//			ZUnionFunc: func(ctx context.Context, store redis.ZStore) *redis.StringSliceCmd {
//				panic("mock out the ZUnion method")
//			},
//			ZUnionStoreFunc: func(ctx context.Context, dest string, store *redis.ZStore) *redis.IntCmd {
//				panic("mock out the ZUnionStore method")
//			},
//			ZUnionWithScoresFunc: func(ctx context.Context, store redis.ZStore) *redis.ZSliceCmd {
//				panic("mock out the ZUnionWithScores method")
//			},
//		}
//
//		// use mockedGoRedisClient in code that requires interfaces.GoRedisClient
//		// and then make assertions.
//
//	}
type GoRedisClientMock struct {
	// ACLCatFunc mocks the ACLCat method.
	ACLCatFunc func(ctx context.Context) *redis.StringSliceCmd

	// ACLCatArgsFunc mocks the ACLCatArgs method.
	ACLCatArgsFunc func(ctx context.Context, options *redis.ACLCatArgs) *redis.StringSliceCmd

	// ACLDelUserFunc mocks the ACLDelUser method.
	ACLDelUserFunc func(ctx context.Context, username string) *redis.IntCmd

	// ACLDryRunFunc mocks the ACLDryRun method.
	ACLDryRunFunc func(ctx context.Context, username string, command ...interface{}) *redis.StringCmd

	// ACLListFunc mocks the ACLList method.
	ACLListFunc func(ctx context.Context) *redis.StringSliceCmd

	// ACLLogFunc mocks the ACLLog method.
	ACLLogFunc func(ctx context.Context, count int64) *redis.ACLLogCmd

	// ACLLogResetFunc mocks the ACLLogReset method.
	ACLLogResetFunc func(ctx context.Context) *redis.StatusCmd

	// ACLSetUserFunc mocks the ACLSetUser method.
	ACLSetUserFunc func(ctx context.Context, username string, rules ...string) *redis.StatusCmd

	// AddHookFunc mocks the AddHook method.
	AddHookFunc func(hook redis.Hook)

	// AppendFunc mocks the Append method.
	AppendFunc func(ctx context.Context, key string, value string) *redis.IntCmd

	// BFAddFunc mocks the BFAdd method.
	BFAddFunc func(ctx context.Context, key string, element interface{}) *redis.BoolCmd

	// BFCardFunc mocks the BFCard method.
	BFCardFunc func(ctx context.Context, key string) *redis.IntCmd

	// BFExistsFunc mocks the BFExists method.
	BFExistsFunc func(ctx context.Context, key string, element interface{}) *redis.BoolCmd

	// BFInfoFunc mocks the BFInfo method.
	BFInfoFunc func(ctx context.Context, key string) *redis.BFInfoCmd

	// BFInfoArgFunc mocks the BFInfoArg method.
	BFInfoArgFunc func(ctx context.Context, key string, option string) *redis.BFInfoCmd

	// BFInfoCapacityFunc mocks the BFInfoCapacity method.
	BFInfoCapacityFunc func(ctx context.Context, key string) *redis.BFInfoCmd

	// BFInfoExpansionFunc mocks the BFInfoExpansion method.
	BFInfoExpansionFunc func(ctx context.Context, key string) *redis.BFInfoCmd

	// BFInfoFiltersFunc mocks the BFInfoFilters method.
	BFInfoFiltersFunc func(ctx context.Context, key string) *redis.BFInfoCmd

	// BFInfoItemsFunc mocks the BFInfoItems method.
	BFInfoItemsFunc func(ctx context.Context, key string) *redis.BFInfoCmd

	// BFInfoSizeFunc mocks the BFInfoSize method.
	BFInfoSizeFunc func(ctx context.Context, key string) *redis.BFInfoCmd

	// BFInsertFunc mocks the BFInsert method.
	BFInsertFunc func(ctx context.Context, key string, options *redis.BFInsertOptions, elements ...interface{}) *redis.BoolSliceCmd

	// BFLoadChunkFunc mocks the BFLoadChunk method.
	BFLoadChunkFunc func(ctx context.Context, key string, iterator int64, data interface{}) *redis.StatusCmd

	// BFMAddFunc mocks the BFMAdd method.
	BFMAddFunc func(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd

	// BFMExistsFunc mocks the BFMExists method.
	BFMExistsFunc func(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd

	// BFReserveFunc mocks the BFReserve method.
	BFReserveFunc func(ctx context.Context, key string, errorRate float64, capacity int64) *redis.StatusCmd

	// BFReserveExpansionFunc mocks the BFReserveExpansion method.
	BFReserveExpansionFunc func(ctx context.Context, key string, errorRate float64, capacity int64, expansion int64) *redis.StatusCmd

	// BFReserveNonScalingFunc mocks the BFReserveNonScaling method.
	BFReserveNonScalingFunc func(ctx context.Context, key string, errorRate float64, capacity int64) *redis.StatusCmd

	// BFReserveWithArgsFunc mocks the BFReserveWithArgs method.
	BFReserveWithArgsFunc func(ctx context.Context, key string, options *redis.BFReserveOptions) *redis.StatusCmd

	// BFScanDumpFunc mocks the BFScanDump method.
	BFScanDumpFunc func(ctx context.Context, key string, iterator int64) *redis.ScanDumpCmd

	// BLMPopFunc mocks the BLMPop method.
	BLMPopFunc func(ctx context.Context, timeout time.Duration, direction string, count int64, keys ...string) *redis.KeyValuesCmd

	// BLMoveFunc mocks the BLMove method.
	BLMoveFunc func(ctx context.Context, source string, destination string, srcpos string, destpos string, timeout time.Duration) *redis.StringCmd

	// BLPopFunc mocks the BLPop method.
	BLPopFunc func(ctx context.Context, timeout time.Duration, keys ...string) *redis.StringSliceCmd

	// BRPopFunc mocks the BRPop method.
	BRPopFunc func(ctx context.Context, timeout time.Duration, keys ...string) *redis.StringSliceCmd

	// BRPopLPushFunc mocks the BRPopLPush method.
	BRPopLPushFunc func(ctx context.Context, source string, destination string, timeout time.Duration) *redis.StringCmd

	// BZMPopFunc mocks the BZMPop method.
	BZMPopFunc func(ctx context.Context, timeout time.Duration, order string, count int64, keys ...string) *redis.ZSliceWithKeyCmd

	// BZPopMaxFunc mocks the BZPopMax method.
	BZPopMaxFunc func(ctx context.Context, timeout time.Duration, keys ...string) *redis.ZWithKeyCmd

	// BZPopMinFunc mocks the BZPopMin method.
	BZPopMinFunc func(ctx context.Context, timeout time.Duration, keys ...string) *redis.ZWithKeyCmd

	// BgRewriteAOFFunc mocks the BgRewriteAOF method.
	BgRewriteAOFFunc func(ctx context.Context) *redis.StatusCmd

	// BgSaveFunc mocks the BgSave method.
	BgSaveFunc func(ctx context.Context) *redis.StatusCmd

	// BitCountFunc mocks the BitCount method.
	BitCountFunc func(ctx context.Context, key string, bitCount *redis.BitCount) *redis.IntCmd

	// BitFieldFunc mocks the BitField method.
	BitFieldFunc func(ctx context.Context, key string, values ...interface{}) *redis.IntSliceCmd

	// BitFieldROFunc mocks the BitFieldRO method.
	BitFieldROFunc func(ctx context.Context, key string, values ...interface{}) *redis.IntSliceCmd

	// BitOpAndFunc mocks the BitOpAnd method.
	BitOpAndFunc func(ctx context.Context, destKey string, keys ...string) *redis.IntCmd

	// BitOpNotFunc mocks the BitOpNot method.
	BitOpNotFunc func(ctx context.Context, destKey string, key string) *redis.IntCmd

	// BitOpOrFunc mocks the BitOpOr method.
	BitOpOrFunc func(ctx context.Context, destKey string, keys ...string) *redis.IntCmd

	// BitOpXorFunc mocks the BitOpXor method.
	BitOpXorFunc func(ctx context.Context, destKey string, keys ...string) *redis.IntCmd

	// BitPosFunc mocks the BitPos method.
	BitPosFunc func(ctx context.Context, key string, bit int64, pos ...int64) *redis.IntCmd

	// BitPosSpanFunc mocks the BitPosSpan method.
	BitPosSpanFunc func(ctx context.Context, key string, bit int8, start int64, end int64, span string) *redis.IntCmd

	// CFAddFunc mocks the CFAdd method.
	CFAddFunc func(ctx context.Context, key string, element interface{}) *redis.BoolCmd

	// CFAddNXFunc mocks the CFAddNX method.
	CFAddNXFunc func(ctx context.Context, key string, element interface{}) *redis.BoolCmd

	// CFCountFunc mocks the CFCount method.
	CFCountFunc func(ctx context.Context, key string, element interface{}) *redis.IntCmd

	// CFDelFunc mocks the CFDel method.
	CFDelFunc func(ctx context.Context, key string, element interface{}) *redis.BoolCmd

	// CFExistsFunc mocks the CFExists method.
	CFExistsFunc func(ctx context.Context, key string, element interface{}) *redis.BoolCmd

	// CFInfoFunc mocks the CFInfo method.
	CFInfoFunc func(ctx context.Context, key string) *redis.CFInfoCmd

	// CFInsertFunc mocks the CFInsert method.
	CFInsertFunc func(ctx context.Context, key string, options *redis.CFInsertOptions, elements ...interface{}) *redis.BoolSliceCmd

	// CFInsertNXFunc mocks the CFInsertNX method.
	CFInsertNXFunc func(ctx context.Context, key string, options *redis.CFInsertOptions, elements ...interface{}) *redis.IntSliceCmd

	// CFLoadChunkFunc mocks the CFLoadChunk method.
	CFLoadChunkFunc func(ctx context.Context, key string, iterator int64, data interface{}) *redis.StatusCmd

	// CFMExistsFunc mocks the CFMExists method.
	CFMExistsFunc func(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd

	// CFReserveFunc mocks the CFReserve method.
	CFReserveFunc func(ctx context.Context, key string, capacity int64) *redis.StatusCmd

	// CFReserveBucketSizeFunc mocks the CFReserveBucketSize method.
	CFReserveBucketSizeFunc func(ctx context.Context, key string, capacity int64, bucketsize int64) *redis.StatusCmd

	// CFReserveExpansionFunc mocks the CFReserveExpansion method.
	CFReserveExpansionFunc func(ctx context.Context, key string, capacity int64, expansion int64) *redis.StatusCmd

	// CFReserveMaxIterationsFunc mocks the CFReserveMaxIterations method.
	CFReserveMaxIterationsFunc func(ctx context.Context, key string, capacity int64, maxiterations int64) *redis.StatusCmd

	// CFReserveWithArgsFunc mocks the CFReserveWithArgs method.
	CFReserveWithArgsFunc func(ctx context.Context, key string, options *redis.CFReserveOptions) *redis.StatusCmd

	// CFScanDumpFunc mocks the CFScanDump method.
	CFScanDumpFunc func(ctx context.Context, key string, iterator int64) *redis.ScanDumpCmd

	// CMSIncrByFunc mocks the CMSIncrBy method.
	CMSIncrByFunc func(ctx context.Context, key string, elements ...interface{}) *redis.IntSliceCmd

	// CMSInfoFunc mocks the CMSInfo method.
	CMSInfoFunc func(ctx context.Context, key string) *redis.CMSInfoCmd

	// CMSInitByDimFunc mocks the CMSInitByDim method.
	CMSInitByDimFunc func(ctx context.Context, key string, width int64, height int64) *redis.StatusCmd

	// CMSInitByProbFunc mocks the CMSInitByProb method.
	CMSInitByProbFunc func(ctx context.Context, key string, errorRate float64, probability float64) *redis.StatusCmd

	// CMSMergeFunc mocks the CMSMerge method.
	CMSMergeFunc func(ctx context.Context, destKey string, sourceKeys ...string) *redis.StatusCmd

	// CMSMergeWithWeightFunc mocks the CMSMergeWithWeight method.
	CMSMergeWithWeightFunc func(ctx context.Context, destKey string, sourceKeys map[string]int64) *redis.StatusCmd

	// CMSQueryFunc mocks the CMSQuery method.
	CMSQueryFunc func(ctx context.Context, key string, elements ...interface{}) *redis.IntSliceCmd

	// ClientGetNameFunc mocks the ClientGetName method.
	ClientGetNameFunc func(ctx context.Context) *redis.StringCmd

	// ClientIDFunc mocks the ClientID method.
	ClientIDFunc func(ctx context.Context) *redis.IntCmd

	// ClientInfoFunc mocks the ClientInfo method.
	ClientInfoFunc func(ctx context.Context) *redis.ClientInfoCmd

	// ClientKillFunc mocks the ClientKill method.
	ClientKillFunc func(ctx context.Context, ipPort string) *redis.StatusCmd

	// ClientKillByFilterFunc mocks the ClientKillByFilter method.
	ClientKillByFilterFunc func(ctx context.Context, keys ...string) *redis.IntCmd

	// ClientListFunc mocks the ClientList method.
	ClientListFunc func(ctx context.Context) *redis.StringCmd

	// ClientPauseFunc mocks the ClientPause method.
	ClientPauseFunc func(ctx context.Context, dur time.Duration) *redis.BoolCmd

	// ClientUnblockFunc mocks the ClientUnblock method.
	ClientUnblockFunc func(ctx context.Context, id int64) *redis.IntCmd

	// ClientUnblockWithErrorFunc mocks the ClientUnblockWithError method.
	ClientUnblockWithErrorFunc func(ctx context.Context, id int64) *redis.IntCmd

	// ClientUnpauseFunc mocks the ClientUnpause method.
	ClientUnpauseFunc func(ctx context.Context) *redis.BoolCmd

	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// ClusterAddSlotsFunc mocks the ClusterAddSlots method.
	ClusterAddSlotsFunc func(ctx context.Context, slots ...int) *redis.StatusCmd

	// ClusterAddSlotsRangeFunc mocks the ClusterAddSlotsRange method.
	ClusterAddSlotsRangeFunc func(ctx context.Context, min int, max int) *redis.StatusCmd

	// ClusterCountFailureReportsFunc mocks the ClusterCountFailureReports method.
	ClusterCountFailureReportsFunc func(ctx context.Context, nodeID string) *redis.IntCmd

	// ClusterCountKeysInSlotFunc mocks the ClusterCountKeysInSlot method.
	ClusterCountKeysInSlotFunc func(ctx context.Context, slot int) *redis.IntCmd

	// ClusterDelSlotsFunc mocks the ClusterDelSlots method.
	ClusterDelSlotsFunc func(ctx context.Context, slots ...int) *redis.StatusCmd

	// ClusterDelSlotsRangeFunc mocks the ClusterDelSlotsRange method.
	ClusterDelSlotsRangeFunc func(ctx context.Context, min int, max int) *redis.StatusCmd

	// ClusterFailoverFunc mocks the ClusterFailover method.
	ClusterFailoverFunc func(ctx context.Context) *redis.StatusCmd

	// ClusterForgetFunc mocks the ClusterForget method.
	ClusterForgetFunc func(ctx context.Context, nodeID string) *redis.StatusCmd

	// ClusterGetKeysInSlotFunc mocks the ClusterGetKeysInSlot method.
	ClusterGetKeysInSlotFunc func(ctx context.Context, slot int, count int) *redis.StringSliceCmd

	// ClusterInfoFunc mocks the ClusterInfo method.
	ClusterInfoFunc func(ctx context.Context) *redis.StringCmd

	// ClusterKeySlotFunc mocks the ClusterKeySlot method.
	ClusterKeySlotFunc func(ctx context.Context, key string) *redis.IntCmd

	// ClusterLinksFunc mocks the ClusterLinks method.
	ClusterLinksFunc func(ctx context.Context) *redis.ClusterLinksCmd

	// ClusterMeetFunc mocks the ClusterMeet method.
	ClusterMeetFunc func(ctx context.Context, host string, port string) *redis.StatusCmd

	// ClusterMyIDFunc mocks the ClusterMyID method.
	ClusterMyIDFunc func(ctx context.Context) *redis.StringCmd

	// ClusterMyShardIDFunc mocks the ClusterMyShardID method.
	ClusterMyShardIDFunc func(ctx context.Context) *redis.StringCmd

	// ClusterNodesFunc mocks the ClusterNodes method.
	ClusterNodesFunc func(ctx context.Context) *redis.StringCmd

	// ClusterReplicateFunc mocks the ClusterReplicate method.
	ClusterReplicateFunc func(ctx context.Context, nodeID string) *redis.StatusCmd

	// ClusterResetHardFunc mocks the ClusterResetHard method.
	ClusterResetHardFunc func(ctx context.Context) *redis.StatusCmd

	// ClusterResetSoftFunc mocks the ClusterResetSoft method.
	ClusterResetSoftFunc func(ctx context.Context) *redis.StatusCmd

	// ClusterSaveConfigFunc mocks the ClusterSaveConfig method.
	ClusterSaveConfigFunc func(ctx context.Context) *redis.StatusCmd

	// ClusterShardsFunc mocks the ClusterShards method.
	ClusterShardsFunc func(ctx context.Context) *redis.ClusterShardsCmd

	// ClusterSlavesFunc mocks the ClusterSlaves method.
	ClusterSlavesFunc func(ctx context.Context, nodeID string) *redis.StringSliceCmd

	// ClusterSlotsFunc mocks the ClusterSlots method.
	ClusterSlotsFunc func(ctx context.Context) *redis.ClusterSlotsCmd

	// CommandFunc mocks the Command method.
	CommandFunc func(ctx context.Context) *redis.CommandsInfoCmd

	// CommandGetKeysFunc mocks the CommandGetKeys method.
	CommandGetKeysFunc func(ctx context.Context, commands ...interface{}) *redis.StringSliceCmd

	// CommandGetKeysAndFlagsFunc mocks the CommandGetKeysAndFlags method.
	CommandGetKeysAndFlagsFunc func(ctx context.Context, commands ...interface{}) *redis.KeyFlagsCmd

	// CommandListFunc mocks the CommandList method.
	CommandListFunc func(ctx context.Context, filter *redis.FilterBy) *redis.StringSliceCmd

	// ConfigGetFunc mocks the ConfigGet method.
	ConfigGetFunc func(ctx context.Context, parameter string) *redis.MapStringStringCmd

	// ConfigResetStatFunc mocks the ConfigResetStat method.
	ConfigResetStatFunc func(ctx context.Context) *redis.StatusCmd

	// ConfigRewriteFunc mocks the ConfigRewrite method.
	ConfigRewriteFunc func(ctx context.Context) *redis.StatusCmd

	// ConfigSetFunc mocks the ConfigSet method.
	ConfigSetFunc func(ctx context.Context, parameter string, value string) *redis.StatusCmd

	// CopyFunc mocks the Copy method.
	CopyFunc func(ctx context.Context, sourceKey string, destKey string, db int, replace bool) *redis.IntCmd

	// DBSizeFunc mocks the DBSize method.
	DBSizeFunc func(ctx context.Context) *redis.IntCmd

	// DebugObjectFunc mocks the DebugObject method.
	DebugObjectFunc func(ctx context.Context, key string) *redis.StringCmd

	// DecrFunc mocks the Decr method.
	DecrFunc func(ctx context.Context, key string) *redis.IntCmd

	// DecrByFunc mocks the DecrBy method.
	DecrByFunc func(ctx context.Context, key string, decrement int64) *redis.IntCmd

	// DelFunc mocks the Del method.
	DelFunc func(ctx context.Context, keys ...string) *redis.IntCmd

	// DoFunc mocks the Do method.
	DoFunc func(ctx context.Context, args ...interface{}) *redis.Cmd

	// DumpFunc mocks the Dump method.
	DumpFunc func(ctx context.Context, key string) *redis.StringCmd

	// EchoFunc mocks the Echo method.
	EchoFunc func(ctx context.Context, message interface{}) *redis.StringCmd

	// EvalFunc mocks the Eval method.
	EvalFunc func(ctx context.Context, script string, keys []string, args ...interface{}) *redis.Cmd

	// EvalROFunc mocks the EvalRO method.
	EvalROFunc func(ctx context.Context, script string, keys []string, args ...interface{}) *redis.Cmd

	// EvalShaFunc mocks the EvalSha method.
	EvalShaFunc func(ctx context.Context, sha1 string, keys []string, args ...interface{}) *redis.Cmd

	// EvalShaROFunc mocks the EvalShaRO method.
	EvalShaROFunc func(ctx context.Context, sha1 string, keys []string, args ...interface{}) *redis.Cmd

	// ExistsFunc mocks the Exists method.
	ExistsFunc func(ctx context.Context, keys ...string) *redis.IntCmd

	// ExpireFunc mocks the Expire method.
	ExpireFunc func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd

	// ExpireAtFunc mocks the ExpireAt method.
	ExpireAtFunc func(ctx context.Context, key string, tm time.Time) *redis.BoolCmd

	// ExpireGTFunc mocks the ExpireGT method.
	ExpireGTFunc func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd

	// ExpireLTFunc mocks the ExpireLT method.
	ExpireLTFunc func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd

	// ExpireNXFunc mocks the ExpireNX method.
	ExpireNXFunc func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd

	// ExpireTimeFunc mocks the ExpireTime method.
	ExpireTimeFunc func(ctx context.Context, key string) *redis.DurationCmd

	// ExpireXXFunc mocks the ExpireXX method.
	ExpireXXFunc func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd

	// FCallFunc mocks the FCall method.
	FCallFunc func(ctx context.Context, function string, keys []string, args ...interface{}) *redis.Cmd

	// FCallROFunc mocks the FCallRO method.
	FCallROFunc func(ctx context.Context, function string, keys []string, args ...interface{}) *redis.Cmd

	// FCallRoFunc mocks the FCallRo method.
	FCallRoFunc func(ctx context.Context, function string, keys []string, args ...interface{}) *redis.Cmd

	// FTAggregateFunc mocks the FTAggregate method.
	FTAggregateFunc func(ctx context.Context, index string, query string) *redis.MapStringInterfaceCmd

	// FTAggregateWithArgsFunc mocks the FTAggregateWithArgs method.
	FTAggregateWithArgsFunc func(ctx context.Context, index string, query string, options *redis.FTAggregateOptions) *redis.AggregateCmd

	// FTAliasAddFunc mocks the FTAliasAdd method.
	FTAliasAddFunc func(ctx context.Context, index string, alias string) *redis.StatusCmd

	// FTAliasDelFunc mocks the FTAliasDel method.
	FTAliasDelFunc func(ctx context.Context, alias string) *redis.StatusCmd

	// FTAliasUpdateFunc mocks the FTAliasUpdate method.
	FTAliasUpdateFunc func(ctx context.Context, index string, alias string) *redis.StatusCmd

	// FTAlterFunc mocks the FTAlter method.
	FTAlterFunc func(ctx context.Context, index string, skipInitialScan bool, definition []interface{}) *redis.StatusCmd

	// FTConfigGetFunc mocks the FTConfigGet method.
	FTConfigGetFunc func(ctx context.Context, option string) *redis.MapMapStringInterfaceCmd

	// FTConfigSetFunc mocks the FTConfigSet method.
	FTConfigSetFunc func(ctx context.Context, option string, value interface{}) *redis.StatusCmd

	// FTCreateFunc mocks the FTCreate method.
	FTCreateFunc func(ctx context.Context, index string, options *redis.FTCreateOptions, schema ...*redis.FieldSchema) *redis.StatusCmd

	// FTCursorDelFunc mocks the FTCursorDel method.
	FTCursorDelFunc func(ctx context.Context, index string, cursorId int) *redis.StatusCmd

	// FTCursorReadFunc mocks the FTCursorRead method.
	FTCursorReadFunc func(ctx context.Context, index string, cursorId int, count int) *redis.MapStringInterfaceCmd

	// FTDictAddFunc mocks the FTDictAdd method.
	FTDictAddFunc func(ctx context.Context, dict string, term ...interface{}) *redis.IntCmd

	// FTDictDelFunc mocks the FTDictDel method.
	FTDictDelFunc func(ctx context.Context, dict string, term ...interface{}) *redis.IntCmd

	// FTDictDumpFunc mocks the FTDictDump method.
	FTDictDumpFunc func(ctx context.Context, dict string) *redis.StringSliceCmd

	// FTDropIndexFunc mocks the FTDropIndex method.
	FTDropIndexFunc func(ctx context.Context, index string) *redis.StatusCmd

	// FTDropIndexWithArgsFunc mocks the FTDropIndexWithArgs method.
	FTDropIndexWithArgsFunc func(ctx context.Context, index string, options *redis.FTDropIndexOptions) *redis.StatusCmd

	// FTExplainFunc mocks the FTExplain method.
	FTExplainFunc func(ctx context.Context, index string, query string) *redis.StringCmd

	// FTExplainWithArgsFunc mocks the FTExplainWithArgs method.
	FTExplainWithArgsFunc func(ctx context.Context, index string, query string, options *redis.FTExplainOptions) *redis.StringCmd

	// FTInfoFunc mocks the FTInfo method.
	FTInfoFunc func(ctx context.Context, index string) *redis.FTInfoCmd

	// FTSearchFunc mocks the FTSearch method.
	FTSearchFunc func(ctx context.Context, index string, query string) *redis.FTSearchCmd

	// FTSearchWithArgsFunc mocks the FTSearchWithArgs method.
	FTSearchWithArgsFunc func(ctx context.Context, index string, query string, options *redis.FTSearchOptions) *redis.FTSearchCmd

	// FTSpellCheckFunc mocks the FTSpellCheck method.
	FTSpellCheckFunc func(ctx context.Context, index string, query string) *redis.FTSpellCheckCmd

	// FTSpellCheckWithArgsFunc mocks the FTSpellCheckWithArgs method.
	FTSpellCheckWithArgsFunc func(ctx context.Context, index string, query string, options *redis.FTSpellCheckOptions) *redis.FTSpellCheckCmd

	// FTSynDumpFunc mocks the FTSynDump method.
	FTSynDumpFunc func(ctx context.Context, index string) *redis.FTSynDumpCmd

	// FTSynUpdateFunc mocks the FTSynUpdate method.
	FTSynUpdateFunc func(ctx context.Context, index string, synGroupId interface{}, terms []interface{}) *redis.StatusCmd

	// FTSynUpdateWithArgsFunc mocks the FTSynUpdateWithArgs method.
	FTSynUpdateWithArgsFunc func(ctx context.Context, index string, synGroupId interface{}, options *redis.FTSynUpdateOptions, terms []interface{}) *redis.StatusCmd

	// FTTagValsFunc mocks the FTTagVals method.
	FTTagValsFunc func(ctx context.Context, index string, field string) *redis.StringSliceCmd

	// FT_ListFunc mocks the FT_List method.
	FT_ListFunc func(ctx context.Context) *redis.StringSliceCmd

	// FlushAllFunc mocks the FlushAll method.
	FlushAllFunc func(ctx context.Context) *redis.StatusCmd

	// FlushAllAsyncFunc mocks the FlushAllAsync method.
	FlushAllAsyncFunc func(ctx context.Context) *redis.StatusCmd

	// FlushDBFunc mocks the FlushDB method.
	FlushDBFunc func(ctx context.Context) *redis.StatusCmd

	// FlushDBAsyncFunc mocks the FlushDBAsync method.
	FlushDBAsyncFunc func(ctx context.Context) *redis.StatusCmd

	// FunctionDeleteFunc mocks the FunctionDelete method.
	FunctionDeleteFunc func(ctx context.Context, libName string) *redis.StringCmd

	// FunctionDumpFunc mocks the FunctionDump method.
	FunctionDumpFunc func(ctx context.Context) *redis.StringCmd

	// FunctionFlushFunc mocks the FunctionFlush method.
	FunctionFlushFunc func(ctx context.Context) *redis.StringCmd

	// FunctionFlushAsyncFunc mocks the FunctionFlushAsync method.
	FunctionFlushAsyncFunc func(ctx context.Context) *redis.StringCmd

	// FunctionKillFunc mocks the FunctionKill method.
	FunctionKillFunc func(ctx context.Context) *redis.StringCmd

	// FunctionListFunc mocks the FunctionList method.
	FunctionListFunc func(ctx context.Context, q redis.FunctionListQuery) *redis.FunctionListCmd

	// FunctionLoadFunc mocks the FunctionLoad method.
	FunctionLoadFunc func(ctx context.Context, code string) *redis.StringCmd

	// FunctionLoadReplaceFunc mocks the FunctionLoadReplace method.
	FunctionLoadReplaceFunc func(ctx context.Context, code string) *redis.StringCmd

	// FunctionRestoreFunc mocks the FunctionRestore method.
	FunctionRestoreFunc func(ctx context.Context, libDump string) *redis.StringCmd

	// FunctionStatsFunc mocks the FunctionStats method.
	FunctionStatsFunc func(ctx context.Context) *redis.FunctionStatsCmd

	// GeoAddFunc mocks the GeoAdd method.
	GeoAddFunc func(ctx context.Context, key string, geoLocation ...*redis.GeoLocation) *redis.IntCmd

	// GeoDistFunc mocks the GeoDist method.
	GeoDistFunc func(ctx context.Context, key string, member1 string, member2 string, unit string) *redis.FloatCmd

	// GeoHashFunc mocks the GeoHash method.
	GeoHashFunc func(ctx context.Context, key string, members ...string) *redis.StringSliceCmd

	// GeoPosFunc mocks the GeoPos method.
	GeoPosFunc func(ctx context.Context, key string, members ...string) *redis.GeoPosCmd

	// GeoRadiusFunc mocks the GeoRadius method.
	GeoRadiusFunc func(ctx context.Context, key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd

	// GeoRadiusByMemberFunc mocks the GeoRadiusByMember method.
	GeoRadiusByMemberFunc func(ctx context.Context, key string, member string, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd

	// GeoRadiusByMemberStoreFunc mocks the GeoRadiusByMemberStore method.
	GeoRadiusByMemberStoreFunc func(ctx context.Context, key string, member string, query *redis.GeoRadiusQuery) *redis.IntCmd

	// GeoRadiusStoreFunc mocks the GeoRadiusStore method.
	GeoRadiusStoreFunc func(ctx context.Context, key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.IntCmd

	// GeoSearchFunc mocks the GeoSearch method.
	GeoSearchFunc func(ctx context.Context, key string, q *redis.GeoSearchQuery) *redis.StringSliceCmd

	// GeoSearchLocationFunc mocks the GeoSearchLocation method.
	GeoSearchLocationFunc func(ctx context.Context, key string, q *redis.GeoSearchLocationQuery) *redis.GeoSearchLocationCmd

	// GeoSearchStoreFunc mocks the GeoSearchStore method.
	GeoSearchStoreFunc func(ctx context.Context, key string, store string, q *redis.GeoSearchStoreQuery) *redis.IntCmd

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, key string) *redis.StringCmd

	// GetBitFunc mocks the GetBit method.
	GetBitFunc func(ctx context.Context, key string, offset int64) *redis.IntCmd

	// GetDelFunc mocks the GetDel method.
	GetDelFunc func(ctx context.Context, key string) *redis.StringCmd

	// GetExFunc mocks the GetEx method.
	GetExFunc func(ctx context.Context, key string, expiration time.Duration) *redis.StringCmd

	// GetRangeFunc mocks the GetRange method.
	GetRangeFunc func(ctx context.Context, key string, start int64, end int64) *redis.StringCmd

	// GetSetFunc mocks the GetSet method.
	GetSetFunc func(ctx context.Context, key string, value interface{}) *redis.StringCmd

	// HDelFunc mocks the HDel method.
	HDelFunc func(ctx context.Context, key string, fields ...string) *redis.IntCmd

	// HExistsFunc mocks the HExists method.
	HExistsFunc func(ctx context.Context, key string, field string) *redis.BoolCmd

	// HExpireFunc mocks the HExpire method.
	HExpireFunc func(ctx context.Context, key string, expiration time.Duration, fields ...string) *redis.IntSliceCmd

	// HExpireAtFunc mocks the HExpireAt method.
	HExpireAtFunc func(ctx context.Context, key string, tm time.Time, fields ...string) *redis.IntSliceCmd

	// HExpireAtWithArgsFunc mocks the HExpireAtWithArgs method.
	HExpireAtWithArgsFunc func(ctx context.Context, key string, tm time.Time, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd

	// HExpireTimeFunc mocks the HExpireTime method.
	HExpireTimeFunc func(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd

	// HExpireWithArgsFunc mocks the HExpireWithArgs method.
	HExpireWithArgsFunc func(ctx context.Context, key string, expiration time.Duration, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd

	// HGetFunc mocks the HGet method.
	HGetFunc func(ctx context.Context, key string, field string) *redis.StringCmd

	// HGetAllFunc mocks the HGetAll method.
	HGetAllFunc func(ctx context.Context, key string) *redis.MapStringStringCmd

	// HGetDelFunc mocks the HGetDel method.
	HGetDelFunc func(ctx context.Context, key string, fields ...string) *redis.StringSliceCmd

	// HGetEXFunc mocks the HGetEX method.
	HGetEXFunc func(ctx context.Context, key string, fields ...string) *redis.StringSliceCmd

	// HGetEXWithArgsFunc mocks the HGetEXWithArgs method.
	HGetEXWithArgsFunc func(ctx context.Context, key string, options *redis.HGetEXOptions, fields ...string) *redis.StringSliceCmd

	// HIncrByFunc mocks the HIncrBy method.
	HIncrByFunc func(ctx context.Context, key string, field string, incr int64) *redis.IntCmd

	// HIncrByFloatFunc mocks the HIncrByFloat method.
	HIncrByFloatFunc func(ctx context.Context, key string, field string, incr float64) *redis.FloatCmd

	// HKeysFunc mocks the HKeys method.
	HKeysFunc func(ctx context.Context, key string) *redis.StringSliceCmd

	// HLenFunc mocks the HLen method.
	HLenFunc func(ctx context.Context, key string) *redis.IntCmd

	// HMGetFunc mocks the HMGet method.
	HMGetFunc func(ctx context.Context, key string, fields ...string) *redis.SliceCmd

	// HMSetFunc mocks the HMSet method.
	HMSetFunc func(ctx context.Context, key string, values ...interface{}) *redis.BoolCmd

	// HPExpireFunc mocks the HPExpire method.
	HPExpireFunc func(ctx context.Context, key string, expiration time.Duration, fields ...string) *redis.IntSliceCmd

	// HPExpireAtFunc mocks the HPExpireAt method.
	HPExpireAtFunc func(ctx context.Context, key string, tm time.Time, fields ...string) *redis.IntSliceCmd

	// HPExpireAtWithArgsFunc mocks the HPExpireAtWithArgs method.
	HPExpireAtWithArgsFunc func(ctx context.Context, key string, tm time.Time, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd

	// HPExpireTimeFunc mocks the HPExpireTime method.
	HPExpireTimeFunc func(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd

	// HPExpireWithArgsFunc mocks the HPExpireWithArgs method.
	HPExpireWithArgsFunc func(ctx context.Context, key string, expiration time.Duration, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd

	// HPTTLFunc mocks the HPTTL method.
	HPTTLFunc func(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd

	// HPersistFunc mocks the HPersist method.
	HPersistFunc func(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd

	// HRandFieldFunc mocks the HRandField method.
	HRandFieldFunc func(ctx context.Context, key string, count int) *redis.StringSliceCmd

	// HRandFieldWithValuesFunc mocks the HRandFieldWithValues method.
	HRandFieldWithValuesFunc func(ctx context.Context, key string, count int) *redis.KeyValueSliceCmd

	// HScanFunc mocks the HScan method.
	HScanFunc func(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd

	// HScanNoValuesFunc mocks the HScanNoValues method.
	HScanNoValuesFunc func(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd

	// HSetFunc mocks the HSet method.
	HSetFunc func(ctx context.Context, key string, values ...interface{}) *redis.IntCmd

	// HSetEXFunc mocks the HSetEX method.
	HSetEXFunc func(ctx context.Context, key string, fieldsAndValues ...string) *redis.IntCmd

	// HSetEXWithArgsFunc mocks the HSetEXWithArgs method.
	HSetEXWithArgsFunc func(ctx context.Context, key string, options *redis.HSetEXOptions, fieldsAndValues ...string) *redis.IntCmd

	// HSetNXFunc mocks the HSetNX method.
	HSetNXFunc func(ctx context.Context, key string, field string, value interface{}) *redis.BoolCmd

	// HStrLenFunc mocks the HStrLen method.
	HStrLenFunc func(ctx context.Context, key string, field string) *redis.IntCmd

	// HTTLFunc mocks the HTTL method.
	HTTLFunc func(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd

	// HValsFunc mocks the HVals method.
	HValsFunc func(ctx context.Context, key string) *redis.StringSliceCmd

	// IncrFunc mocks the Incr method.
	IncrFunc func(ctx context.Context, key string) *redis.IntCmd

	// IncrByFunc mocks the IncrBy method.
	IncrByFunc func(ctx context.Context, key string, value int64) *redis.IntCmd

	// IncrByFloatFunc mocks the IncrByFloat method.
	IncrByFloatFunc func(ctx context.Context, key string, value float64) *redis.FloatCmd

	// InfoFunc mocks the Info method.
	InfoFunc func(ctx context.Context, section ...string) *redis.StringCmd

	// JSONArrAppendFunc mocks the JSONArrAppend method.
	JSONArrAppendFunc func(ctx context.Context, key string, path string, values ...interface{}) *redis.IntSliceCmd

	// JSONArrIndexFunc mocks the JSONArrIndex method.
	JSONArrIndexFunc func(ctx context.Context, key string, path string, value ...interface{}) *redis.IntSliceCmd

	// JSONArrIndexWithArgsFunc mocks the JSONArrIndexWithArgs method.
	JSONArrIndexWithArgsFunc func(ctx context.Context, key string, path string, options *redis.JSONArrIndexArgs, value ...interface{}) *redis.IntSliceCmd

	// JSONArrInsertFunc mocks the JSONArrInsert method.
	JSONArrInsertFunc func(ctx context.Context, key string, path string, index int64, values ...interface{}) *redis.IntSliceCmd

	// JSONArrLenFunc mocks the JSONArrLen method.
	JSONArrLenFunc func(ctx context.Context, key string, path string) *redis.IntSliceCmd

	// JSONArrPopFunc mocks the JSONArrPop method.
	JSONArrPopFunc func(ctx context.Context, key string, path string, index int) *redis.StringSliceCmd

	// JSONArrTrimFunc mocks the JSONArrTrim method.
	JSONArrTrimFunc func(ctx context.Context, key string, path string) *redis.IntSliceCmd

	// JSONArrTrimWithArgsFunc mocks the JSONArrTrimWithArgs method.
	JSONArrTrimWithArgsFunc func(ctx context.Context, key string, path string, options *redis.JSONArrTrimArgs) *redis.IntSliceCmd

	// JSONClearFunc mocks the JSONClear method.
	JSONClearFunc func(ctx context.Context, key string, path string) *redis.IntCmd

	// JSONDebugMemoryFunc mocks the JSONDebugMemory method.
	JSONDebugMemoryFunc func(ctx context.Context, key string, path string) *redis.IntCmd

	// JSONDelFunc mocks the JSONDel method.
	JSONDelFunc func(ctx context.Context, key string, path string) *redis.IntCmd

	// JSONForgetFunc mocks the JSONForget method.
	JSONForgetFunc func(ctx context.Context, key string, path string) *redis.IntCmd

	// JSONGetFunc mocks the JSONGet method.
	JSONGetFunc func(ctx context.Context, key string, paths ...string) *redis.JSONCmd

	// JSONGetWithArgsFunc mocks the JSONGetWithArgs method.
	JSONGetWithArgsFunc func(ctx context.Context, key string, options *redis.JSONGetArgs, paths ...string) *redis.JSONCmd

	// JSONMGetFunc mocks the JSONMGet method.
	JSONMGetFunc func(ctx context.Context, path string, keys ...string) *redis.JSONSliceCmd

	// JSONMSetFunc mocks the JSONMSet method.
	JSONMSetFunc func(ctx context.Context, params ...interface{}) *redis.StatusCmd

	// JSONMSetArgsFunc mocks the JSONMSetArgs method.
	JSONMSetArgsFunc func(ctx context.Context, docs []redis.JSONSetArgs) *redis.StatusCmd

	// JSONMergeFunc mocks the JSONMerge method.
	JSONMergeFunc func(ctx context.Context, key string, path string, value string) *redis.StatusCmd

	// JSONNumIncrByFunc mocks the JSONNumIncrBy method.
	JSONNumIncrByFunc func(ctx context.Context, key string, path string, value float64) *redis.JSONCmd

	// JSONObjKeysFunc mocks the JSONObjKeys method.
	JSONObjKeysFunc func(ctx context.Context, key string, path string) *redis.SliceCmd

	// JSONObjLenFunc mocks the JSONObjLen method.
	JSONObjLenFunc func(ctx context.Context, key string, path string) *redis.IntPointerSliceCmd

	// JSONSetFunc mocks the JSONSet method.
	JSONSetFunc func(ctx context.Context, key string, path string, value interface{}) *redis.StatusCmd

	// JSONSetModeFunc mocks the JSONSetMode method.
	JSONSetModeFunc func(ctx context.Context, key string, path string, value interface{}, mode string) *redis.StatusCmd

	// JSONStrAppendFunc mocks the JSONStrAppend method.
	JSONStrAppendFunc func(ctx context.Context, key string, path string, value string) *redis.IntPointerSliceCmd

	// JSONStrLenFunc mocks the JSONStrLen method.
	JSONStrLenFunc func(ctx context.Context, key string, path string) *redis.IntPointerSliceCmd

	// JSONToggleFunc mocks the JSONToggle method.
	JSONToggleFunc func(ctx context.Context, key string, path string) *redis.IntPointerSliceCmd

	// JSONTypeFunc mocks the JSONType method.
	JSONTypeFunc func(ctx context.Context, key string, path string) *redis.JSONSliceCmd

	// KeysFunc mocks the Keys method.
	KeysFunc func(ctx context.Context, pattern string) *redis.StringSliceCmd

	// LCSFunc mocks the LCS method.
	LCSFunc func(ctx context.Context, q *redis.LCSQuery) *redis.LCSCmd

	// LIndexFunc mocks the LIndex method.
	LIndexFunc func(ctx context.Context, key string, index int64) *redis.StringCmd

	// LInsertFunc mocks the LInsert method.
	LInsertFunc func(ctx context.Context, key string, op string, pivot interface{}, value interface{}) *redis.IntCmd

	// LInsertAfterFunc mocks the LInsertAfter method.
	LInsertAfterFunc func(ctx context.Context, key string, pivot interface{}, value interface{}) *redis.IntCmd

	// LInsertBeforeFunc mocks the LInsertBefore method.
	LInsertBeforeFunc func(ctx context.Context, key string, pivot interface{}, value interface{}) *redis.IntCmd

	// LLenFunc mocks the LLen method.
	LLenFunc func(ctx context.Context, key string) *redis.IntCmd

	// LMPopFunc mocks the LMPop method.
	LMPopFunc func(ctx context.Context, direction string, count int64, keys ...string) *redis.KeyValuesCmd

	// LMoveFunc mocks the LMove method.
	LMoveFunc func(ctx context.Context, source string, destination string, srcpos string, destpos string) *redis.StringCmd

	// LPopFunc mocks the LPop method.
	LPopFunc func(ctx context.Context, key string) *redis.StringCmd

	// LPopCountFunc mocks the LPopCount method.
	LPopCountFunc func(ctx context.Context, key string, count int) *redis.StringSliceCmd

	// LPosFunc mocks the LPos method.
	LPosFunc func(ctx context.Context, key string, value string, args redis.LPosArgs) *redis.IntCmd

	// LPosCountFunc mocks the LPosCount method.
	LPosCountFunc func(ctx context.Context, key string, value string, count int64, args redis.LPosArgs) *redis.IntSliceCmd

	// LPushFunc mocks the LPush method.
	LPushFunc func(ctx context.Context, key string, values ...interface{}) *redis.IntCmd

	// LPushXFunc mocks the LPushX method.
	LPushXFunc func(ctx context.Context, key string, values ...interface{}) *redis.IntCmd

	// LRangeFunc mocks the LRange method.
	LRangeFunc func(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd

	// LRemFunc mocks the LRem method.
	LRemFunc func(ctx context.Context, key string, count int64, value interface{}) *redis.IntCmd

	// LSetFunc mocks the LSet method.
	LSetFunc func(ctx context.Context, key string, index int64, value interface{}) *redis.StatusCmd

	// LTrimFunc mocks the LTrim method.
	LTrimFunc func(ctx context.Context, key string, start int64, stop int64) *redis.StatusCmd

	// LastSaveFunc mocks the LastSave method.
	LastSaveFunc func(ctx context.Context) *redis.IntCmd

	// MGetFunc mocks the MGet method.
	MGetFunc func(ctx context.Context, keys ...string) *redis.SliceCmd

	// MSetFunc mocks the MSet method.
	MSetFunc func(ctx context.Context, values ...interface{}) *redis.StatusCmd

	// MSetNXFunc mocks the MSetNX method.
	MSetNXFunc func(ctx context.Context, values ...interface{}) *redis.BoolCmd

	// MemoryUsageFunc mocks the MemoryUsage method.
	MemoryUsageFunc func(ctx context.Context, key string, samples ...int) *redis.IntCmd

	// MigrateFunc mocks the Migrate method.
	MigrateFunc func(ctx context.Context, host string, port string, key string, db int, timeout time.Duration) *redis.StatusCmd

	// ModuleLoadexFunc mocks the ModuleLoadex method.
	ModuleLoadexFunc func(ctx context.Context, conf *redis.ModuleLoadexConfig) *redis.StringCmd

	// MoveFunc mocks the Move method.
	MoveFunc func(ctx context.Context, key string, db int) *redis.BoolCmd

	// ObjectEncodingFunc mocks the ObjectEncoding method.
	ObjectEncodingFunc func(ctx context.Context, key string) *redis.StringCmd

	// ObjectFreqFunc mocks the ObjectFreq method.
	ObjectFreqFunc func(ctx context.Context, key string) *redis.IntCmd

	// ObjectIdleTimeFunc mocks the ObjectIdleTime method.
	ObjectIdleTimeFunc func(ctx context.Context, key string) *redis.DurationCmd

	// ObjectRefCountFunc mocks the ObjectRefCount method.
	ObjectRefCountFunc func(ctx context.Context, key string) *redis.IntCmd

	// PExpireFunc mocks the PExpire method.
	PExpireFunc func(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd

	// PExpireAtFunc mocks the PExpireAt method.
	PExpireAtFunc func(ctx context.Context, key string, tm time.Time) *redis.BoolCmd

	// PExpireTimeFunc mocks the PExpireTime method.
	PExpireTimeFunc func(ctx context.Context, key string) *redis.DurationCmd

	// PFAddFunc mocks the PFAdd method.
	PFAddFunc func(ctx context.Context, key string, els ...interface{}) *redis.IntCmd

	// PFCountFunc mocks the PFCount method.
	PFCountFunc func(ctx context.Context, keys ...string) *redis.IntCmd

	// PFMergeFunc mocks the PFMerge method.
	PFMergeFunc func(ctx context.Context, dest string, keys ...string) *redis.StatusCmd

	// PSubscribeFunc mocks the PSubscribe method.
	PSubscribeFunc func(ctx context.Context, channels ...string) *redis.PubSub

	// PTTLFunc mocks the PTTL method.
	PTTLFunc func(ctx context.Context, key string) *redis.DurationCmd

	// PersistFunc mocks the Persist method.
	PersistFunc func(ctx context.Context, key string) *redis.BoolCmd

	// PingFunc mocks the Ping method.
	PingFunc func(ctx context.Context) *redis.StatusCmd

	// PipelineFunc mocks the Pipeline method.
	PipelineFunc func() redis.Pipeliner

	// PipelinedFunc mocks the Pipelined method.
	PipelinedFunc func(ctx context.Context, fn func(redis.Pipeliner) error) ([]redis.Cmder, error)

	// PoolStatsFunc mocks the PoolStats method.
	PoolStatsFunc func() *redis.PoolStats

	// ProcessFunc mocks the Process method.
	ProcessFunc func(ctx context.Context, cmd redis.Cmder) error

	// PubSubChannelsFunc mocks the PubSubChannels method.
	PubSubChannelsFunc func(ctx context.Context, pattern string) *redis.StringSliceCmd

	// PubSubNumPatFunc mocks the PubSubNumPat method.
	PubSubNumPatFunc func(ctx context.Context) *redis.IntCmd

	// PubSubNumSubFunc mocks the PubSubNumSub method.
	PubSubNumSubFunc func(ctx context.Context, channels ...string) *redis.MapStringIntCmd

	// PubSubShardChannelsFunc mocks the PubSubShardChannels method.
	PubSubShardChannelsFunc func(ctx context.Context, pattern string) *redis.StringSliceCmd

	// PubSubShardNumSubFunc mocks the PubSubShardNumSub method.
	PubSubShardNumSubFunc func(ctx context.Context, channels ...string) *redis.MapStringIntCmd

	// PublishFunc mocks the Publish method.
	PublishFunc func(ctx context.Context, channel string, message interface{}) *redis.IntCmd

	// QuitFunc mocks the Quit method.
	QuitFunc func(ctx context.Context) *redis.StatusCmd

	// RPopFunc mocks the RPop method.
	RPopFunc func(ctx context.Context, key string) *redis.StringCmd

	// RPopCountFunc mocks the RPopCount method.
	RPopCountFunc func(ctx context.Context, key string, count int) *redis.StringSliceCmd

	// RPopLPushFunc mocks the RPopLPush method.
	RPopLPushFunc func(ctx context.Context, source string, destination string) *redis.StringCmd

	// RPushFunc mocks the RPush method.
	RPushFunc func(ctx context.Context, key string, values ...interface{}) *redis.IntCmd

	// RPushXFunc mocks the RPushX method.
	RPushXFunc func(ctx context.Context, key string, values ...interface{}) *redis.IntCmd

	// RandomKeyFunc mocks the RandomKey method.
	RandomKeyFunc func(ctx context.Context) *redis.StringCmd

	// ReadOnlyFunc mocks the ReadOnly method.
	ReadOnlyFunc func(ctx context.Context) *redis.StatusCmd

	// ReadWriteFunc mocks the ReadWrite method.
	ReadWriteFunc func(ctx context.Context) *redis.StatusCmd

	// RenameFunc mocks the Rename method.
	RenameFunc func(ctx context.Context, key string, newkey string) *redis.StatusCmd

	// RenameNXFunc mocks the RenameNX method.
	RenameNXFunc func(ctx context.Context, key string, newkey string) *redis.BoolCmd

	// RestoreFunc mocks the Restore method.
	RestoreFunc func(ctx context.Context, key string, ttl time.Duration, value string) *redis.StatusCmd

	// RestoreReplaceFunc mocks the RestoreReplace method.
	RestoreReplaceFunc func(ctx context.Context, key string, ttl time.Duration, value string) *redis.StatusCmd

	// SAddFunc mocks the SAdd method.
	SAddFunc func(ctx context.Context, key string, members ...interface{}) *redis.IntCmd

	// SCardFunc mocks the SCard method.
	SCardFunc func(ctx context.Context, key string) *redis.IntCmd

	// SDiffFunc mocks the SDiff method.
	SDiffFunc func(ctx context.Context, keys ...string) *redis.StringSliceCmd

	// SDiffStoreFunc mocks the SDiffStore method.
	SDiffStoreFunc func(ctx context.Context, destination string, keys ...string) *redis.IntCmd

	// SInterFunc mocks the SInter method.
	SInterFunc func(ctx context.Context, keys ...string) *redis.StringSliceCmd

	// SInterCardFunc mocks the SInterCard method.
	SInterCardFunc func(ctx context.Context, limit int64, keys ...string) *redis.IntCmd

	// SInterStoreFunc mocks the SInterStore method.
	SInterStoreFunc func(ctx context.Context, destination string, keys ...string) *redis.IntCmd

	// SIsMemberFunc mocks the SIsMember method.
	SIsMemberFunc func(ctx context.Context, key string, member interface{}) *redis.BoolCmd

	// SMIsMemberFunc mocks the SMIsMember method.
	SMIsMemberFunc func(ctx context.Context, key string, members ...interface{}) *redis.BoolSliceCmd

	// SMembersFunc mocks the SMembers method.
	SMembersFunc func(ctx context.Context, key string) *redis.StringSliceCmd

	// SMembersMapFunc mocks the SMembersMap method.
	SMembersMapFunc func(ctx context.Context, key string) *redis.StringStructMapCmd

	// SMoveFunc mocks the SMove method.
	SMoveFunc func(ctx context.Context, source string, destination string, member interface{}) *redis.BoolCmd

	// SPopFunc mocks the SPop method.
	SPopFunc func(ctx context.Context, key string) *redis.StringCmd

	// SPopNFunc mocks the SPopN method.
	SPopNFunc func(ctx context.Context, key string, count int64) *redis.StringSliceCmd

	// SPublishFunc mocks the SPublish method.
	SPublishFunc func(ctx context.Context, channel string, message interface{}) *redis.IntCmd

	// SRandMemberFunc mocks the SRandMember method.
	SRandMemberFunc func(ctx context.Context, key string) *redis.StringCmd

	// SRandMemberNFunc mocks the SRandMemberN method.
	SRandMemberNFunc func(ctx context.Context, key string, count int64) *redis.StringSliceCmd

	// SRemFunc mocks the SRem method.
	SRemFunc func(ctx context.Context, key string, members ...interface{}) *redis.IntCmd

	// SScanFunc mocks the SScan method.
	SScanFunc func(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd

	// SSubscribeFunc mocks the SSubscribe method.
	SSubscribeFunc func(ctx context.Context, channels ...string) *redis.PubSub

	// SUnionFunc mocks the SUnion method.
	SUnionFunc func(ctx context.Context, keys ...string) *redis.StringSliceCmd

	// SUnionStoreFunc mocks the SUnionStore method.
	SUnionStoreFunc func(ctx context.Context, destination string, keys ...string) *redis.IntCmd

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context) *redis.StatusCmd

	// ScanFunc mocks the Scan method.
	ScanFunc func(ctx context.Context, cursor uint64, match string, count int64) *redis.ScanCmd

	// ScanTypeFunc mocks the ScanType method.
	ScanTypeFunc func(ctx context.Context, cursor uint64, match string, count int64, keyType string) *redis.ScanCmd

	// ScriptExistsFunc mocks the ScriptExists method.
	ScriptExistsFunc func(ctx context.Context, hashes ...string) *redis.BoolSliceCmd

	// ScriptFlushFunc mocks the ScriptFlush method.
	ScriptFlushFunc func(ctx context.Context) *redis.StatusCmd

	// ScriptKillFunc mocks the ScriptKill method.
	ScriptKillFunc func(ctx context.Context) *redis.StatusCmd

	// ScriptLoadFunc mocks the ScriptLoad method.
	ScriptLoadFunc func(ctx context.Context, script string) *redis.StringCmd

	// SetFunc mocks the Set method.
	SetFunc func(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.StatusCmd

	// SetArgsFunc mocks the SetArgs method.
	SetArgsFunc func(ctx context.Context, key string, value interface{}, a redis.SetArgs) *redis.StatusCmd

	// SetBitFunc mocks the SetBit method.
	SetBitFunc func(ctx context.Context, key string, offset int64, value int) *redis.IntCmd

	// SetExFunc mocks the SetEx method.
	SetExFunc func(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.StatusCmd

	// SetNXFunc mocks the SetNX method.
	SetNXFunc func(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.BoolCmd

	// SetRangeFunc mocks the SetRange method.
	SetRangeFunc func(ctx context.Context, key string, offset int64, value string) *redis.IntCmd

	// SetXXFunc mocks the SetXX method.
	SetXXFunc func(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.BoolCmd

	// ShutdownFunc mocks the Shutdown method.
	ShutdownFunc func(ctx context.Context) *redis.StatusCmd

	// ShutdownNoSaveFunc mocks the ShutdownNoSave method.
	ShutdownNoSaveFunc func(ctx context.Context) *redis.StatusCmd

	// ShutdownSaveFunc mocks the ShutdownSave method.
	ShutdownSaveFunc func(ctx context.Context) *redis.StatusCmd

	// SlaveOfFunc mocks the SlaveOf method.
	SlaveOfFunc func(ctx context.Context, host string, port string) *redis.StatusCmd

	// SlowLogGetFunc mocks the SlowLogGet method.
	SlowLogGetFunc func(ctx context.Context, num int64) *redis.SlowLogCmd

	// SortFunc mocks the Sort method.
	SortFunc func(ctx context.Context, key string, sort *redis.Sort) *redis.StringSliceCmd

	// SortInterfacesFunc mocks the SortInterfaces method.
	SortInterfacesFunc func(ctx context.Context, key string, sort *redis.Sort) *redis.SliceCmd

	// SortROFunc mocks the SortRO method.
	SortROFunc func(ctx context.Context, key string, sort *redis.Sort) *redis.StringSliceCmd

	// SortStoreFunc mocks the SortStore method.
	SortStoreFunc func(ctx context.Context, key string, store string, sort *redis.Sort) *redis.IntCmd

	// StrLenFunc mocks the StrLen method.
	StrLenFunc func(ctx context.Context, key string) *redis.IntCmd

	// SubscribeFunc mocks the Subscribe method.
	SubscribeFunc func(ctx context.Context, channels ...string) *redis.PubSub

	// TDigestAddFunc mocks the TDigestAdd method.
	TDigestAddFunc func(ctx context.Context, key string, elements ...float64) *redis.StatusCmd

	// TDigestByRankFunc mocks the TDigestByRank method.
	TDigestByRankFunc func(ctx context.Context, key string, rank ...uint64) *redis.FloatSliceCmd

	// TDigestByRevRankFunc mocks the TDigestByRevRank method.
	TDigestByRevRankFunc func(ctx context.Context, key string, rank ...uint64) *redis.FloatSliceCmd

	// TDigestCDFFunc mocks the TDigestCDF method.
	TDigestCDFFunc func(ctx context.Context, key string, elements ...float64) *redis.FloatSliceCmd

	// TDigestCreateFunc mocks the TDigestCreate method.
	TDigestCreateFunc func(ctx context.Context, key string) *redis.StatusCmd

	// TDigestCreateWithCompressionFunc mocks the TDigestCreateWithCompression method.
	TDigestCreateWithCompressionFunc func(ctx context.Context, key string, compression int64) *redis.StatusCmd

	// TDigestInfoFunc mocks the TDigestInfo method.
	TDigestInfoFunc func(ctx context.Context, key string) *redis.TDigestInfoCmd

	// TDigestMaxFunc mocks the TDigestMax method.
	TDigestMaxFunc func(ctx context.Context, key string) *redis.FloatCmd

	// TDigestMergeFunc mocks the TDigestMerge method.
	TDigestMergeFunc func(ctx context.Context, destKey string, options *redis.TDigestMergeOptions, sourceKeys ...string) *redis.StatusCmd

	// TDigestMinFunc mocks the TDigestMin method.
	TDigestMinFunc func(ctx context.Context, key string) *redis.FloatCmd

	// TDigestQuantileFunc mocks the TDigestQuantile method.
	TDigestQuantileFunc func(ctx context.Context, key string, elements ...float64) *redis.FloatSliceCmd

	// TDigestRankFunc mocks the TDigestRank method.
	TDigestRankFunc func(ctx context.Context, key string, values ...float64) *redis.IntSliceCmd

	// TDigestResetFunc mocks the TDigestReset method.
	TDigestResetFunc func(ctx context.Context, key string) *redis.StatusCmd

	// TDigestRevRankFunc mocks the TDigestRevRank method.
	TDigestRevRankFunc func(ctx context.Context, key string, values ...float64) *redis.IntSliceCmd

	// TDigestTrimmedMeanFunc mocks the TDigestTrimmedMean method.
	TDigestTrimmedMeanFunc func(ctx context.Context, key string, lowCutQuantile float64, highCutQuantile float64) *redis.FloatCmd

	// TSAddFunc mocks the TSAdd method.
	TSAddFunc func(ctx context.Context, key string, timestamp interface{}, value float64) *redis.IntCmd

	// TSAddWithArgsFunc mocks the TSAddWithArgs method.
	TSAddWithArgsFunc func(ctx context.Context, key string, timestamp interface{}, value float64, options *redis.TSOptions) *redis.IntCmd

	// TSAlterFunc mocks the TSAlter method.
	TSAlterFunc func(ctx context.Context, key string, options *redis.TSAlterOptions) *redis.StatusCmd

	// TSCreateFunc mocks the TSCreate method.
	TSCreateFunc func(ctx context.Context, key string) *redis.StatusCmd

	// TSCreateRuleFunc mocks the TSCreateRule method.
	TSCreateRuleFunc func(ctx context.Context, sourceKey string, destKey string, aggregator redis.Aggregator, bucketDuration int) *redis.StatusCmd

	// TSCreateRuleWithArgsFunc mocks the TSCreateRuleWithArgs method.
	TSCreateRuleWithArgsFunc func(ctx context.Context, sourceKey string, destKey string, aggregator redis.Aggregator, bucketDuration int, options *redis.TSCreateRuleOptions) *redis.StatusCmd

	// TSCreateWithArgsFunc mocks the TSCreateWithArgs method.
	TSCreateWithArgsFunc func(ctx context.Context, key string, options *redis.TSOptions) *redis.StatusCmd

	// TSDecrByFunc mocks the TSDecrBy method.
	TSDecrByFunc func(ctx context.Context, Key string, timestamp float64) *redis.IntCmd

	// TSDecrByWithArgsFunc mocks the TSDecrByWithArgs method.
	TSDecrByWithArgsFunc func(ctx context.Context, key string, timestamp float64, options *redis.TSIncrDecrOptions) *redis.IntCmd

	// TSDelFunc mocks the TSDel method.
	TSDelFunc func(ctx context.Context, Key string, fromTimestamp int, toTimestamp int) *redis.IntCmd

	// TSDeleteRuleFunc mocks the TSDeleteRule method.
	TSDeleteRuleFunc func(ctx context.Context, sourceKey string, destKey string) *redis.StatusCmd

	// TSGetFunc mocks the TSGet method.
	TSGetFunc func(ctx context.Context, key string) *redis.TSTimestampValueCmd

	// TSGetWithArgsFunc mocks the TSGetWithArgs method.
	TSGetWithArgsFunc func(ctx context.Context, key string, options *redis.TSGetOptions) *redis.TSTimestampValueCmd

	// TSIncrByFunc mocks the TSIncrBy method.
	TSIncrByFunc func(ctx context.Context, Key string, timestamp float64) *redis.IntCmd

	// TSIncrByWithArgsFunc mocks the TSIncrByWithArgs method.
	TSIncrByWithArgsFunc func(ctx context.Context, key string, timestamp float64, options *redis.TSIncrDecrOptions) *redis.IntCmd

	// TSInfoFunc mocks the TSInfo method.
	TSInfoFunc func(ctx context.Context, key string) *redis.MapStringInterfaceCmd

	// TSInfoWithArgsFunc mocks the TSInfoWithArgs method.
	TSInfoWithArgsFunc func(ctx context.Context, key string, options *redis.TSInfoOptions) *redis.MapStringInterfaceCmd

	// TSMAddFunc mocks the TSMAdd method.
	TSMAddFunc func(ctx context.Context, ktvSlices [][]interface{}) *redis.IntSliceCmd

	// TSMGetFunc mocks the TSMGet method.
	TSMGetFunc func(ctx context.Context, filters []string) *redis.MapStringSliceInterfaceCmd

	// TSMGetWithArgsFunc mocks the TSMGetWithArgs method.
	TSMGetWithArgsFunc func(ctx context.Context, filters []string, options *redis.TSMGetOptions) *redis.MapStringSliceInterfaceCmd

	// TSMRangeFunc mocks the TSMRange method.
	TSMRangeFunc func(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string) *redis.MapStringSliceInterfaceCmd

	// TSMRangeWithArgsFunc mocks the TSMRangeWithArgs method.
	TSMRangeWithArgsFunc func(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string, options *redis.TSMRangeOptions) *redis.MapStringSliceInterfaceCmd

	// TSMRevRangeFunc mocks the TSMRevRange method.
	TSMRevRangeFunc func(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string) *redis.MapStringSliceInterfaceCmd

	// TSMRevRangeWithArgsFunc mocks the TSMRevRangeWithArgs method.
	TSMRevRangeWithArgsFunc func(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string, options *redis.TSMRevRangeOptions) *redis.MapStringSliceInterfaceCmd

	// TSQueryIndexFunc mocks the TSQueryIndex method.
	TSQueryIndexFunc func(ctx context.Context, filterExpr []string) *redis.StringSliceCmd

	// TSRangeFunc mocks the TSRange method.
	TSRangeFunc func(ctx context.Context, key string, fromTimestamp int, toTimestamp int) *redis.TSTimestampValueSliceCmd

	// TSRangeWithArgsFunc mocks the TSRangeWithArgs method.
	TSRangeWithArgsFunc func(ctx context.Context, key string, fromTimestamp int, toTimestamp int, options *redis.TSRangeOptions) *redis.TSTimestampValueSliceCmd

	// TSRevRangeFunc mocks the TSRevRange method.
	TSRevRangeFunc func(ctx context.Context, key string, fromTimestamp int, toTimestamp int) *redis.TSTimestampValueSliceCmd

	// TSRevRangeWithArgsFunc mocks the TSRevRangeWithArgs method.
	TSRevRangeWithArgsFunc func(ctx context.Context, key string, fromTimestamp int, toTimestamp int, options *redis.TSRevRangeOptions) *redis.TSTimestampValueSliceCmd

	// TTLFunc mocks the TTL method.
	TTLFunc func(ctx context.Context, key string) *redis.DurationCmd

	// TimeFunc mocks the Time method.
	TimeFunc func(ctx context.Context) *redis.TimeCmd

	// TopKAddFunc mocks the TopKAdd method.
	TopKAddFunc func(ctx context.Context, key string, elements ...interface{}) *redis.StringSliceCmd

	// TopKCountFunc mocks the TopKCount method.
	TopKCountFunc func(ctx context.Context, key string, elements ...interface{}) *redis.IntSliceCmd

	// TopKIncrByFunc mocks the TopKIncrBy method.
	TopKIncrByFunc func(ctx context.Context, key string, elements ...interface{}) *redis.StringSliceCmd

	// TopKInfoFunc mocks the TopKInfo method.
	TopKInfoFunc func(ctx context.Context, key string) *redis.TopKInfoCmd

	// TopKListFunc mocks the TopKList method.
	TopKListFunc func(ctx context.Context, key string) *redis.StringSliceCmd

	// TopKListWithCountFunc mocks the TopKListWithCount method.
	TopKListWithCountFunc func(ctx context.Context, key string) *redis.MapStringIntCmd

	// TopKQueryFunc mocks the TopKQuery method.
	TopKQueryFunc func(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd

	// TopKReserveFunc mocks the TopKReserve method.
	TopKReserveFunc func(ctx context.Context, key string, k int64) *redis.StatusCmd

	// TopKReserveWithOptionsFunc mocks the TopKReserveWithOptions method.
	TopKReserveWithOptionsFunc func(ctx context.Context, key string, k int64, width int64, depth int64, decay float64) *redis.StatusCmd

	// TouchFunc mocks the Touch method.
	TouchFunc func(ctx context.Context, keys ...string) *redis.IntCmd

	// TxPipelineFunc mocks the TxPipeline method.
	TxPipelineFunc func() redis.Pipeliner

	// TxPipelinedFunc mocks the TxPipelined method.
	TxPipelinedFunc func(ctx context.Context, fn func(redis.Pipeliner) error) ([]redis.Cmder, error)

	// TypeFunc mocks the Type method.
	TypeFunc func(ctx context.Context, key string) *redis.StatusCmd

	// UnlinkFunc mocks the Unlink method.
	UnlinkFunc func(ctx context.Context, keys ...string) *redis.IntCmd

	// WatchFunc mocks the Watch method.
	WatchFunc func(ctx context.Context, fn func(*redis.Tx) error, keys ...string) error

	// XAckFunc mocks the XAck method.
	XAckFunc func(ctx context.Context, stream string, group string, ids ...string) *redis.IntCmd

	// XAddFunc mocks the XAdd method.
	XAddFunc func(ctx context.Context, a *redis.XAddArgs) *redis.StringCmd

	// XAutoClaimFunc mocks the XAutoClaim method.
	XAutoClaimFunc func(ctx context.Context, a *redis.XAutoClaimArgs) *redis.XAutoClaimCmd

	// XAutoClaimJustIDFunc mocks the XAutoClaimJustID method.
	XAutoClaimJustIDFunc func(ctx context.Context, a *redis.XAutoClaimArgs) *redis.XAutoClaimJustIDCmd

	// XClaimFunc mocks the XClaim method.
	XClaimFunc func(ctx context.Context, a *redis.XClaimArgs) *redis.XMessageSliceCmd

	// XClaimJustIDFunc mocks the XClaimJustID method.
	XClaimJustIDFunc func(ctx context.Context, a *redis.XClaimArgs) *redis.StringSliceCmd

	// XDelFunc mocks the XDel method.
	XDelFunc func(ctx context.Context, stream string, ids ...string) *redis.IntCmd

	// XGroupCreateFunc mocks the XGroupCreate method.
	XGroupCreateFunc func(ctx context.Context, stream string, group string, start string) *redis.StatusCmd

	// XGroupCreateConsumerFunc mocks the XGroupCreateConsumer method.
	XGroupCreateConsumerFunc func(ctx context.Context, stream string, group string, consumer string) *redis.IntCmd

	// XGroupCreateMkStreamFunc mocks the XGroupCreateMkStream method.
	XGroupCreateMkStreamFunc func(ctx context.Context, stream string, group string, start string) *redis.StatusCmd

	// XGroupDelConsumerFunc mocks the XGroupDelConsumer method.
	XGroupDelConsumerFunc func(ctx context.Context, stream string, group string, consumer string) *redis.IntCmd

	// XGroupDestroyFunc mocks the XGroupDestroy method.
	XGroupDestroyFunc func(ctx context.Context, stream string, group string) *redis.IntCmd

	// XGroupSetIDFunc mocks the XGroupSetID method.
	XGroupSetIDFunc func(ctx context.Context, stream string, group string, start string) *redis.StatusCmd

	// XInfoConsumersFunc mocks the XInfoConsumers method.
	XInfoConsumersFunc func(ctx context.Context, key string, group string) *redis.XInfoConsumersCmd

	// XInfoGroupsFunc mocks the XInfoGroups method.
	XInfoGroupsFunc func(ctx context.Context, key string) *redis.XInfoGroupsCmd

	// XInfoStreamFunc mocks the XInfoStream method.
	XInfoStreamFunc func(ctx context.Context, key string) *redis.XInfoStreamCmd

	// XInfoStreamFullFunc mocks the XInfoStreamFull method.
	XInfoStreamFullFunc func(ctx context.Context, key string, count int) *redis.XInfoStreamFullCmd

	// XLenFunc mocks the XLen method.
	XLenFunc func(ctx context.Context, stream string) *redis.IntCmd

	// XPendingFunc mocks the XPending method.
	XPendingFunc func(ctx context.Context, stream string, group string) *redis.XPendingCmd

	// XPendingExtFunc mocks the XPendingExt method.
	XPendingExtFunc func(ctx context.Context, a *redis.XPendingExtArgs) *redis.XPendingExtCmd

	// XRangeFunc mocks the XRange method.
	XRangeFunc func(ctx context.Context, stream string, start string, stop string) *redis.XMessageSliceCmd

	// XRangeNFunc mocks the XRangeN method.
	XRangeNFunc func(ctx context.Context, stream string, start string, stop string, count int64) *redis.XMessageSliceCmd

	// XReadFunc mocks the XRead method.
	XReadFunc func(ctx context.Context, a *redis.XReadArgs) *redis.XStreamSliceCmd

	// XReadGroupFunc mocks the XReadGroup method.
	XReadGroupFunc func(ctx context.Context, a *redis.XReadGroupArgs) *redis.XStreamSliceCmd

	// XReadStreamsFunc mocks the XReadStreams method.
	XReadStreamsFunc func(ctx context.Context, streams ...string) *redis.XStreamSliceCmd

	// XRevRangeFunc mocks the XRevRange method.
	XRevRangeFunc func(ctx context.Context, stream string, start string, stop string) *redis.XMessageSliceCmd

	// XRevRangeNFunc mocks the XRevRangeN method.
	XRevRangeNFunc func(ctx context.Context, stream string, start string, stop string, count int64) *redis.XMessageSliceCmd

	// XTrimMaxLenFunc mocks the XTrimMaxLen method.
	XTrimMaxLenFunc func(ctx context.Context, key string, maxLen int64) *redis.IntCmd

	// XTrimMaxLenApproxFunc mocks the XTrimMaxLenApprox method.
	XTrimMaxLenApproxFunc func(ctx context.Context, key string, maxLen int64, limit int64) *redis.IntCmd

	// XTrimMinIDFunc mocks the XTrimMinID method.
	XTrimMinIDFunc func(ctx context.Context, key string, minID string) *redis.IntCmd

	// XTrimMinIDApproxFunc mocks the XTrimMinIDApprox method.
	XTrimMinIDApproxFunc func(ctx context.Context, key string, minID string, limit int64) *redis.IntCmd

	// ZAddFunc mocks the ZAdd method.
	ZAddFunc func(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd

	// ZAddArgsFunc mocks the ZAddArgs method.
	ZAddArgsFunc func(ctx context.Context, key string, args redis.ZAddArgs) *redis.IntCmd

	// ZAddArgsIncrFunc mocks the ZAddArgsIncr method.
	ZAddArgsIncrFunc func(ctx context.Context, key string, args redis.ZAddArgs) *redis.FloatCmd

	// ZAddGTFunc mocks the ZAddGT method.
	ZAddGTFunc func(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd

	// ZAddLTFunc mocks the ZAddLT method.
	ZAddLTFunc func(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd

	// ZAddNXFunc mocks the ZAddNX method.
	ZAddNXFunc func(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd

	// ZAddXXFunc mocks the ZAddXX method.
	ZAddXXFunc func(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd

	// ZCardFunc mocks the ZCard method.
	ZCardFunc func(ctx context.Context, key string) *redis.IntCmd

	// ZCountFunc mocks the ZCount method.
	ZCountFunc func(ctx context.Context, key string, min string, max string) *redis.IntCmd

	// ZDiffFunc mocks the ZDiff method.
	ZDiffFunc func(ctx context.Context, keys ...string) *redis.StringSliceCmd

	// ZDiffStoreFunc mocks the ZDiffStore method.
	ZDiffStoreFunc func(ctx context.Context, destination string, keys ...string) *redis.IntCmd

	// ZDiffWithScoresFunc mocks the ZDiffWithScores method.
	ZDiffWithScoresFunc func(ctx context.Context, keys ...string) *redis.ZSliceCmd

	// ZIncrByFunc mocks the ZIncrBy method.
	ZIncrByFunc func(ctx context.Context, key string, increment float64, member string) *redis.FloatCmd

	// ZInterFunc mocks the ZInter method.
	ZInterFunc func(ctx context.Context, store *redis.ZStore) *redis.StringSliceCmd

	// ZInterCardFunc mocks the ZInterCard method.
	ZInterCardFunc func(ctx context.Context, limit int64, keys ...string) *redis.IntCmd

	// ZInterStoreFunc mocks the ZInterStore method.
	ZInterStoreFunc func(ctx context.Context, destination string, store *redis.ZStore) *redis.IntCmd

	// ZInterWithScoresFunc mocks the ZInterWithScores method.
	ZInterWithScoresFunc func(ctx context.Context, store *redis.ZStore) *redis.ZSliceCmd

	// ZLexCountFunc mocks the ZLexCount method.
	ZLexCountFunc func(ctx context.Context, key string, min string, max string) *redis.IntCmd

	// ZMPopFunc mocks the ZMPop method.
	ZMPopFunc func(ctx context.Context, order string, count int64, keys ...string) *redis.ZSliceWithKeyCmd

	// ZMScoreFunc mocks the ZMScore method.
	ZMScoreFunc func(ctx context.Context, key string, members ...string) *redis.FloatSliceCmd

	// ZPopMaxFunc mocks the ZPopMax method.
	ZPopMaxFunc func(ctx context.Context, key string, count ...int64) *redis.ZSliceCmd

	// ZPopMinFunc mocks the ZPopMin method.
	ZPopMinFunc func(ctx context.Context, key string, count ...int64) *redis.ZSliceCmd

	// ZRandMemberFunc mocks the ZRandMember method.
	ZRandMemberFunc func(ctx context.Context, key string, count int) *redis.StringSliceCmd

	// ZRandMemberWithScoresFunc mocks the ZRandMemberWithScores method.
	ZRandMemberWithScoresFunc func(ctx context.Context, key string, count int) *redis.ZSliceCmd

	// ZRangeFunc mocks the ZRange method.
	ZRangeFunc func(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd

	// ZRangeArgsFunc mocks the ZRangeArgs method.
	ZRangeArgsFunc func(ctx context.Context, z redis.ZRangeArgs) *redis.StringSliceCmd

	// ZRangeArgsWithScoresFunc mocks the ZRangeArgsWithScores method.
	ZRangeArgsWithScoresFunc func(ctx context.Context, z redis.ZRangeArgs) *redis.ZSliceCmd

	// ZRangeByLexFunc mocks the ZRangeByLex method.
	ZRangeByLexFunc func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd

	// ZRangeByScoreFunc mocks the ZRangeByScore method.
	ZRangeByScoreFunc func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd

	// ZRangeByScoreWithScoresFunc mocks the ZRangeByScoreWithScores method.
	ZRangeByScoreWithScoresFunc func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.ZSliceCmd

	// ZRangeStoreFunc mocks the ZRangeStore method.
	ZRangeStoreFunc func(ctx context.Context, dst string, z redis.ZRangeArgs) *redis.IntCmd

	// ZRangeWithScoresFunc mocks the ZRangeWithScores method.
	ZRangeWithScoresFunc func(ctx context.Context, key string, start int64, stop int64) *redis.ZSliceCmd

	// ZRankFunc mocks the ZRank method.
	ZRankFunc func(ctx context.Context, key string, member string) *redis.IntCmd

	// ZRankWithScoreFunc mocks the ZRankWithScore method.
	ZRankWithScoreFunc func(ctx context.Context, key string, member string) *redis.RankWithScoreCmd

	// ZRemFunc mocks the ZRem method.
	ZRemFunc func(ctx context.Context, key string, members ...interface{}) *redis.IntCmd

	// ZRemRangeByLexFunc mocks the ZRemRangeByLex method.
	ZRemRangeByLexFunc func(ctx context.Context, key string, min string, max string) *redis.IntCmd

	// ZRemRangeByRankFunc mocks the ZRemRangeByRank method.
	ZRemRangeByRankFunc func(ctx context.Context, key string, start int64, stop int64) *redis.IntCmd

	// ZRemRangeByScoreFunc mocks the ZRemRangeByScore method.
	ZRemRangeByScoreFunc func(ctx context.Context, key string, min string, max string) *redis.IntCmd

	// ZRevRangeFunc mocks the ZRevRange method.
	ZRevRangeFunc func(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd

	// ZRevRangeByLexFunc mocks the ZRevRangeByLex method.
	ZRevRangeByLexFunc func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd

	// ZRevRangeByScoreFunc mocks the ZRevRangeByScore method.
	ZRevRangeByScoreFunc func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd

	// ZRevRangeByScoreWithScoresFunc mocks the ZRevRangeByScoreWithScores method.
	ZRevRangeByScoreWithScoresFunc func(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.ZSliceCmd

	// ZRevRangeWithScoresFunc mocks the ZRevRangeWithScores method.
	ZRevRangeWithScoresFunc func(ctx context.Context, key string, start int64, stop int64) *redis.ZSliceCmd

	// ZRevRankFunc mocks the ZRevRank method.
	ZRevRankFunc func(ctx context.Context, key string, member string) *redis.IntCmd

	// ZRevRankWithScoreFunc mocks the ZRevRankWithScore method.
	ZRevRankWithScoreFunc func(ctx context.Context, key string, member string) *redis.RankWithScoreCmd

	// ZScanFunc mocks the ZScan method.
	ZScanFunc func(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd

	// ZScoreFunc mocks the ZScore method.
	ZScoreFunc func(ctx context.Context, key string, member string) *redis.FloatCmd

	// ZUnionFunc mocks the ZUnion method.
	ZUnionFunc func(ctx context.Context, store redis.ZStore) *redis.StringSliceCmd

	// ZUnionStoreFunc mocks the ZUnionStore method.
	ZUnionStoreFunc func(ctx context.Context, dest string, store *redis.ZStore) *redis.IntCmd

	// ZUnionWithScoresFunc mocks the ZUnionWithScores method.
	ZUnionWithScoresFunc func(ctx context.Context, store redis.ZStore) *redis.ZSliceCmd

	// calls tracks calls to the methods.
	calls struct {
		// ACLCat holds details about calls to the ACLCat method.
		ACLCat []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ACLCatArgs holds details about calls to the ACLCatArgs method.
		ACLCatArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Options is the options argument value.
			Options *redis.ACLCatArgs
		}
		// ACLDelUser holds details about calls to the ACLDelUser method.
		ACLDelUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Username is the username argument value.
			Username string
		}
		// ACLDryRun holds details about calls to the ACLDryRun method.
		ACLDryRun []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Username is the username argument value.
			Username string
			// Command is the command argument value.
			Command []interface{}
		}
		// ACLList holds details about calls to the ACLList method.
		ACLList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ACLLog holds details about calls to the ACLLog method.
		ACLLog []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Count is the count argument value.
			Count int64
		}
		// ACLLogReset holds details about calls to the ACLLogReset method.
		ACLLogReset []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ACLSetUser holds details about calls to the ACLSetUser method.
		ACLSetUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Username is the username argument value.
			Username string
			// Rules is the rules argument value.
			Rules []string
		}
		// AddHook holds details about calls to the AddHook method.
		AddHook []struct {
			// Hook is the hook argument value.
			Hook redis.Hook
		}
		// Append holds details about calls to the Append method.
		Append []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value string
		}
		// BFAdd holds details about calls to the BFAdd method.
		BFAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Element is the element argument value.
			Element interface{}
		}
		// BFCard holds details about calls to the BFCard method.
		BFCard []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// BFExists holds details about calls to the BFExists method.
		BFExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Element is the element argument value.
			Element interface{}
		}
		// BFInfo holds details about calls to the BFInfo method.
		BFInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// BFInfoArg holds details about calls to the BFInfoArg method.
		BFInfoArg []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Option is the option argument value.
			Option string
		}
		// BFInfoCapacity holds details about calls to the BFInfoCapacity method.
		BFInfoCapacity []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// BFInfoExpansion holds details about calls to the BFInfoExpansion method.
		BFInfoExpansion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// BFInfoFilters holds details about calls to the BFInfoFilters method.
		BFInfoFilters []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// BFInfoItems holds details about calls to the BFInfoItems method.
		BFInfoItems []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// BFInfoSize holds details about calls to the BFInfoSize method.
		BFInfoSize []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// BFInsert holds details about calls to the BFInsert method.
		BFInsert []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.BFInsertOptions
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// BFLoadChunk holds details about calls to the BFLoadChunk method.
		BFLoadChunk []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Iterator is the iterator argument value.
			Iterator int64
			// Data is the data argument value.
			Data interface{}
		}
		// BFMAdd holds details about calls to the BFMAdd method.
		BFMAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// BFMExists holds details about calls to the BFMExists method.
		BFMExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// BFReserve holds details about calls to the BFReserve method.
		BFReserve []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// ErrorRate is the errorRate argument value.
			ErrorRate float64
			// Capacity is the capacity argument value.
			Capacity int64
		}
		// BFReserveExpansion holds details about calls to the BFReserveExpansion method.
		BFReserveExpansion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// ErrorRate is the errorRate argument value.
			ErrorRate float64
			// Capacity is the capacity argument value.
			Capacity int64
			// Expansion is the expansion argument value.
			Expansion int64
		}
		// BFReserveNonScaling holds details about calls to the BFReserveNonScaling method.
		BFReserveNonScaling []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// ErrorRate is the errorRate argument value.
			ErrorRate float64
			// Capacity is the capacity argument value.
			Capacity int64
		}
		// BFReserveWithArgs holds details about calls to the BFReserveWithArgs method.
		BFReserveWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.BFReserveOptions
		}
		// BFScanDump holds details about calls to the BFScanDump method.
		BFScanDump []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Iterator is the iterator argument value.
			Iterator int64
		}
		// BLMPop holds details about calls to the BLMPop method.
		BLMPop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Timeout is the timeout argument value.
			Timeout time.Duration
			// Direction is the direction argument value.
			Direction string
			// Count is the count argument value.
			Count int64
			// Keys is the keys argument value.
			Keys []string
		}
		// BLMove holds details about calls to the BLMove method.
		BLMove []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Source is the source argument value.
			Source string
			// Destination is the destination argument value.
			Destination string
			// Srcpos is the srcpos argument value.
			Srcpos string
			// Destpos is the destpos argument value.
			Destpos string
			// Timeout is the timeout argument value.
			Timeout time.Duration
		}
		// BLPop holds details about calls to the BLPop method.
		BLPop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Timeout is the timeout argument value.
			Timeout time.Duration
			// Keys is the keys argument value.
			Keys []string
		}
		// BRPop holds details about calls to the BRPop method.
		BRPop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Timeout is the timeout argument value.
			Timeout time.Duration
			// Keys is the keys argument value.
			Keys []string
		}
		// BRPopLPush holds details about calls to the BRPopLPush method.
		BRPopLPush []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Source is the source argument value.
			Source string
			// Destination is the destination argument value.
			Destination string
			// Timeout is the timeout argument value.
			Timeout time.Duration
		}
		// BZMPop holds details about calls to the BZMPop method.
		BZMPop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Timeout is the timeout argument value.
			Timeout time.Duration
			// Order is the order argument value.
			Order string
			// Count is the count argument value.
			Count int64
			// Keys is the keys argument value.
			Keys []string
		}
		// BZPopMax holds details about calls to the BZPopMax method.
		BZPopMax []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Timeout is the timeout argument value.
			Timeout time.Duration
			// Keys is the keys argument value.
			Keys []string
		}
		// BZPopMin holds details about calls to the BZPopMin method.
		BZPopMin []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Timeout is the timeout argument value.
			Timeout time.Duration
			// Keys is the keys argument value.
			Keys []string
		}
		// BgRewriteAOF holds details about calls to the BgRewriteAOF method.
		BgRewriteAOF []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// BgSave holds details about calls to the BgSave method.
		BgSave []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// BitCount holds details about calls to the BitCount method.
		BitCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// BitCount is the bitCount argument value.
			BitCount *redis.BitCount
		}
		// BitField holds details about calls to the BitField method.
		BitField []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Values is the values argument value.
			Values []interface{}
		}
		// BitFieldRO holds details about calls to the BitFieldRO method.
		BitFieldRO []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Values is the values argument value.
			Values []interface{}
		}
		// BitOpAnd holds details about calls to the BitOpAnd method.
		BitOpAnd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DestKey is the destKey argument value.
			DestKey string
			// Keys is the keys argument value.
			Keys []string
		}
		// BitOpNot holds details about calls to the BitOpNot method.
		BitOpNot []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DestKey is the destKey argument value.
			DestKey string
			// Key is the key argument value.
			Key string
		}
		// BitOpOr holds details about calls to the BitOpOr method.
		BitOpOr []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DestKey is the destKey argument value.
			DestKey string
			// Keys is the keys argument value.
			Keys []string
		}
		// BitOpXor holds details about calls to the BitOpXor method.
		BitOpXor []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DestKey is the destKey argument value.
			DestKey string
			// Keys is the keys argument value.
			Keys []string
		}
		// BitPos holds details about calls to the BitPos method.
		BitPos []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Bit is the bit argument value.
			Bit int64
			// Pos is the pos argument value.
			Pos []int64
		}
		// BitPosSpan holds details about calls to the BitPosSpan method.
		BitPosSpan []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Bit is the bit argument value.
			Bit int8
			// Start is the start argument value.
			Start int64
			// End is the end argument value.
			End int64
			// Span is the span argument value.
			Span string
		}
		// CFAdd holds details about calls to the CFAdd method.
		CFAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Element is the element argument value.
			Element interface{}
		}
		// CFAddNX holds details about calls to the CFAddNX method.
		CFAddNX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Element is the element argument value.
			Element interface{}
		}
		// CFCount holds details about calls to the CFCount method.
		CFCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Element is the element argument value.
			Element interface{}
		}
		// CFDel holds details about calls to the CFDel method.
		CFDel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Element is the element argument value.
			Element interface{}
		}
		// CFExists holds details about calls to the CFExists method.
		CFExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Element is the element argument value.
			Element interface{}
		}
		// CFInfo holds details about calls to the CFInfo method.
		CFInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// CFInsert holds details about calls to the CFInsert method.
		CFInsert []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.CFInsertOptions
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// CFInsertNX holds details about calls to the CFInsertNX method.
		CFInsertNX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.CFInsertOptions
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// CFLoadChunk holds details about calls to the CFLoadChunk method.
		CFLoadChunk []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Iterator is the iterator argument value.
			Iterator int64
			// Data is the data argument value.
			Data interface{}
		}
		// CFMExists holds details about calls to the CFMExists method.
		CFMExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// CFReserve holds details about calls to the CFReserve method.
		CFReserve []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Capacity is the capacity argument value.
			Capacity int64
		}
		// CFReserveBucketSize holds details about calls to the CFReserveBucketSize method.
		CFReserveBucketSize []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Capacity is the capacity argument value.
			Capacity int64
			// Bucketsize is the bucketsize argument value.
			Bucketsize int64
		}
		// CFReserveExpansion holds details about calls to the CFReserveExpansion method.
		CFReserveExpansion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Capacity is the capacity argument value.
			Capacity int64
			// Expansion is the expansion argument value.
			Expansion int64
		}
		// CFReserveMaxIterations holds details about calls to the CFReserveMaxIterations method.
		CFReserveMaxIterations []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Capacity is the capacity argument value.
			Capacity int64
			// Maxiterations is the maxiterations argument value.
			Maxiterations int64
		}
		// CFReserveWithArgs holds details about calls to the CFReserveWithArgs method.
		CFReserveWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.CFReserveOptions
		}
		// CFScanDump holds details about calls to the CFScanDump method.
		CFScanDump []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Iterator is the iterator argument value.
			Iterator int64
		}
		// CMSIncrBy holds details about calls to the CMSIncrBy method.
		CMSIncrBy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// CMSInfo holds details about calls to the CMSInfo method.
		CMSInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// CMSInitByDim holds details about calls to the CMSInitByDim method.
		CMSInitByDim []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Width is the width argument value.
			Width int64
			// Height is the height argument value.
			Height int64
		}
		// CMSInitByProb holds details about calls to the CMSInitByProb method.
		CMSInitByProb []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// ErrorRate is the errorRate argument value.
			ErrorRate float64
			// Probability is the probability argument value.
			Probability float64
		}
		// CMSMerge holds details about calls to the CMSMerge method.
		CMSMerge []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DestKey is the destKey argument value.
			DestKey string
			// SourceKeys is the sourceKeys argument value.
			SourceKeys []string
		}
		// CMSMergeWithWeight holds details about calls to the CMSMergeWithWeight method.
		CMSMergeWithWeight []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DestKey is the destKey argument value.
			DestKey string
			// SourceKeys is the sourceKeys argument value.
			SourceKeys map[string]int64
		}
		// CMSQuery holds details about calls to the CMSQuery method.
		CMSQuery []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// ClientGetName holds details about calls to the ClientGetName method.
		ClientGetName []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClientID holds details about calls to the ClientID method.
		ClientID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClientInfo holds details about calls to the ClientInfo method.
		ClientInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClientKill holds details about calls to the ClientKill method.
		ClientKill []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IpPort is the ipPort argument value.
			IpPort string
		}
		// ClientKillByFilter holds details about calls to the ClientKillByFilter method.
		ClientKillByFilter []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// ClientList holds details about calls to the ClientList method.
		ClientList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClientPause holds details about calls to the ClientPause method.
		ClientPause []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dur is the dur argument value.
			Dur time.Duration
		}
		// ClientUnblock holds details about calls to the ClientUnblock method.
		ClientUnblock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// ClientUnblockWithError holds details about calls to the ClientUnblockWithError method.
		ClientUnblockWithError []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID int64
		}
		// ClientUnpause holds details about calls to the ClientUnpause method.
		ClientUnpause []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// ClusterAddSlots holds details about calls to the ClusterAddSlots method.
		ClusterAddSlots []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Slots is the slots argument value.
			Slots []int
		}
		// ClusterAddSlotsRange holds details about calls to the ClusterAddSlotsRange method.
		ClusterAddSlotsRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Min is the min argument value.
			Min int
			// Max is the max argument value.
			Max int
		}
		// ClusterCountFailureReports holds details about calls to the ClusterCountFailureReports method.
		ClusterCountFailureReports []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NodeID is the nodeID argument value.
			NodeID string
		}
		// ClusterCountKeysInSlot holds details about calls to the ClusterCountKeysInSlot method.
		ClusterCountKeysInSlot []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Slot is the slot argument value.
			Slot int
		}
		// ClusterDelSlots holds details about calls to the ClusterDelSlots method.
		ClusterDelSlots []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Slots is the slots argument value.
			Slots []int
		}
		// ClusterDelSlotsRange holds details about calls to the ClusterDelSlotsRange method.
		ClusterDelSlotsRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Min is the min argument value.
			Min int
			// Max is the max argument value.
			Max int
		}
		// ClusterFailover holds details about calls to the ClusterFailover method.
		ClusterFailover []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClusterForget holds details about calls to the ClusterForget method.
		ClusterForget []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NodeID is the nodeID argument value.
			NodeID string
		}
		// ClusterGetKeysInSlot holds details about calls to the ClusterGetKeysInSlot method.
		ClusterGetKeysInSlot []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Slot is the slot argument value.
			Slot int
			// Count is the count argument value.
			Count int
		}
		// ClusterInfo holds details about calls to the ClusterInfo method.
		ClusterInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClusterKeySlot holds details about calls to the ClusterKeySlot method.
		ClusterKeySlot []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// ClusterLinks holds details about calls to the ClusterLinks method.
		ClusterLinks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClusterMeet holds details about calls to the ClusterMeet method.
		ClusterMeet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Host is the host argument value.
			Host string
			// Port is the port argument value.
			Port string
		}
		// ClusterMyID holds details about calls to the ClusterMyID method.
		ClusterMyID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClusterMyShardID holds details about calls to the ClusterMyShardID method.
		ClusterMyShardID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClusterNodes holds details about calls to the ClusterNodes method.
		ClusterNodes []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClusterReplicate holds details about calls to the ClusterReplicate method.
		ClusterReplicate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NodeID is the nodeID argument value.
			NodeID string
		}
		// ClusterResetHard holds details about calls to the ClusterResetHard method.
		ClusterResetHard []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClusterResetSoft holds details about calls to the ClusterResetSoft method.
		ClusterResetSoft []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClusterSaveConfig holds details about calls to the ClusterSaveConfig method.
		ClusterSaveConfig []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClusterShards holds details about calls to the ClusterShards method.
		ClusterShards []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ClusterSlaves holds details about calls to the ClusterSlaves method.
		ClusterSlaves []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// NodeID is the nodeID argument value.
			NodeID string
		}
		// ClusterSlots holds details about calls to the ClusterSlots method.
		ClusterSlots []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Command holds details about calls to the Command method.
		Command []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CommandGetKeys holds details about calls to the CommandGetKeys method.
		CommandGetKeys []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Commands is the commands argument value.
			Commands []interface{}
		}
		// CommandGetKeysAndFlags holds details about calls to the CommandGetKeysAndFlags method.
		CommandGetKeysAndFlags []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Commands is the commands argument value.
			Commands []interface{}
		}
		// CommandList holds details about calls to the CommandList method.
		CommandList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Filter is the filter argument value.
			Filter *redis.FilterBy
		}
		// ConfigGet holds details about calls to the ConfigGet method.
		ConfigGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Parameter is the parameter argument value.
			Parameter string
		}
		// ConfigResetStat holds details about calls to the ConfigResetStat method.
		ConfigResetStat []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ConfigRewrite holds details about calls to the ConfigRewrite method.
		ConfigRewrite []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ConfigSet holds details about calls to the ConfigSet method.
		ConfigSet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Parameter is the parameter argument value.
			Parameter string
			// Value is the value argument value.
			Value string
		}
		// Copy holds details about calls to the Copy method.
		Copy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SourceKey is the sourceKey argument value.
			SourceKey string
			// DestKey is the destKey argument value.
			DestKey string
			// Db is the db argument value.
			Db int
			// Replace is the replace argument value.
			Replace bool
		}
		// DBSize holds details about calls to the DBSize method.
		DBSize []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// DebugObject holds details about calls to the DebugObject method.
		DebugObject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Decr holds details about calls to the Decr method.
		Decr []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// DecrBy holds details about calls to the DecrBy method.
		DecrBy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Decrement is the decrement argument value.
			Decrement int64
		}
		// Del holds details about calls to the Del method.
		Del []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// Do holds details about calls to the Do method.
		Do []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Args is the args argument value.
			Args []interface{}
		}
		// Dump holds details about calls to the Dump method.
		Dump []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Echo holds details about calls to the Echo method.
		Echo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Message is the message argument value.
			Message interface{}
		}
		// Eval holds details about calls to the Eval method.
		Eval []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Script is the script argument value.
			Script string
			// Keys is the keys argument value.
			Keys []string
			// Args is the args argument value.
			Args []interface{}
		}
		// EvalRO holds details about calls to the EvalRO method.
		EvalRO []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Script is the script argument value.
			Script string
			// Keys is the keys argument value.
			Keys []string
			// Args is the args argument value.
			Args []interface{}
		}
		// EvalSha holds details about calls to the EvalSha method.
		EvalSha []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sha1 is the sha1 argument value.
			Sha1 string
			// Keys is the keys argument value.
			Keys []string
			// Args is the args argument value.
			Args []interface{}
		}
		// EvalShaRO holds details about calls to the EvalShaRO method.
		EvalShaRO []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Sha1 is the sha1 argument value.
			Sha1 string
			// Keys is the keys argument value.
			Keys []string
			// Args is the args argument value.
			Args []interface{}
		}
		// Exists holds details about calls to the Exists method.
		Exists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// Expire holds details about calls to the Expire method.
		Expire []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// ExpireAt holds details about calls to the ExpireAt method.
		ExpireAt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Tm is the tm argument value.
			Tm time.Time
		}
		// ExpireGT holds details about calls to the ExpireGT method.
		ExpireGT []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// ExpireLT holds details about calls to the ExpireLT method.
		ExpireLT []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// ExpireNX holds details about calls to the ExpireNX method.
		ExpireNX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// ExpireTime holds details about calls to the ExpireTime method.
		ExpireTime []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// ExpireXX holds details about calls to the ExpireXX method.
		ExpireXX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// FCall holds details about calls to the FCall method.
		FCall []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Function is the function argument value.
			Function string
			// Keys is the keys argument value.
			Keys []string
			// Args is the args argument value.
			Args []interface{}
		}
		// FCallRO holds details about calls to the FCallRO method.
		FCallRO []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Function is the function argument value.
			Function string
			// Keys is the keys argument value.
			Keys []string
			// Args is the args argument value.
			Args []interface{}
		}
		// FCallRo holds details about calls to the FCallRo method.
		FCallRo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Function is the function argument value.
			Function string
			// Keys is the keys argument value.
			Keys []string
			// Args is the args argument value.
			Args []interface{}
		}
		// FTAggregate holds details about calls to the FTAggregate method.
		FTAggregate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Query is the query argument value.
			Query string
		}
		// FTAggregateWithArgs holds details about calls to the FTAggregateWithArgs method.
		FTAggregateWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Query is the query argument value.
			Query string
			// Options is the options argument value.
			Options *redis.FTAggregateOptions
		}
		// FTAliasAdd holds details about calls to the FTAliasAdd method.
		FTAliasAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Alias is the alias argument value.
			Alias string
		}
		// FTAliasDel holds details about calls to the FTAliasDel method.
		FTAliasDel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Alias is the alias argument value.
			Alias string
		}
		// FTAliasUpdate holds details about calls to the FTAliasUpdate method.
		FTAliasUpdate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Alias is the alias argument value.
			Alias string
		}
		// FTAlter holds details about calls to the FTAlter method.
		FTAlter []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// SkipInitialScan is the skipInitialScan argument value.
			SkipInitialScan bool
			// Definition is the definition argument value.
			Definition []interface{}
		}
		// FTConfigGet holds details about calls to the FTConfigGet method.
		FTConfigGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Option is the option argument value.
			Option string
		}
		// FTConfigSet holds details about calls to the FTConfigSet method.
		FTConfigSet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Option is the option argument value.
			Option string
			// Value is the value argument value.
			Value interface{}
		}
		// FTCreate holds details about calls to the FTCreate method.
		FTCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Options is the options argument value.
			Options *redis.FTCreateOptions
			// Schema is the schema argument value.
			Schema []*redis.FieldSchema
		}
		// FTCursorDel holds details about calls to the FTCursorDel method.
		FTCursorDel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// CursorId is the cursorId argument value.
			CursorId int
		}
		// FTCursorRead holds details about calls to the FTCursorRead method.
		FTCursorRead []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// CursorId is the cursorId argument value.
			CursorId int
			// Count is the count argument value.
			Count int
		}
		// FTDictAdd holds details about calls to the FTDictAdd method.
		FTDictAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dict is the dict argument value.
			Dict string
			// Term is the term argument value.
			Term []interface{}
		}
		// FTDictDel holds details about calls to the FTDictDel method.
		FTDictDel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dict is the dict argument value.
			Dict string
			// Term is the term argument value.
			Term []interface{}
		}
		// FTDictDump holds details about calls to the FTDictDump method.
		FTDictDump []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dict is the dict argument value.
			Dict string
		}
		// FTDropIndex holds details about calls to the FTDropIndex method.
		FTDropIndex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
		}
		// FTDropIndexWithArgs holds details about calls to the FTDropIndexWithArgs method.
		FTDropIndexWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Options is the options argument value.
			Options *redis.FTDropIndexOptions
		}
		// FTExplain holds details about calls to the FTExplain method.
		FTExplain []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Query is the query argument value.
			Query string
		}
		// FTExplainWithArgs holds details about calls to the FTExplainWithArgs method.
		FTExplainWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Query is the query argument value.
			Query string
			// Options is the options argument value.
			Options *redis.FTExplainOptions
		}
		// FTInfo holds details about calls to the FTInfo method.
		FTInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
		}
		// FTSearch holds details about calls to the FTSearch method.
		FTSearch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Query is the query argument value.
			Query string
		}
		// FTSearchWithArgs holds details about calls to the FTSearchWithArgs method.
		FTSearchWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Query is the query argument value.
			Query string
			// Options is the options argument value.
			Options *redis.FTSearchOptions
		}
		// FTSpellCheck holds details about calls to the FTSpellCheck method.
		FTSpellCheck []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Query is the query argument value.
			Query string
		}
		// FTSpellCheckWithArgs holds details about calls to the FTSpellCheckWithArgs method.
		FTSpellCheckWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Query is the query argument value.
			Query string
			// Options is the options argument value.
			Options *redis.FTSpellCheckOptions
		}
		// FTSynDump holds details about calls to the FTSynDump method.
		FTSynDump []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
		}
		// FTSynUpdate holds details about calls to the FTSynUpdate method.
		FTSynUpdate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// SynGroupId is the synGroupId argument value.
			SynGroupId interface{}
			// Terms is the terms argument value.
			Terms []interface{}
		}
		// FTSynUpdateWithArgs holds details about calls to the FTSynUpdateWithArgs method.
		FTSynUpdateWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// SynGroupId is the synGroupId argument value.
			SynGroupId interface{}
			// Options is the options argument value.
			Options *redis.FTSynUpdateOptions
			// Terms is the terms argument value.
			Terms []interface{}
		}
		// FTTagVals holds details about calls to the FTTagVals method.
		FTTagVals []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Index is the index argument value.
			Index string
			// Field is the field argument value.
			Field string
		}
		// FT_List holds details about calls to the FT_List method.
		FT_List []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FlushAll holds details about calls to the FlushAll method.
		FlushAll []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FlushAllAsync holds details about calls to the FlushAllAsync method.
		FlushAllAsync []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FlushDB holds details about calls to the FlushDB method.
		FlushDB []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FlushDBAsync holds details about calls to the FlushDBAsync method.
		FlushDBAsync []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FunctionDelete holds details about calls to the FunctionDelete method.
		FunctionDelete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// LibName is the libName argument value.
			LibName string
		}
		// FunctionDump holds details about calls to the FunctionDump method.
		FunctionDump []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FunctionFlush holds details about calls to the FunctionFlush method.
		FunctionFlush []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FunctionFlushAsync holds details about calls to the FunctionFlushAsync method.
		FunctionFlushAsync []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FunctionKill holds details about calls to the FunctionKill method.
		FunctionKill []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FunctionList holds details about calls to the FunctionList method.
		FunctionList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Q is the q argument value.
			Q redis.FunctionListQuery
		}
		// FunctionLoad holds details about calls to the FunctionLoad method.
		FunctionLoad []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Code is the code argument value.
			Code string
		}
		// FunctionLoadReplace holds details about calls to the FunctionLoadReplace method.
		FunctionLoadReplace []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Code is the code argument value.
			Code string
		}
		// FunctionRestore holds details about calls to the FunctionRestore method.
		FunctionRestore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// LibDump is the libDump argument value.
			LibDump string
		}
		// FunctionStats holds details about calls to the FunctionStats method.
		FunctionStats []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GeoAdd holds details about calls to the GeoAdd method.
		GeoAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// GeoLocation is the geoLocation argument value.
			GeoLocation []*redis.GeoLocation
		}
		// GeoDist holds details about calls to the GeoDist method.
		GeoDist []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Member1 is the member1 argument value.
			Member1 string
			// Member2 is the member2 argument value.
			Member2 string
			// Unit is the unit argument value.
			Unit string
		}
		// GeoHash holds details about calls to the GeoHash method.
		GeoHash []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []string
		}
		// GeoPos holds details about calls to the GeoPos method.
		GeoPos []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []string
		}
		// GeoRadius holds details about calls to the GeoRadius method.
		GeoRadius []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Longitude is the longitude argument value.
			Longitude float64
			// Latitude is the latitude argument value.
			Latitude float64
			// Query is the query argument value.
			Query *redis.GeoRadiusQuery
		}
		// GeoRadiusByMember holds details about calls to the GeoRadiusByMember method.
		GeoRadiusByMember []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member string
			// Query is the query argument value.
			Query *redis.GeoRadiusQuery
		}
		// GeoRadiusByMemberStore holds details about calls to the GeoRadiusByMemberStore method.
		GeoRadiusByMemberStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member string
			// Query is the query argument value.
			Query *redis.GeoRadiusQuery
		}
		// GeoRadiusStore holds details about calls to the GeoRadiusStore method.
		GeoRadiusStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Longitude is the longitude argument value.
			Longitude float64
			// Latitude is the latitude argument value.
			Latitude float64
			// Query is the query argument value.
			Query *redis.GeoRadiusQuery
		}
		// GeoSearch holds details about calls to the GeoSearch method.
		GeoSearch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Q is the q argument value.
			Q *redis.GeoSearchQuery
		}
		// GeoSearchLocation holds details about calls to the GeoSearchLocation method.
		GeoSearchLocation []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Q is the q argument value.
			Q *redis.GeoSearchLocationQuery
		}
		// GeoSearchStore holds details about calls to the GeoSearchStore method.
		GeoSearchStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Store is the store argument value.
			Store string
			// Q is the q argument value.
			Q *redis.GeoSearchStoreQuery
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// GetBit holds details about calls to the GetBit method.
		GetBit []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Offset is the offset argument value.
			Offset int64
		}
		// GetDel holds details about calls to the GetDel method.
		GetDel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// GetEx holds details about calls to the GetEx method.
		GetEx []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// GetRange holds details about calls to the GetRange method.
		GetRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// End is the end argument value.
			End int64
		}
		// GetSet holds details about calls to the GetSet method.
		GetSet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
		}
		// HDel holds details about calls to the HDel method.
		HDel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Fields is the fields argument value.
			Fields []string
		}
		// HExists holds details about calls to the HExists method.
		HExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Field is the field argument value.
			Field string
		}
		// HExpire holds details about calls to the HExpire method.
		HExpire []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
			// Fields is the fields argument value.
			Fields []string
		}
		// HExpireAt holds details about calls to the HExpireAt method.
		HExpireAt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Tm is the tm argument value.
			Tm time.Time
			// Fields is the fields argument value.
			Fields []string
		}
		// HExpireAtWithArgs holds details about calls to the HExpireAtWithArgs method.
		HExpireAtWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Tm is the tm argument value.
			Tm time.Time
			// ExpirationArgs is the expirationArgs argument value.
			ExpirationArgs redis.HExpireArgs
			// Fields is the fields argument value.
			Fields []string
		}
		// HExpireTime holds details about calls to the HExpireTime method.
		HExpireTime []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Fields is the fields argument value.
			Fields []string
		}
		// HExpireWithArgs holds details about calls to the HExpireWithArgs method.
		HExpireWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
			// ExpirationArgs is the expirationArgs argument value.
			ExpirationArgs redis.HExpireArgs
			// Fields is the fields argument value.
			Fields []string
		}
		// HGet holds details about calls to the HGet method.
		HGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Field is the field argument value.
			Field string
		}
		// HGetAll holds details about calls to the HGetAll method.
		HGetAll []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// HGetDel holds details about calls to the HGetDel method.
		HGetDel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Fields is the fields argument value.
			Fields []string
		}
		// HGetEX holds details about calls to the HGetEX method.
		HGetEX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Fields is the fields argument value.
			Fields []string
		}
		// HGetEXWithArgs holds details about calls to the HGetEXWithArgs method.
		HGetEXWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.HGetEXOptions
			// Fields is the fields argument value.
			Fields []string
		}
		// HIncrBy holds details about calls to the HIncrBy method.
		HIncrBy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Field is the field argument value.
			Field string
			// Incr is the incr argument value.
			Incr int64
		}
		// HIncrByFloat holds details about calls to the HIncrByFloat method.
		HIncrByFloat []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Field is the field argument value.
			Field string
			// Incr is the incr argument value.
			Incr float64
		}
		// HKeys holds details about calls to the HKeys method.
		HKeys []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// HLen holds details about calls to the HLen method.
		HLen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// HMGet holds details about calls to the HMGet method.
		HMGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Fields is the fields argument value.
			Fields []string
		}
		// HMSet holds details about calls to the HMSet method.
		HMSet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Values is the values argument value.
			Values []interface{}
		}
		// HPExpire holds details about calls to the HPExpire method.
		HPExpire []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
			// Fields is the fields argument value.
			Fields []string
		}
		// HPExpireAt holds details about calls to the HPExpireAt method.
		HPExpireAt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Tm is the tm argument value.
			Tm time.Time
			// Fields is the fields argument value.
			Fields []string
		}
		// HPExpireAtWithArgs holds details about calls to the HPExpireAtWithArgs method.
		HPExpireAtWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Tm is the tm argument value.
			Tm time.Time
			// ExpirationArgs is the expirationArgs argument value.
			ExpirationArgs redis.HExpireArgs
			// Fields is the fields argument value.
			Fields []string
		}
		// HPExpireTime holds details about calls to the HPExpireTime method.
		HPExpireTime []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Fields is the fields argument value.
			Fields []string
		}
		// HPExpireWithArgs holds details about calls to the HPExpireWithArgs method.
		HPExpireWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
			// ExpirationArgs is the expirationArgs argument value.
			ExpirationArgs redis.HExpireArgs
			// Fields is the fields argument value.
			Fields []string
		}
		// HPTTL holds details about calls to the HPTTL method.
		HPTTL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Fields is the fields argument value.
			Fields []string
		}
		// HPersist holds details about calls to the HPersist method.
		HPersist []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Fields is the fields argument value.
			Fields []string
		}
		// HRandField holds details about calls to the HRandField method.
		HRandField []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int
		}
		// HRandFieldWithValues holds details about calls to the HRandFieldWithValues method.
		HRandFieldWithValues []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int
		}
		// HScan holds details about calls to the HScan method.
		HScan []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Cursor is the cursor argument value.
			Cursor uint64
			// Match is the match argument value.
			Match string
			// Count is the count argument value.
			Count int64
		}
		// HScanNoValues holds details about calls to the HScanNoValues method.
		HScanNoValues []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Cursor is the cursor argument value.
			Cursor uint64
			// Match is the match argument value.
			Match string
			// Count is the count argument value.
			Count int64
		}
		// HSet holds details about calls to the HSet method.
		HSet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Values is the values argument value.
			Values []interface{}
		}
		// HSetEX holds details about calls to the HSetEX method.
		HSetEX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// FieldsAndValues is the fieldsAndValues argument value.
			FieldsAndValues []string
		}
		// HSetEXWithArgs holds details about calls to the HSetEXWithArgs method.
		HSetEXWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.HSetEXOptions
			// FieldsAndValues is the fieldsAndValues argument value.
			FieldsAndValues []string
		}
		// HSetNX holds details about calls to the HSetNX method.
		HSetNX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Field is the field argument value.
			Field string
			// Value is the value argument value.
			Value interface{}
		}
		// HStrLen holds details about calls to the HStrLen method.
		HStrLen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Field is the field argument value.
			Field string
		}
		// HTTL holds details about calls to the HTTL method.
		HTTL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Fields is the fields argument value.
			Fields []string
		}
		// HVals holds details about calls to the HVals method.
		HVals []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Incr holds details about calls to the Incr method.
		Incr []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// IncrBy holds details about calls to the IncrBy method.
		IncrBy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value int64
		}
		// IncrByFloat holds details about calls to the IncrByFloat method.
		IncrByFloat []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value float64
		}
		// Info holds details about calls to the Info method.
		Info []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Section is the section argument value.
			Section []string
		}
		// JSONArrAppend holds details about calls to the JSONArrAppend method.
		JSONArrAppend []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
			// Values is the values argument value.
			Values []interface{}
		}
		// JSONArrIndex holds details about calls to the JSONArrIndex method.
		JSONArrIndex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
			// Value is the value argument value.
			Value []interface{}
		}
		// JSONArrIndexWithArgs holds details about calls to the JSONArrIndexWithArgs method.
		JSONArrIndexWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
			// Options is the options argument value.
			Options *redis.JSONArrIndexArgs
			// Value is the value argument value.
			Value []interface{}
		}
		// JSONArrInsert holds details about calls to the JSONArrInsert method.
		JSONArrInsert []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
			// Index is the index argument value.
			Index int64
			// Values is the values argument value.
			Values []interface{}
		}
		// JSONArrLen holds details about calls to the JSONArrLen method.
		JSONArrLen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
		}
		// JSONArrPop holds details about calls to the JSONArrPop method.
		JSONArrPop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
			// Index is the index argument value.
			Index int
		}
		// JSONArrTrim holds details about calls to the JSONArrTrim method.
		JSONArrTrim []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
		}
		// JSONArrTrimWithArgs holds details about calls to the JSONArrTrimWithArgs method.
		JSONArrTrimWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
			// Options is the options argument value.
			Options *redis.JSONArrTrimArgs
		}
		// JSONClear holds details about calls to the JSONClear method.
		JSONClear []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
		}
		// JSONDebugMemory holds details about calls to the JSONDebugMemory method.
		JSONDebugMemory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
		}
		// JSONDel holds details about calls to the JSONDel method.
		JSONDel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
		}
		// JSONForget holds details about calls to the JSONForget method.
		JSONForget []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
		}
		// JSONGet holds details about calls to the JSONGet method.
		JSONGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Paths is the paths argument value.
			Paths []string
		}
		// JSONGetWithArgs holds details about calls to the JSONGetWithArgs method.
		JSONGetWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.JSONGetArgs
			// Paths is the paths argument value.
			Paths []string
		}
		// JSONMGet holds details about calls to the JSONMGet method.
		JSONMGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Path is the path argument value.
			Path string
			// Keys is the keys argument value.
			Keys []string
		}
		// JSONMSet holds details about calls to the JSONMSet method.
		JSONMSet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Params is the params argument value.
			Params []interface{}
		}
		// JSONMSetArgs holds details about calls to the JSONMSetArgs method.
		JSONMSetArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Docs is the docs argument value.
			Docs []redis.JSONSetArgs
		}
		// JSONMerge holds details about calls to the JSONMerge method.
		JSONMerge []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
			// Value is the value argument value.
			Value string
		}
		// JSONNumIncrBy holds details about calls to the JSONNumIncrBy method.
		JSONNumIncrBy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
			// Value is the value argument value.
			Value float64
		}
		// JSONObjKeys holds details about calls to the JSONObjKeys method.
		JSONObjKeys []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
		}
		// JSONObjLen holds details about calls to the JSONObjLen method.
		JSONObjLen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
		}
		// JSONSet holds details about calls to the JSONSet method.
		JSONSet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
			// Value is the value argument value.
			Value interface{}
		}
		// JSONSetMode holds details about calls to the JSONSetMode method.
		JSONSetMode []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
			// Value is the value argument value.
			Value interface{}
			// Mode is the mode argument value.
			Mode string
		}
		// JSONStrAppend holds details about calls to the JSONStrAppend method.
		JSONStrAppend []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
			// Value is the value argument value.
			Value string
		}
		// JSONStrLen holds details about calls to the JSONStrLen method.
		JSONStrLen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
		}
		// JSONToggle holds details about calls to the JSONToggle method.
		JSONToggle []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
		}
		// JSONType holds details about calls to the JSONType method.
		JSONType []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Path is the path argument value.
			Path string
		}
		// Keys holds details about calls to the Keys method.
		Keys []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Pattern is the pattern argument value.
			Pattern string
		}
		// LCS holds details about calls to the LCS method.
		LCS []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Q is the q argument value.
			Q *redis.LCSQuery
		}
		// LIndex holds details about calls to the LIndex method.
		LIndex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Index is the index argument value.
			Index int64
		}
		// LInsert holds details about calls to the LInsert method.
		LInsert []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Op is the op argument value.
			Op string
			// Pivot is the pivot argument value.
			Pivot interface{}
			// Value is the value argument value.
			Value interface{}
		}
		// LInsertAfter holds details about calls to the LInsertAfter method.
		LInsertAfter []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Pivot is the pivot argument value.
			Pivot interface{}
			// Value is the value argument value.
			Value interface{}
		}
		// LInsertBefore holds details about calls to the LInsertBefore method.
		LInsertBefore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Pivot is the pivot argument value.
			Pivot interface{}
			// Value is the value argument value.
			Value interface{}
		}
		// LLen holds details about calls to the LLen method.
		LLen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// LMPop holds details about calls to the LMPop method.
		LMPop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Direction is the direction argument value.
			Direction string
			// Count is the count argument value.
			Count int64
			// Keys is the keys argument value.
			Keys []string
		}
		// LMove holds details about calls to the LMove method.
		LMove []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Source is the source argument value.
			Source string
			// Destination is the destination argument value.
			Destination string
			// Srcpos is the srcpos argument value.
			Srcpos string
			// Destpos is the destpos argument value.
			Destpos string
		}
		// LPop holds details about calls to the LPop method.
		LPop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// LPopCount holds details about calls to the LPopCount method.
		LPopCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int
		}
		// LPos holds details about calls to the LPos method.
		LPos []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value string
			// Args is the args argument value.
			Args redis.LPosArgs
		}
		// LPosCount holds details about calls to the LPosCount method.
		LPosCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value string
			// Count is the count argument value.
			Count int64
			// Args is the args argument value.
			Args redis.LPosArgs
		}
		// LPush holds details about calls to the LPush method.
		LPush []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Values is the values argument value.
			Values []interface{}
		}
		// LPushX holds details about calls to the LPushX method.
		LPushX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Values is the values argument value.
			Values []interface{}
		}
		// LRange holds details about calls to the LRange method.
		LRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// Stop is the stop argument value.
			Stop int64
		}
		// LRem holds details about calls to the LRem method.
		LRem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int64
			// Value is the value argument value.
			Value interface{}
		}
		// LSet holds details about calls to the LSet method.
		LSet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Index is the index argument value.
			Index int64
			// Value is the value argument value.
			Value interface{}
		}
		// LTrim holds details about calls to the LTrim method.
		LTrim []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// Stop is the stop argument value.
			Stop int64
		}
		// LastSave holds details about calls to the LastSave method.
		LastSave []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// MGet holds details about calls to the MGet method.
		MGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// MSet holds details about calls to the MSet method.
		MSet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Values is the values argument value.
			Values []interface{}
		}
		// MSetNX holds details about calls to the MSetNX method.
		MSetNX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Values is the values argument value.
			Values []interface{}
		}
		// MemoryUsage holds details about calls to the MemoryUsage method.
		MemoryUsage []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Samples is the samples argument value.
			Samples []int
		}
		// Migrate holds details about calls to the Migrate method.
		Migrate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Host is the host argument value.
			Host string
			// Port is the port argument value.
			Port string
			// Key is the key argument value.
			Key string
			// Db is the db argument value.
			Db int
			// Timeout is the timeout argument value.
			Timeout time.Duration
		}
		// ModuleLoadex holds details about calls to the ModuleLoadex method.
		ModuleLoadex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Conf is the conf argument value.
			Conf *redis.ModuleLoadexConfig
		}
		// Move holds details about calls to the Move method.
		Move []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Db is the db argument value.
			Db int
		}
		// ObjectEncoding holds details about calls to the ObjectEncoding method.
		ObjectEncoding []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// ObjectFreq holds details about calls to the ObjectFreq method.
		ObjectFreq []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// ObjectIdleTime holds details about calls to the ObjectIdleTime method.
		ObjectIdleTime []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// ObjectRefCount holds details about calls to the ObjectRefCount method.
		ObjectRefCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// PExpire holds details about calls to the PExpire method.
		PExpire []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// PExpireAt holds details about calls to the PExpireAt method.
		PExpireAt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Tm is the tm argument value.
			Tm time.Time
		}
		// PExpireTime holds details about calls to the PExpireTime method.
		PExpireTime []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// PFAdd holds details about calls to the PFAdd method.
		PFAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Els is the els argument value.
			Els []interface{}
		}
		// PFCount holds details about calls to the PFCount method.
		PFCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// PFMerge holds details about calls to the PFMerge method.
		PFMerge []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dest is the dest argument value.
			Dest string
			// Keys is the keys argument value.
			Keys []string
		}
		// PSubscribe holds details about calls to the PSubscribe method.
		PSubscribe []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Channels is the channels argument value.
			Channels []string
		}
		// PTTL holds details about calls to the PTTL method.
		PTTL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Persist holds details about calls to the Persist method.
		Persist []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Ping holds details about calls to the Ping method.
		Ping []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Pipeline holds details about calls to the Pipeline method.
		Pipeline []struct {
		}
		// Pipelined holds details about calls to the Pipelined method.
		Pipelined []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Fn is the fn argument value.
			Fn func(redis.Pipeliner) error
		}
		// PoolStats holds details about calls to the PoolStats method.
		PoolStats []struct {
		}
		// Process holds details about calls to the Process method.
		Process []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Cmd is the cmd argument value.
			Cmd redis.Cmder
		}
		// PubSubChannels holds details about calls to the PubSubChannels method.
		PubSubChannels []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Pattern is the pattern argument value.
			Pattern string
		}
		// PubSubNumPat holds details about calls to the PubSubNumPat method.
		PubSubNumPat []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// PubSubNumSub holds details about calls to the PubSubNumSub method.
		PubSubNumSub []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Channels is the channels argument value.
			Channels []string
		}
		// PubSubShardChannels holds details about calls to the PubSubShardChannels method.
		PubSubShardChannels []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Pattern is the pattern argument value.
			Pattern string
		}
		// PubSubShardNumSub holds details about calls to the PubSubShardNumSub method.
		PubSubShardNumSub []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Channels is the channels argument value.
			Channels []string
		}
		// Publish holds details about calls to the Publish method.
		Publish []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Channel is the channel argument value.
			Channel string
			// Message is the message argument value.
			Message interface{}
		}
		// Quit holds details about calls to the Quit method.
		Quit []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// RPop holds details about calls to the RPop method.
		RPop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// RPopCount holds details about calls to the RPopCount method.
		RPopCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int
		}
		// RPopLPush holds details about calls to the RPopLPush method.
		RPopLPush []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Source is the source argument value.
			Source string
			// Destination is the destination argument value.
			Destination string
		}
		// RPush holds details about calls to the RPush method.
		RPush []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Values is the values argument value.
			Values []interface{}
		}
		// RPushX holds details about calls to the RPushX method.
		RPushX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Values is the values argument value.
			Values []interface{}
		}
		// RandomKey holds details about calls to the RandomKey method.
		RandomKey []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ReadOnly holds details about calls to the ReadOnly method.
		ReadOnly []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ReadWrite holds details about calls to the ReadWrite method.
		ReadWrite []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Rename holds details about calls to the Rename method.
		Rename []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Newkey is the newkey argument value.
			Newkey string
		}
		// RenameNX holds details about calls to the RenameNX method.
		RenameNX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Newkey is the newkey argument value.
			Newkey string
		}
		// Restore holds details about calls to the Restore method.
		Restore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// TTL is the ttl argument value.
			TTL time.Duration
			// Value is the value argument value.
			Value string
		}
		// RestoreReplace holds details about calls to the RestoreReplace method.
		RestoreReplace []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// TTL is the ttl argument value.
			TTL time.Duration
			// Value is the value argument value.
			Value string
		}
		// SAdd holds details about calls to the SAdd method.
		SAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []interface{}
		}
		// SCard holds details about calls to the SCard method.
		SCard []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// SDiff holds details about calls to the SDiff method.
		SDiff []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// SDiffStore holds details about calls to the SDiffStore method.
		SDiffStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Destination is the destination argument value.
			Destination string
			// Keys is the keys argument value.
			Keys []string
		}
		// SInter holds details about calls to the SInter method.
		SInter []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// SInterCard holds details about calls to the SInterCard method.
		SInterCard []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Limit is the limit argument value.
			Limit int64
			// Keys is the keys argument value.
			Keys []string
		}
		// SInterStore holds details about calls to the SInterStore method.
		SInterStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Destination is the destination argument value.
			Destination string
			// Keys is the keys argument value.
			Keys []string
		}
		// SIsMember holds details about calls to the SIsMember method.
		SIsMember []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member interface{}
		}
		// SMIsMember holds details about calls to the SMIsMember method.
		SMIsMember []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []interface{}
		}
		// SMembers holds details about calls to the SMembers method.
		SMembers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// SMembersMap holds details about calls to the SMembersMap method.
		SMembersMap []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// SMove holds details about calls to the SMove method.
		SMove []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Source is the source argument value.
			Source string
			// Destination is the destination argument value.
			Destination string
			// Member is the member argument value.
			Member interface{}
		}
		// SPop holds details about calls to the SPop method.
		SPop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// SPopN holds details about calls to the SPopN method.
		SPopN []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int64
		}
		// SPublish holds details about calls to the SPublish method.
		SPublish []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Channel is the channel argument value.
			Channel string
			// Message is the message argument value.
			Message interface{}
		}
		// SRandMember holds details about calls to the SRandMember method.
		SRandMember []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// SRandMemberN holds details about calls to the SRandMemberN method.
		SRandMemberN []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int64
		}
		// SRem holds details about calls to the SRem method.
		SRem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []interface{}
		}
		// SScan holds details about calls to the SScan method.
		SScan []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Cursor is the cursor argument value.
			Cursor uint64
			// Match is the match argument value.
			Match string
			// Count is the count argument value.
			Count int64
		}
		// SSubscribe holds details about calls to the SSubscribe method.
		SSubscribe []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Channels is the channels argument value.
			Channels []string
		}
		// SUnion holds details about calls to the SUnion method.
		SUnion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// SUnionStore holds details about calls to the SUnionStore method.
		SUnionStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Destination is the destination argument value.
			Destination string
			// Keys is the keys argument value.
			Keys []string
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Scan holds details about calls to the Scan method.
		Scan []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Cursor is the cursor argument value.
			Cursor uint64
			// Match is the match argument value.
			Match string
			// Count is the count argument value.
			Count int64
		}
		// ScanType holds details about calls to the ScanType method.
		ScanType []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Cursor is the cursor argument value.
			Cursor uint64
			// Match is the match argument value.
			Match string
			// Count is the count argument value.
			Count int64
			// KeyType is the keyType argument value.
			KeyType string
		}
		// ScriptExists holds details about calls to the ScriptExists method.
		ScriptExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Hashes is the hashes argument value.
			Hashes []string
		}
		// ScriptFlush holds details about calls to the ScriptFlush method.
		ScriptFlush []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ScriptKill holds details about calls to the ScriptKill method.
		ScriptKill []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ScriptLoad holds details about calls to the ScriptLoad method.
		ScriptLoad []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Script is the script argument value.
			Script string
		}
		// Set holds details about calls to the Set method.
		Set []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// SetArgs holds details about calls to the SetArgs method.
		SetArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
			// A is the a argument value.
			A redis.SetArgs
		}
		// SetBit holds details about calls to the SetBit method.
		SetBit []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Offset is the offset argument value.
			Offset int64
			// Value is the value argument value.
			Value int
		}
		// SetEx holds details about calls to the SetEx method.
		SetEx []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// SetNX holds details about calls to the SetNX method.
		SetNX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// SetRange holds details about calls to the SetRange method.
		SetRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Offset is the offset argument value.
			Offset int64
			// Value is the value argument value.
			Value string
		}
		// SetXX holds details about calls to the SetXX method.
		SetXX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Value is the value argument value.
			Value interface{}
			// Expiration is the expiration argument value.
			Expiration time.Duration
		}
		// Shutdown holds details about calls to the Shutdown method.
		Shutdown []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ShutdownNoSave holds details about calls to the ShutdownNoSave method.
		ShutdownNoSave []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ShutdownSave holds details about calls to the ShutdownSave method.
		ShutdownSave []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// SlaveOf holds details about calls to the SlaveOf method.
		SlaveOf []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Host is the host argument value.
			Host string
			// Port is the port argument value.
			Port string
		}
		// SlowLogGet holds details about calls to the SlowLogGet method.
		SlowLogGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Num is the num argument value.
			Num int64
		}
		// Sort holds details about calls to the Sort method.
		Sort []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Sort is the sort argument value.
			Sort *redis.Sort
		}
		// SortInterfaces holds details about calls to the SortInterfaces method.
		SortInterfaces []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Sort is the sort argument value.
			Sort *redis.Sort
		}
		// SortRO holds details about calls to the SortRO method.
		SortRO []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Sort is the sort argument value.
			Sort *redis.Sort
		}
		// SortStore holds details about calls to the SortStore method.
		SortStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Store is the store argument value.
			Store string
			// Sort is the sort argument value.
			Sort *redis.Sort
		}
		// StrLen holds details about calls to the StrLen method.
		StrLen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Subscribe holds details about calls to the Subscribe method.
		Subscribe []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Channels is the channels argument value.
			Channels []string
		}
		// TDigestAdd holds details about calls to the TDigestAdd method.
		TDigestAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []float64
		}
		// TDigestByRank holds details about calls to the TDigestByRank method.
		TDigestByRank []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Rank is the rank argument value.
			Rank []uint64
		}
		// TDigestByRevRank holds details about calls to the TDigestByRevRank method.
		TDigestByRevRank []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Rank is the rank argument value.
			Rank []uint64
		}
		// TDigestCDF holds details about calls to the TDigestCDF method.
		TDigestCDF []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []float64
		}
		// TDigestCreate holds details about calls to the TDigestCreate method.
		TDigestCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// TDigestCreateWithCompression holds details about calls to the TDigestCreateWithCompression method.
		TDigestCreateWithCompression []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Compression is the compression argument value.
			Compression int64
		}
		// TDigestInfo holds details about calls to the TDigestInfo method.
		TDigestInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// TDigestMax holds details about calls to the TDigestMax method.
		TDigestMax []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// TDigestMerge holds details about calls to the TDigestMerge method.
		TDigestMerge []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DestKey is the destKey argument value.
			DestKey string
			// Options is the options argument value.
			Options *redis.TDigestMergeOptions
			// SourceKeys is the sourceKeys argument value.
			SourceKeys []string
		}
		// TDigestMin holds details about calls to the TDigestMin method.
		TDigestMin []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// TDigestQuantile holds details about calls to the TDigestQuantile method.
		TDigestQuantile []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []float64
		}
		// TDigestRank holds details about calls to the TDigestRank method.
		TDigestRank []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Values is the values argument value.
			Values []float64
		}
		// TDigestReset holds details about calls to the TDigestReset method.
		TDigestReset []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// TDigestRevRank holds details about calls to the TDigestRevRank method.
		TDigestRevRank []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Values is the values argument value.
			Values []float64
		}
		// TDigestTrimmedMean holds details about calls to the TDigestTrimmedMean method.
		TDigestTrimmedMean []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// LowCutQuantile is the lowCutQuantile argument value.
			LowCutQuantile float64
			// HighCutQuantile is the highCutQuantile argument value.
			HighCutQuantile float64
		}
		// TSAdd holds details about calls to the TSAdd method.
		TSAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Timestamp is the timestamp argument value.
			Timestamp interface{}
			// Value is the value argument value.
			Value float64
		}
		// TSAddWithArgs holds details about calls to the TSAddWithArgs method.
		TSAddWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Timestamp is the timestamp argument value.
			Timestamp interface{}
			// Value is the value argument value.
			Value float64
			// Options is the options argument value.
			Options *redis.TSOptions
		}
		// TSAlter holds details about calls to the TSAlter method.
		TSAlter []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.TSAlterOptions
		}
		// TSCreate holds details about calls to the TSCreate method.
		TSCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// TSCreateRule holds details about calls to the TSCreateRule method.
		TSCreateRule []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SourceKey is the sourceKey argument value.
			SourceKey string
			// DestKey is the destKey argument value.
			DestKey string
			// Aggregator is the aggregator argument value.
			Aggregator redis.Aggregator
			// BucketDuration is the bucketDuration argument value.
			BucketDuration int
		}
		// TSCreateRuleWithArgs holds details about calls to the TSCreateRuleWithArgs method.
		TSCreateRuleWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SourceKey is the sourceKey argument value.
			SourceKey string
			// DestKey is the destKey argument value.
			DestKey string
			// Aggregator is the aggregator argument value.
			Aggregator redis.Aggregator
			// BucketDuration is the bucketDuration argument value.
			BucketDuration int
			// Options is the options argument value.
			Options *redis.TSCreateRuleOptions
		}
		// TSCreateWithArgs holds details about calls to the TSCreateWithArgs method.
		TSCreateWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.TSOptions
		}
		// TSDecrBy holds details about calls to the TSDecrBy method.
		TSDecrBy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the Key argument value.
			Key string
			// Timestamp is the timestamp argument value.
			Timestamp float64
		}
		// TSDecrByWithArgs holds details about calls to the TSDecrByWithArgs method.
		TSDecrByWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Timestamp is the timestamp argument value.
			Timestamp float64
			// Options is the options argument value.
			Options *redis.TSIncrDecrOptions
		}
		// TSDel holds details about calls to the TSDel method.
		TSDel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the Key argument value.
			Key string
			// FromTimestamp is the fromTimestamp argument value.
			FromTimestamp int
			// ToTimestamp is the toTimestamp argument value.
			ToTimestamp int
		}
		// TSDeleteRule holds details about calls to the TSDeleteRule method.
		TSDeleteRule []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SourceKey is the sourceKey argument value.
			SourceKey string
			// DestKey is the destKey argument value.
			DestKey string
		}
		// TSGet holds details about calls to the TSGet method.
		TSGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// TSGetWithArgs holds details about calls to the TSGetWithArgs method.
		TSGetWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.TSGetOptions
		}
		// TSIncrBy holds details about calls to the TSIncrBy method.
		TSIncrBy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the Key argument value.
			Key string
			// Timestamp is the timestamp argument value.
			Timestamp float64
		}
		// TSIncrByWithArgs holds details about calls to the TSIncrByWithArgs method.
		TSIncrByWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Timestamp is the timestamp argument value.
			Timestamp float64
			// Options is the options argument value.
			Options *redis.TSIncrDecrOptions
		}
		// TSInfo holds details about calls to the TSInfo method.
		TSInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// TSInfoWithArgs holds details about calls to the TSInfoWithArgs method.
		TSInfoWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Options is the options argument value.
			Options *redis.TSInfoOptions
		}
		// TSMAdd holds details about calls to the TSMAdd method.
		TSMAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// KtvSlices is the ktvSlices argument value.
			KtvSlices [][]interface{}
		}
		// TSMGet holds details about calls to the TSMGet method.
		TSMGet []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Filters is the filters argument value.
			Filters []string
		}
		// TSMGetWithArgs holds details about calls to the TSMGetWithArgs method.
		TSMGetWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Filters is the filters argument value.
			Filters []string
			// Options is the options argument value.
			Options *redis.TSMGetOptions
		}
		// TSMRange holds details about calls to the TSMRange method.
		TSMRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FromTimestamp is the fromTimestamp argument value.
			FromTimestamp int
			// ToTimestamp is the toTimestamp argument value.
			ToTimestamp int
			// FilterExpr is the filterExpr argument value.
			FilterExpr []string
		}
		// TSMRangeWithArgs holds details about calls to the TSMRangeWithArgs method.
		TSMRangeWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FromTimestamp is the fromTimestamp argument value.
			FromTimestamp int
			// ToTimestamp is the toTimestamp argument value.
			ToTimestamp int
			// FilterExpr is the filterExpr argument value.
			FilterExpr []string
			// Options is the options argument value.
			Options *redis.TSMRangeOptions
		}
		// TSMRevRange holds details about calls to the TSMRevRange method.
		TSMRevRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FromTimestamp is the fromTimestamp argument value.
			FromTimestamp int
			// ToTimestamp is the toTimestamp argument value.
			ToTimestamp int
			// FilterExpr is the filterExpr argument value.
			FilterExpr []string
		}
		// TSMRevRangeWithArgs holds details about calls to the TSMRevRangeWithArgs method.
		TSMRevRangeWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FromTimestamp is the fromTimestamp argument value.
			FromTimestamp int
			// ToTimestamp is the toTimestamp argument value.
			ToTimestamp int
			// FilterExpr is the filterExpr argument value.
			FilterExpr []string
			// Options is the options argument value.
			Options *redis.TSMRevRangeOptions
		}
		// TSQueryIndex holds details about calls to the TSQueryIndex method.
		TSQueryIndex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// FilterExpr is the filterExpr argument value.
			FilterExpr []string
		}
		// TSRange holds details about calls to the TSRange method.
		TSRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// FromTimestamp is the fromTimestamp argument value.
			FromTimestamp int
			// ToTimestamp is the toTimestamp argument value.
			ToTimestamp int
		}
		// TSRangeWithArgs holds details about calls to the TSRangeWithArgs method.
		TSRangeWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// FromTimestamp is the fromTimestamp argument value.
			FromTimestamp int
			// ToTimestamp is the toTimestamp argument value.
			ToTimestamp int
			// Options is the options argument value.
			Options *redis.TSRangeOptions
		}
		// TSRevRange holds details about calls to the TSRevRange method.
		TSRevRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// FromTimestamp is the fromTimestamp argument value.
			FromTimestamp int
			// ToTimestamp is the toTimestamp argument value.
			ToTimestamp int
		}
		// TSRevRangeWithArgs holds details about calls to the TSRevRangeWithArgs method.
		TSRevRangeWithArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// FromTimestamp is the fromTimestamp argument value.
			FromTimestamp int
			// ToTimestamp is the toTimestamp argument value.
			ToTimestamp int
			// Options is the options argument value.
			Options *redis.TSRevRangeOptions
		}
		// TTL holds details about calls to the TTL method.
		TTL []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Time holds details about calls to the Time method.
		Time []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// TopKAdd holds details about calls to the TopKAdd method.
		TopKAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// TopKCount holds details about calls to the TopKCount method.
		TopKCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// TopKIncrBy holds details about calls to the TopKIncrBy method.
		TopKIncrBy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// TopKInfo holds details about calls to the TopKInfo method.
		TopKInfo []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// TopKList holds details about calls to the TopKList method.
		TopKList []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// TopKListWithCount holds details about calls to the TopKListWithCount method.
		TopKListWithCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// TopKQuery holds details about calls to the TopKQuery method.
		TopKQuery []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Elements is the elements argument value.
			Elements []interface{}
		}
		// TopKReserve holds details about calls to the TopKReserve method.
		TopKReserve []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// K is the k argument value.
			K int64
		}
		// TopKReserveWithOptions holds details about calls to the TopKReserveWithOptions method.
		TopKReserveWithOptions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// K is the k argument value.
			K int64
			// Width is the width argument value.
			Width int64
			// Depth is the depth argument value.
			Depth int64
			// Decay is the decay argument value.
			Decay float64
		}
		// Touch holds details about calls to the Touch method.
		Touch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// TxPipeline holds details about calls to the TxPipeline method.
		TxPipeline []struct {
		}
		// TxPipelined holds details about calls to the TxPipelined method.
		TxPipelined []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Fn is the fn argument value.
			Fn func(redis.Pipeliner) error
		}
		// Type holds details about calls to the Type method.
		Type []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// Unlink holds details about calls to the Unlink method.
		Unlink []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// Watch holds details about calls to the Watch method.
		Watch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Fn is the fn argument value.
			Fn func(*redis.Tx) error
			// Keys is the keys argument value.
			Keys []string
		}
		// XAck holds details about calls to the XAck method.
		XAck []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
			// Ids is the ids argument value.
			Ids []string
		}
		// XAdd holds details about calls to the XAdd method.
		XAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// A is the a argument value.
			A *redis.XAddArgs
		}
		// XAutoClaim holds details about calls to the XAutoClaim method.
		XAutoClaim []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// A is the a argument value.
			A *redis.XAutoClaimArgs
		}
		// XAutoClaimJustID holds details about calls to the XAutoClaimJustID method.
		XAutoClaimJustID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// A is the a argument value.
			A *redis.XAutoClaimArgs
		}
		// XClaim holds details about calls to the XClaim method.
		XClaim []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// A is the a argument value.
			A *redis.XClaimArgs
		}
		// XClaimJustID holds details about calls to the XClaimJustID method.
		XClaimJustID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// A is the a argument value.
			A *redis.XClaimArgs
		}
		// XDel holds details about calls to the XDel method.
		XDel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Ids is the ids argument value.
			Ids []string
		}
		// XGroupCreate holds details about calls to the XGroupCreate method.
		XGroupCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
			// Start is the start argument value.
			Start string
		}
		// XGroupCreateConsumer holds details about calls to the XGroupCreateConsumer method.
		XGroupCreateConsumer []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
			// Consumer is the consumer argument value.
			Consumer string
		}
		// XGroupCreateMkStream holds details about calls to the XGroupCreateMkStream method.
		XGroupCreateMkStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
			// Start is the start argument value.
			Start string
		}
		// XGroupDelConsumer holds details about calls to the XGroupDelConsumer method.
		XGroupDelConsumer []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
			// Consumer is the consumer argument value.
			Consumer string
		}
		// XGroupDestroy holds details about calls to the XGroupDestroy method.
		XGroupDestroy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
		}
		// XGroupSetID holds details about calls to the XGroupSetID method.
		XGroupSetID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
			// Start is the start argument value.
			Start string
		}
		// XInfoConsumers holds details about calls to the XInfoConsumers method.
		XInfoConsumers []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Group is the group argument value.
			Group string
		}
		// XInfoGroups holds details about calls to the XInfoGroups method.
		XInfoGroups []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// XInfoStream holds details about calls to the XInfoStream method.
		XInfoStream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// XInfoStreamFull holds details about calls to the XInfoStreamFull method.
		XInfoStreamFull []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int
		}
		// XLen holds details about calls to the XLen method.
		XLen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
		}
		// XPending holds details about calls to the XPending method.
		XPending []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Group is the group argument value.
			Group string
		}
		// XPendingExt holds details about calls to the XPendingExt method.
		XPendingExt []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// A is the a argument value.
			A *redis.XPendingExtArgs
		}
		// XRange holds details about calls to the XRange method.
		XRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Start is the start argument value.
			Start string
			// Stop is the stop argument value.
			Stop string
		}
		// XRangeN holds details about calls to the XRangeN method.
		XRangeN []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Start is the start argument value.
			Start string
			// Stop is the stop argument value.
			Stop string
			// Count is the count argument value.
			Count int64
		}
		// XRead holds details about calls to the XRead method.
		XRead []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// A is the a argument value.
			A *redis.XReadArgs
		}
		// XReadGroup holds details about calls to the XReadGroup method.
		XReadGroup []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// A is the a argument value.
			A *redis.XReadGroupArgs
		}
		// XReadStreams holds details about calls to the XReadStreams method.
		XReadStreams []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Streams is the streams argument value.
			Streams []string
		}
		// XRevRange holds details about calls to the XRevRange method.
		XRevRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Start is the start argument value.
			Start string
			// Stop is the stop argument value.
			Stop string
		}
		// XRevRangeN holds details about calls to the XRevRangeN method.
		XRevRangeN []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Stream is the stream argument value.
			Stream string
			// Start is the start argument value.
			Start string
			// Stop is the stop argument value.
			Stop string
			// Count is the count argument value.
			Count int64
		}
		// XTrimMaxLen holds details about calls to the XTrimMaxLen method.
		XTrimMaxLen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// MaxLen is the maxLen argument value.
			MaxLen int64
		}
		// XTrimMaxLenApprox holds details about calls to the XTrimMaxLenApprox method.
		XTrimMaxLenApprox []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// MaxLen is the maxLen argument value.
			MaxLen int64
			// Limit is the limit argument value.
			Limit int64
		}
		// XTrimMinID holds details about calls to the XTrimMinID method.
		XTrimMinID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// MinID is the minID argument value.
			MinID string
		}
		// XTrimMinIDApprox holds details about calls to the XTrimMinIDApprox method.
		XTrimMinIDApprox []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// MinID is the minID argument value.
			MinID string
			// Limit is the limit argument value.
			Limit int64
		}
		// ZAdd holds details about calls to the ZAdd method.
		ZAdd []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []redis.Z
		}
		// ZAddArgs holds details about calls to the ZAddArgs method.
		ZAddArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Args is the args argument value.
			Args redis.ZAddArgs
		}
		// ZAddArgsIncr holds details about calls to the ZAddArgsIncr method.
		ZAddArgsIncr []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Args is the args argument value.
			Args redis.ZAddArgs
		}
		// ZAddGT holds details about calls to the ZAddGT method.
		ZAddGT []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []redis.Z
		}
		// ZAddLT holds details about calls to the ZAddLT method.
		ZAddLT []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []redis.Z
		}
		// ZAddNX holds details about calls to the ZAddNX method.
		ZAddNX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []redis.Z
		}
		// ZAddXX holds details about calls to the ZAddXX method.
		ZAddXX []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []redis.Z
		}
		// ZCard holds details about calls to the ZCard method.
		ZCard []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
		}
		// ZCount holds details about calls to the ZCount method.
		ZCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Min is the min argument value.
			Min string
			// Max is the max argument value.
			Max string
		}
		// ZDiff holds details about calls to the ZDiff method.
		ZDiff []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// ZDiffStore holds details about calls to the ZDiffStore method.
		ZDiffStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Destination is the destination argument value.
			Destination string
			// Keys is the keys argument value.
			Keys []string
		}
		// ZDiffWithScores holds details about calls to the ZDiffWithScores method.
		ZDiffWithScores []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Keys is the keys argument value.
			Keys []string
		}
		// ZIncrBy holds details about calls to the ZIncrBy method.
		ZIncrBy []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Increment is the increment argument value.
			Increment float64
			// Member is the member argument value.
			Member string
		}
		// ZInter holds details about calls to the ZInter method.
		ZInter []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Store is the store argument value.
			Store *redis.ZStore
		}
		// ZInterCard holds details about calls to the ZInterCard method.
		ZInterCard []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Limit is the limit argument value.
			Limit int64
			// Keys is the keys argument value.
			Keys []string
		}
		// ZInterStore holds details about calls to the ZInterStore method.
		ZInterStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Destination is the destination argument value.
			Destination string
			// Store is the store argument value.
			Store *redis.ZStore
		}
		// ZInterWithScores holds details about calls to the ZInterWithScores method.
		ZInterWithScores []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Store is the store argument value.
			Store *redis.ZStore
		}
		// ZLexCount holds details about calls to the ZLexCount method.
		ZLexCount []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Min is the min argument value.
			Min string
			// Max is the max argument value.
			Max string
		}
		// ZMPop holds details about calls to the ZMPop method.
		ZMPop []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Order is the order argument value.
			Order string
			// Count is the count argument value.
			Count int64
			// Keys is the keys argument value.
			Keys []string
		}
		// ZMScore holds details about calls to the ZMScore method.
		ZMScore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []string
		}
		// ZPopMax holds details about calls to the ZPopMax method.
		ZPopMax []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count []int64
		}
		// ZPopMin holds details about calls to the ZPopMin method.
		ZPopMin []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count []int64
		}
		// ZRandMember holds details about calls to the ZRandMember method.
		ZRandMember []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int
		}
		// ZRandMemberWithScores holds details about calls to the ZRandMemberWithScores method.
		ZRandMemberWithScores []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Count is the count argument value.
			Count int
		}
		// ZRange holds details about calls to the ZRange method.
		ZRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// Stop is the stop argument value.
			Stop int64
		}
		// ZRangeArgs holds details about calls to the ZRangeArgs method.
		ZRangeArgs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Z is the z argument value.
			Z redis.ZRangeArgs
		}
		// ZRangeArgsWithScores holds details about calls to the ZRangeArgsWithScores method.
		ZRangeArgsWithScores []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Z is the z argument value.
			Z redis.ZRangeArgs
		}
		// ZRangeByLex holds details about calls to the ZRangeByLex method.
		ZRangeByLex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Opt is the opt argument value.
			Opt *redis.ZRangeBy
		}
		// ZRangeByScore holds details about calls to the ZRangeByScore method.
		ZRangeByScore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Opt is the opt argument value.
			Opt *redis.ZRangeBy
		}
		// ZRangeByScoreWithScores holds details about calls to the ZRangeByScoreWithScores method.
		ZRangeByScoreWithScores []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Opt is the opt argument value.
			Opt *redis.ZRangeBy
		}
		// ZRangeStore holds details about calls to the ZRangeStore method.
		ZRangeStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dst is the dst argument value.
			Dst string
			// Z is the z argument value.
			Z redis.ZRangeArgs
		}
		// ZRangeWithScores holds details about calls to the ZRangeWithScores method.
		ZRangeWithScores []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// Stop is the stop argument value.
			Stop int64
		}
		// ZRank holds details about calls to the ZRank method.
		ZRank []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member string
		}
		// ZRankWithScore holds details about calls to the ZRankWithScore method.
		ZRankWithScore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member string
		}
		// ZRem holds details about calls to the ZRem method.
		ZRem []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Members is the members argument value.
			Members []interface{}
		}
		// ZRemRangeByLex holds details about calls to the ZRemRangeByLex method.
		ZRemRangeByLex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Min is the min argument value.
			Min string
			// Max is the max argument value.
			Max string
		}
		// ZRemRangeByRank holds details about calls to the ZRemRangeByRank method.
		ZRemRangeByRank []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// Stop is the stop argument value.
			Stop int64
		}
		// ZRemRangeByScore holds details about calls to the ZRemRangeByScore method.
		ZRemRangeByScore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Min is the min argument value.
			Min string
			// Max is the max argument value.
			Max string
		}
		// ZRevRange holds details about calls to the ZRevRange method.
		ZRevRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// Stop is the stop argument value.
			Stop int64
		}
		// ZRevRangeByLex holds details about calls to the ZRevRangeByLex method.
		ZRevRangeByLex []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Opt is the opt argument value.
			Opt *redis.ZRangeBy
		}
		// ZRevRangeByScore holds details about calls to the ZRevRangeByScore method.
		ZRevRangeByScore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Opt is the opt argument value.
			Opt *redis.ZRangeBy
		}
		// ZRevRangeByScoreWithScores holds details about calls to the ZRevRangeByScoreWithScores method.
		ZRevRangeByScoreWithScores []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Opt is the opt argument value.
			Opt *redis.ZRangeBy
		}
		// ZRevRangeWithScores holds details about calls to the ZRevRangeWithScores method.
		ZRevRangeWithScores []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Start is the start argument value.
			Start int64
			// Stop is the stop argument value.
			Stop int64
		}
		// ZRevRank holds details about calls to the ZRevRank method.
		ZRevRank []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member string
		}
		// ZRevRankWithScore holds details about calls to the ZRevRankWithScore method.
		ZRevRankWithScore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member string
		}
		// ZScan holds details about calls to the ZScan method.
		ZScan []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Cursor is the cursor argument value.
			Cursor uint64
			// Match is the match argument value.
			Match string
			// Count is the count argument value.
			Count int64
		}
		// ZScore holds details about calls to the ZScore method.
		ZScore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Key is the key argument value.
			Key string
			// Member is the member argument value.
			Member string
		}
		// ZUnion holds details about calls to the ZUnion method.
		ZUnion []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Store is the store argument value.
			Store redis.ZStore
		}
		// ZUnionStore holds details about calls to the ZUnionStore method.
		ZUnionStore []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dest is the dest argument value.
			Dest string
			// Store is the store argument value.
			Store *redis.ZStore
		}
		// ZUnionWithScores holds details about calls to the ZUnionWithScores method.
		ZUnionWithScores []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Store is the store argument value.
			Store redis.ZStore
		}
	}
	lockACLCat                       sync.RWMutex
	lockACLCatArgs                   sync.RWMutex
	lockACLDelUser                   sync.RWMutex
	lockACLDryRun                    sync.RWMutex
	lockACLList                      sync.RWMutex
	lockACLLog                       sync.RWMutex
	lockACLLogReset                  sync.RWMutex
	lockACLSetUser                   sync.RWMutex
	lockAddHook                      sync.RWMutex
	lockAppend                       sync.RWMutex
	lockBFAdd                        sync.RWMutex
	lockBFCard                       sync.RWMutex
	lockBFExists                     sync.RWMutex
	lockBFInfo                       sync.RWMutex
	lockBFInfoArg                    sync.RWMutex
	lockBFInfoCapacity               sync.RWMutex
	lockBFInfoExpansion              sync.RWMutex
	lockBFInfoFilters                sync.RWMutex
	lockBFInfoItems                  sync.RWMutex
	lockBFInfoSize                   sync.RWMutex
	lockBFInsert                     sync.RWMutex
	lockBFLoadChunk                  sync.RWMutex
	lockBFMAdd                       sync.RWMutex
	lockBFMExists                    sync.RWMutex
	lockBFReserve                    sync.RWMutex
	lockBFReserveExpansion           sync.RWMutex
	lockBFReserveNonScaling          sync.RWMutex
	lockBFReserveWithArgs            sync.RWMutex
	lockBFScanDump                   sync.RWMutex
	lockBLMPop                       sync.RWMutex
	lockBLMove                       sync.RWMutex
	lockBLPop                        sync.RWMutex
	lockBRPop                        sync.RWMutex
	lockBRPopLPush                   sync.RWMutex
	lockBZMPop                       sync.RWMutex
	lockBZPopMax                     sync.RWMutex
	lockBZPopMin                     sync.RWMutex
	lockBgRewriteAOF                 sync.RWMutex
	lockBgSave                       sync.RWMutex
	lockBitCount                     sync.RWMutex
	lockBitField                     sync.RWMutex
	lockBitFieldRO                   sync.RWMutex
	lockBitOpAnd                     sync.RWMutex
	lockBitOpNot                     sync.RWMutex
	lockBitOpOr                      sync.RWMutex
	lockBitOpXor                     sync.RWMutex
	lockBitPos                       sync.RWMutex
	lockBitPosSpan                   sync.RWMutex
	lockCFAdd                        sync.RWMutex
	lockCFAddNX                      sync.RWMutex
	lockCFCount                      sync.RWMutex
	lockCFDel                        sync.RWMutex
	lockCFExists                     sync.RWMutex
	lockCFInfo                       sync.RWMutex
	lockCFInsert                     sync.RWMutex
	lockCFInsertNX                   sync.RWMutex
	lockCFLoadChunk                  sync.RWMutex
	lockCFMExists                    sync.RWMutex
	lockCFReserve                    sync.RWMutex
	lockCFReserveBucketSize          sync.RWMutex
	lockCFReserveExpansion           sync.RWMutex
	lockCFReserveMaxIterations       sync.RWMutex
	lockCFReserveWithArgs            sync.RWMutex
	lockCFScanDump                   sync.RWMutex
	lockCMSIncrBy                    sync.RWMutex
	lockCMSInfo                      sync.RWMutex
	lockCMSInitByDim                 sync.RWMutex
	lockCMSInitByProb                sync.RWMutex
	lockCMSMerge                     sync.RWMutex
	lockCMSMergeWithWeight           sync.RWMutex
	lockCMSQuery                     sync.RWMutex
	lockClientGetName                sync.RWMutex
	lockClientID                     sync.RWMutex
	lockClientInfo                   sync.RWMutex
	lockClientKill                   sync.RWMutex
	lockClientKillByFilter           sync.RWMutex
	lockClientList                   sync.RWMutex
	lockClientPause                  sync.RWMutex
	lockClientUnblock                sync.RWMutex
	lockClientUnblockWithError       sync.RWMutex
	lockClientUnpause                sync.RWMutex
	lockClose                        sync.RWMutex
	lockClusterAddSlots              sync.RWMutex
	lockClusterAddSlotsRange         sync.RWMutex
	lockClusterCountFailureReports   sync.RWMutex
	lockClusterCountKeysInSlot       sync.RWMutex
	lockClusterDelSlots              sync.RWMutex
	lockClusterDelSlotsRange         sync.RWMutex
	lockClusterFailover              sync.RWMutex
	lockClusterForget                sync.RWMutex
	lockClusterGetKeysInSlot         sync.RWMutex
	lockClusterInfo                  sync.RWMutex
	lockClusterKeySlot               sync.RWMutex
	lockClusterLinks                 sync.RWMutex
	lockClusterMeet                  sync.RWMutex
	lockClusterMyID                  sync.RWMutex
	lockClusterMyShardID             sync.RWMutex
	lockClusterNodes                 sync.RWMutex
	lockClusterReplicate             sync.RWMutex
	lockClusterResetHard             sync.RWMutex
	lockClusterResetSoft             sync.RWMutex
	lockClusterSaveConfig            sync.RWMutex
	lockClusterShards                sync.RWMutex
	lockClusterSlaves                sync.RWMutex
	lockClusterSlots                 sync.RWMutex
	lockCommand                      sync.RWMutex
	lockCommandGetKeys               sync.RWMutex
	lockCommandGetKeysAndFlags       sync.RWMutex
	lockCommandList                  sync.RWMutex
	lockConfigGet                    sync.RWMutex
	lockConfigResetStat              sync.RWMutex
	lockConfigRewrite                sync.RWMutex
	lockConfigSet                    sync.RWMutex
	lockCopy                         sync.RWMutex
	lockDBSize                       sync.RWMutex
	lockDebugObject                  sync.RWMutex
	lockDecr                         sync.RWMutex
	lockDecrBy                       sync.RWMutex
	lockDel                          sync.RWMutex
	lockDo                           sync.RWMutex
	lockDump                         sync.RWMutex
	lockEcho                         sync.RWMutex
	lockEval                         sync.RWMutex
	lockEvalRO                       sync.RWMutex
	lockEvalSha                      sync.RWMutex
	lockEvalShaRO                    sync.RWMutex
	lockExists                       sync.RWMutex
	lockExpire                       sync.RWMutex
	lockExpireAt                     sync.RWMutex
	lockExpireGT                     sync.RWMutex
	lockExpireLT                     sync.RWMutex
	lockExpireNX                     sync.RWMutex
	lockExpireTime                   sync.RWMutex
	lockExpireXX                     sync.RWMutex
	lockFCall                        sync.RWMutex
	lockFCallRO                      sync.RWMutex
	lockFCallRo                      sync.RWMutex
	lockFTAggregate                  sync.RWMutex
	lockFTAggregateWithArgs          sync.RWMutex
	lockFTAliasAdd                   sync.RWMutex
	lockFTAliasDel                   sync.RWMutex
	lockFTAliasUpdate                sync.RWMutex
	lockFTAlter                      sync.RWMutex
	lockFTConfigGet                  sync.RWMutex
	lockFTConfigSet                  sync.RWMutex
	lockFTCreate                     sync.RWMutex
	lockFTCursorDel                  sync.RWMutex
	lockFTCursorRead                 sync.RWMutex
	lockFTDictAdd                    sync.RWMutex
	lockFTDictDel                    sync.RWMutex
	lockFTDictDump                   sync.RWMutex
	lockFTDropIndex                  sync.RWMutex
	lockFTDropIndexWithArgs          sync.RWMutex
	lockFTExplain                    sync.RWMutex
	lockFTExplainWithArgs            sync.RWMutex
	lockFTInfo                       sync.RWMutex
	lockFTSearch                     sync.RWMutex
	lockFTSearchWithArgs             sync.RWMutex
	lockFTSpellCheck                 sync.RWMutex
	lockFTSpellCheckWithArgs         sync.RWMutex
	lockFTSynDump                    sync.RWMutex
	lockFTSynUpdate                  sync.RWMutex
	lockFTSynUpdateWithArgs          sync.RWMutex
	lockFTTagVals                    sync.RWMutex
	lockFT_List                      sync.RWMutex
	lockFlushAll                     sync.RWMutex
	lockFlushAllAsync                sync.RWMutex
	lockFlushDB                      sync.RWMutex
	lockFlushDBAsync                 sync.RWMutex
	lockFunctionDelete               sync.RWMutex
	lockFunctionDump                 sync.RWMutex
	lockFunctionFlush                sync.RWMutex
	lockFunctionFlushAsync           sync.RWMutex
	lockFunctionKill                 sync.RWMutex
	lockFunctionList                 sync.RWMutex
	lockFunctionLoad                 sync.RWMutex
	lockFunctionLoadReplace          sync.RWMutex
	lockFunctionRestore              sync.RWMutex
	lockFunctionStats                sync.RWMutex
	lockGeoAdd                       sync.RWMutex
	lockGeoDist                      sync.RWMutex
	lockGeoHash                      sync.RWMutex
	lockGeoPos                       sync.RWMutex
	lockGeoRadius                    sync.RWMutex
	lockGeoRadiusByMember            sync.RWMutex
	lockGeoRadiusByMemberStore       sync.RWMutex
	lockGeoRadiusStore               sync.RWMutex
	lockGeoSearch                    sync.RWMutex
	lockGeoSearchLocation            sync.RWMutex
	lockGeoSearchStore               sync.RWMutex
	lockGet                          sync.RWMutex
	lockGetBit                       sync.RWMutex
	lockGetDel                       sync.RWMutex
	lockGetEx                        sync.RWMutex
	lockGetRange                     sync.RWMutex
	lockGetSet                       sync.RWMutex
	lockHDel                         sync.RWMutex
	lockHExists                      sync.RWMutex
	lockHExpire                      sync.RWMutex
	lockHExpireAt                    sync.RWMutex
	lockHExpireAtWithArgs            sync.RWMutex
	lockHExpireTime                  sync.RWMutex
	lockHExpireWithArgs              sync.RWMutex
	lockHGet                         sync.RWMutex
	lockHGetAll                      sync.RWMutex
	lockHGetDel                      sync.RWMutex
	lockHGetEX                       sync.RWMutex
	lockHGetEXWithArgs               sync.RWMutex
	lockHIncrBy                      sync.RWMutex
	lockHIncrByFloat                 sync.RWMutex
	lockHKeys                        sync.RWMutex
	lockHLen                         sync.RWMutex
	lockHMGet                        sync.RWMutex
	lockHMSet                        sync.RWMutex
	lockHPExpire                     sync.RWMutex
	lockHPExpireAt                   sync.RWMutex
	lockHPExpireAtWithArgs           sync.RWMutex
	lockHPExpireTime                 sync.RWMutex
	lockHPExpireWithArgs             sync.RWMutex
	lockHPTTL                        sync.RWMutex
	lockHPersist                     sync.RWMutex
	lockHRandField                   sync.RWMutex
	lockHRandFieldWithValues         sync.RWMutex
	lockHScan                        sync.RWMutex
	lockHScanNoValues                sync.RWMutex
	lockHSet                         sync.RWMutex
	lockHSetEX                       sync.RWMutex
	lockHSetEXWithArgs               sync.RWMutex
	lockHSetNX                       sync.RWMutex
	lockHStrLen                      sync.RWMutex
	lockHTTL                         sync.RWMutex
	lockHVals                        sync.RWMutex
	lockIncr                         sync.RWMutex
	lockIncrBy                       sync.RWMutex
	lockIncrByFloat                  sync.RWMutex
	lockInfo                         sync.RWMutex
	lockJSONArrAppend                sync.RWMutex
	lockJSONArrIndex                 sync.RWMutex
	lockJSONArrIndexWithArgs         sync.RWMutex
	lockJSONArrInsert                sync.RWMutex
	lockJSONArrLen                   sync.RWMutex
	lockJSONArrPop                   sync.RWMutex
	lockJSONArrTrim                  sync.RWMutex
	lockJSONArrTrimWithArgs          sync.RWMutex
	lockJSONClear                    sync.RWMutex
	lockJSONDebugMemory              sync.RWMutex
	lockJSONDel                      sync.RWMutex
	lockJSONForget                   sync.RWMutex
	lockJSONGet                      sync.RWMutex
	lockJSONGetWithArgs              sync.RWMutex
	lockJSONMGet                     sync.RWMutex
	lockJSONMSet                     sync.RWMutex
	lockJSONMSetArgs                 sync.RWMutex
	lockJSONMerge                    sync.RWMutex
	lockJSONNumIncrBy                sync.RWMutex
	lockJSONObjKeys                  sync.RWMutex
	lockJSONObjLen                   sync.RWMutex
	lockJSONSet                      sync.RWMutex
	lockJSONSetMode                  sync.RWMutex
	lockJSONStrAppend                sync.RWMutex
	lockJSONStrLen                   sync.RWMutex
	lockJSONToggle                   sync.RWMutex
	lockJSONType                     sync.RWMutex
	lockKeys                         sync.RWMutex
	lockLCS                          sync.RWMutex
	lockLIndex                       sync.RWMutex
	lockLInsert                      sync.RWMutex
	lockLInsertAfter                 sync.RWMutex
	lockLInsertBefore                sync.RWMutex
	lockLLen                         sync.RWMutex
	lockLMPop                        sync.RWMutex
	lockLMove                        sync.RWMutex
	lockLPop                         sync.RWMutex
	lockLPopCount                    sync.RWMutex
	lockLPos                         sync.RWMutex
	lockLPosCount                    sync.RWMutex
	lockLPush                        sync.RWMutex
	lockLPushX                       sync.RWMutex
	lockLRange                       sync.RWMutex
	lockLRem                         sync.RWMutex
	lockLSet                         sync.RWMutex
	lockLTrim                        sync.RWMutex
	lockLastSave                     sync.RWMutex
	lockMGet                         sync.RWMutex
	lockMSet                         sync.RWMutex
	lockMSetNX                       sync.RWMutex
	lockMemoryUsage                  sync.RWMutex
	lockMigrate                      sync.RWMutex
	lockModuleLoadex                 sync.RWMutex
	lockMove                         sync.RWMutex
	lockObjectEncoding               sync.RWMutex
	lockObjectFreq                   sync.RWMutex
	lockObjectIdleTime               sync.RWMutex
	lockObjectRefCount               sync.RWMutex
	lockPExpire                      sync.RWMutex
	lockPExpireAt                    sync.RWMutex
	lockPExpireTime                  sync.RWMutex
	lockPFAdd                        sync.RWMutex
	lockPFCount                      sync.RWMutex
	lockPFMerge                      sync.RWMutex
	lockPSubscribe                   sync.RWMutex
	lockPTTL                         sync.RWMutex
	lockPersist                      sync.RWMutex
	lockPing                         sync.RWMutex
	lockPipeline                     sync.RWMutex
	lockPipelined                    sync.RWMutex
	lockPoolStats                    sync.RWMutex
	lockProcess                      sync.RWMutex
	lockPubSubChannels               sync.RWMutex
	lockPubSubNumPat                 sync.RWMutex
	lockPubSubNumSub                 sync.RWMutex
	lockPubSubShardChannels          sync.RWMutex
	lockPubSubShardNumSub            sync.RWMutex
	lockPublish                      sync.RWMutex
	lockQuit                         sync.RWMutex
	lockRPop                         sync.RWMutex
	lockRPopCount                    sync.RWMutex
	lockRPopLPush                    sync.RWMutex
	lockRPush                        sync.RWMutex
	lockRPushX                       sync.RWMutex
	lockRandomKey                    sync.RWMutex
	lockReadOnly                     sync.RWMutex
	lockReadWrite                    sync.RWMutex
	lockRename                       sync.RWMutex
	lockRenameNX                     sync.RWMutex
	lockRestore                      sync.RWMutex
	lockRestoreReplace               sync.RWMutex
	lockSAdd                         sync.RWMutex
	lockSCard                        sync.RWMutex
	lockSDiff                        sync.RWMutex
	lockSDiffStore                   sync.RWMutex
	lockSInter                       sync.RWMutex
	lockSInterCard                   sync.RWMutex
	lockSInterStore                  sync.RWMutex
	lockSIsMember                    sync.RWMutex
	lockSMIsMember                   sync.RWMutex
	lockSMembers                     sync.RWMutex
	lockSMembersMap                  sync.RWMutex
	lockSMove                        sync.RWMutex
	lockSPop                         sync.RWMutex
	lockSPopN                        sync.RWMutex
	lockSPublish                     sync.RWMutex
	lockSRandMember                  sync.RWMutex
	lockSRandMemberN                 sync.RWMutex
	lockSRem                         sync.RWMutex
	lockSScan                        sync.RWMutex
	lockSSubscribe                   sync.RWMutex
	lockSUnion                       sync.RWMutex
	lockSUnionStore                  sync.RWMutex
	lockSave                         sync.RWMutex
	lockScan                         sync.RWMutex
	lockScanType                     sync.RWMutex
	lockScriptExists                 sync.RWMutex
	lockScriptFlush                  sync.RWMutex
	lockScriptKill                   sync.RWMutex
	lockScriptLoad                   sync.RWMutex
	lockSet                          sync.RWMutex
	lockSetArgs                      sync.RWMutex
	lockSetBit                       sync.RWMutex
	lockSetEx                        sync.RWMutex
	lockSetNX                        sync.RWMutex
	lockSetRange                     sync.RWMutex
	lockSetXX                        sync.RWMutex
	lockShutdown                     sync.RWMutex
	lockShutdownNoSave               sync.RWMutex
	lockShutdownSave                 sync.RWMutex
	lockSlaveOf                      sync.RWMutex
	lockSlowLogGet                   sync.RWMutex
	lockSort                         sync.RWMutex
	lockSortInterfaces               sync.RWMutex
	lockSortRO                       sync.RWMutex
	lockSortStore                    sync.RWMutex
	lockStrLen                       sync.RWMutex
	lockSubscribe                    sync.RWMutex
	lockTDigestAdd                   sync.RWMutex
	lockTDigestByRank                sync.RWMutex
	lockTDigestByRevRank             sync.RWMutex
	lockTDigestCDF                   sync.RWMutex
	lockTDigestCreate                sync.RWMutex
	lockTDigestCreateWithCompression sync.RWMutex
	lockTDigestInfo                  sync.RWMutex
	lockTDigestMax                   sync.RWMutex
	lockTDigestMerge                 sync.RWMutex
	lockTDigestMin                   sync.RWMutex
	lockTDigestQuantile              sync.RWMutex
	lockTDigestRank                  sync.RWMutex
	lockTDigestReset                 sync.RWMutex
	lockTDigestRevRank               sync.RWMutex
	lockTDigestTrimmedMean           sync.RWMutex
	lockTSAdd                        sync.RWMutex
	lockTSAddWithArgs                sync.RWMutex
	lockTSAlter                      sync.RWMutex
	lockTSCreate                     sync.RWMutex
	lockTSCreateRule                 sync.RWMutex
	lockTSCreateRuleWithArgs         sync.RWMutex
	lockTSCreateWithArgs             sync.RWMutex
	lockTSDecrBy                     sync.RWMutex
	lockTSDecrByWithArgs             sync.RWMutex
	lockTSDel                        sync.RWMutex
	lockTSDeleteRule                 sync.RWMutex
	lockTSGet                        sync.RWMutex
	lockTSGetWithArgs                sync.RWMutex
	lockTSIncrBy                     sync.RWMutex
	lockTSIncrByWithArgs             sync.RWMutex
	lockTSInfo                       sync.RWMutex
	lockTSInfoWithArgs               sync.RWMutex
	lockTSMAdd                       sync.RWMutex
	lockTSMGet                       sync.RWMutex
	lockTSMGetWithArgs               sync.RWMutex
	lockTSMRange                     sync.RWMutex
	lockTSMRangeWithArgs             sync.RWMutex
	lockTSMRevRange                  sync.RWMutex
	lockTSMRevRangeWithArgs          sync.RWMutex
	lockTSQueryIndex                 sync.RWMutex
	lockTSRange                      sync.RWMutex
	lockTSRangeWithArgs              sync.RWMutex
	lockTSRevRange                   sync.RWMutex
	lockTSRevRangeWithArgs           sync.RWMutex
	lockTTL                          sync.RWMutex
	lockTime                         sync.RWMutex
	lockTopKAdd                      sync.RWMutex
	lockTopKCount                    sync.RWMutex
	lockTopKIncrBy                   sync.RWMutex
	lockTopKInfo                     sync.RWMutex
	lockTopKList                     sync.RWMutex
	lockTopKListWithCount            sync.RWMutex
	lockTopKQuery                    sync.RWMutex
	lockTopKReserve                  sync.RWMutex
	lockTopKReserveWithOptions       sync.RWMutex
	lockTouch                        sync.RWMutex
	lockTxPipeline                   sync.RWMutex
	lockTxPipelined                  sync.RWMutex
	lockType                         sync.RWMutex
	lockUnlink                       sync.RWMutex
	lockWatch                        sync.RWMutex
	lockXAck                         sync.RWMutex
	lockXAdd                         sync.RWMutex
	lockXAutoClaim                   sync.RWMutex
	lockXAutoClaimJustID             sync.RWMutex
	lockXClaim                       sync.RWMutex
	lockXClaimJustID                 sync.RWMutex
	lockXDel                         sync.RWMutex
	lockXGroupCreate                 sync.RWMutex
	lockXGroupCreateConsumer         sync.RWMutex
	lockXGroupCreateMkStream         sync.RWMutex
	lockXGroupDelConsumer            sync.RWMutex
	lockXGroupDestroy                sync.RWMutex
	lockXGroupSetID                  sync.RWMutex
	lockXInfoConsumers               sync.RWMutex
	lockXInfoGroups                  sync.RWMutex
	lockXInfoStream                  sync.RWMutex
	lockXInfoStreamFull              sync.RWMutex
	lockXLen                         sync.RWMutex
	lockXPending                     sync.RWMutex
	lockXPendingExt                  sync.RWMutex
	lockXRange                       sync.RWMutex
	lockXRangeN                      sync.RWMutex
	lockXRead                        sync.RWMutex
	lockXReadGroup                   sync.RWMutex
	lockXReadStreams                 sync.RWMutex
	lockXRevRange                    sync.RWMutex
	lockXRevRangeN                   sync.RWMutex
	lockXTrimMaxLen                  sync.RWMutex
	lockXTrimMaxLenApprox            sync.RWMutex
	lockXTrimMinID                   sync.RWMutex
	lockXTrimMinIDApprox             sync.RWMutex
	lockZAdd                         sync.RWMutex
	lockZAddArgs                     sync.RWMutex
	lockZAddArgsIncr                 sync.RWMutex
	lockZAddGT                       sync.RWMutex
	lockZAddLT                       sync.RWMutex
	lockZAddNX                       sync.RWMutex
	lockZAddXX                       sync.RWMutex
	lockZCard                        sync.RWMutex
	lockZCount                       sync.RWMutex
	lockZDiff                        sync.RWMutex
	lockZDiffStore                   sync.RWMutex
	lockZDiffWithScores              sync.RWMutex
	lockZIncrBy                      sync.RWMutex
	lockZInter                       sync.RWMutex
	lockZInterCard                   sync.RWMutex
	lockZInterStore                  sync.RWMutex
	lockZInterWithScores             sync.RWMutex
	lockZLexCount                    sync.RWMutex
	lockZMPop                        sync.RWMutex
	lockZMScore                      sync.RWMutex
	lockZPopMax                      sync.RWMutex
	lockZPopMin                      sync.RWMutex
	lockZRandMember                  sync.RWMutex
	lockZRandMemberWithScores        sync.RWMutex
	lockZRange                       sync.RWMutex
	lockZRangeArgs                   sync.RWMutex
	lockZRangeArgsWithScores         sync.RWMutex
	lockZRangeByLex                  sync.RWMutex
	lockZRangeByScore                sync.RWMutex
	lockZRangeByScoreWithScores      sync.RWMutex
	lockZRangeStore                  sync.RWMutex
	lockZRangeWithScores             sync.RWMutex
	lockZRank                        sync.RWMutex
	lockZRankWithScore               sync.RWMutex
	lockZRem                         sync.RWMutex
	lockZRemRangeByLex               sync.RWMutex
	lockZRemRangeByRank              sync.RWMutex
	lockZRemRangeByScore             sync.RWMutex
	lockZRevRange                    sync.RWMutex
	lockZRevRangeByLex               sync.RWMutex
	lockZRevRangeByScore             sync.RWMutex
	lockZRevRangeByScoreWithScores   sync.RWMutex
	lockZRevRangeWithScores          sync.RWMutex
	lockZRevRank                     sync.RWMutex
	lockZRevRankWithScore            sync.RWMutex
	lockZScan                        sync.RWMutex
	lockZScore                       sync.RWMutex
	lockZUnion                       sync.RWMutex
	lockZUnionStore                  sync.RWMutex
	lockZUnionWithScores             sync.RWMutex
}

// ACLCat calls ACLCatFunc.
func (mock *GoRedisClientMock) ACLCat(ctx context.Context) *redis.StringSliceCmd {
	if mock.ACLCatFunc == nil {
		panic("GoRedisClientMock.ACLCatFunc: method is nil but GoRedisClient.ACLCat was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockACLCat.Lock()
	mock.calls.ACLCat = append(mock.calls.ACLCat, callInfo)
	mock.lockACLCat.Unlock()
	return mock.ACLCatFunc(ctx)
}

// ACLCatCalls gets all the calls that were made to ACLCat.
// Check the length with:
//
//	len(mockedGoRedisClient.ACLCatCalls())
func (mock *GoRedisClientMock) ACLCatCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockACLCat.RLock()
	calls = mock.calls.ACLCat
	mock.lockACLCat.RUnlock()
	return calls
}

// ACLCatArgs calls ACLCatArgsFunc.
func (mock *GoRedisClientMock) ACLCatArgs(ctx context.Context, options *redis.ACLCatArgs) *redis.StringSliceCmd {
	if mock.ACLCatArgsFunc == nil {
		panic("GoRedisClientMock.ACLCatArgsFunc: method is nil but GoRedisClient.ACLCatArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Options *redis.ACLCatArgs
	}{
		Ctx:     ctx,
		Options: options,
	}
	mock.lockACLCatArgs.Lock()
	mock.calls.ACLCatArgs = append(mock.calls.ACLCatArgs, callInfo)
	mock.lockACLCatArgs.Unlock()
	return mock.ACLCatArgsFunc(ctx, options)
}

// ACLCatArgsCalls gets all the calls that were made to ACLCatArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.ACLCatArgsCalls())
func (mock *GoRedisClientMock) ACLCatArgsCalls() []struct {
	Ctx     context.Context
	Options *redis.ACLCatArgs
} {
	var calls []struct {
		Ctx     context.Context
		Options *redis.ACLCatArgs
	}
	mock.lockACLCatArgs.RLock()
	calls = mock.calls.ACLCatArgs
	mock.lockACLCatArgs.RUnlock()
	return calls
}

// ACLDelUser calls ACLDelUserFunc.
func (mock *GoRedisClientMock) ACLDelUser(ctx context.Context, username string) *redis.IntCmd {
	if mock.ACLDelUserFunc == nil {
		panic("GoRedisClientMock.ACLDelUserFunc: method is nil but GoRedisClient.ACLDelUser was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Username string
	}{
		Ctx:      ctx,
		Username: username,
	}
	mock.lockACLDelUser.Lock()
	mock.calls.ACLDelUser = append(mock.calls.ACLDelUser, callInfo)
	mock.lockACLDelUser.Unlock()
	return mock.ACLDelUserFunc(ctx, username)
}

// ACLDelUserCalls gets all the calls that were made to ACLDelUser.
// Check the length with:
//
//	len(mockedGoRedisClient.ACLDelUserCalls())
func (mock *GoRedisClientMock) ACLDelUserCalls() []struct {
	Ctx      context.Context
	Username string
} {
	var calls []struct {
		Ctx      context.Context
		Username string
	}
	mock.lockACLDelUser.RLock()
	calls = mock.calls.ACLDelUser
	mock.lockACLDelUser.RUnlock()
	return calls
}

// ACLDryRun calls ACLDryRunFunc.
func (mock *GoRedisClientMock) ACLDryRun(ctx context.Context, username string, command ...interface{}) *redis.StringCmd {
	if mock.ACLDryRunFunc == nil {
		panic("GoRedisClientMock.ACLDryRunFunc: method is nil but GoRedisClient.ACLDryRun was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Username string
		Command  []interface{}
	}{
		Ctx:      ctx,
		Username: username,
		Command:  command,
	}
	mock.lockACLDryRun.Lock()
	mock.calls.ACLDryRun = append(mock.calls.ACLDryRun, callInfo)
	mock.lockACLDryRun.Unlock()
	return mock.ACLDryRunFunc(ctx, username, command...)
}

// ACLDryRunCalls gets all the calls that were made to ACLDryRun.
// Check the length with:
//
//	len(mockedGoRedisClient.ACLDryRunCalls())
func (mock *GoRedisClientMock) ACLDryRunCalls() []struct {
	Ctx      context.Context
	Username string
	Command  []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Username string
		Command  []interface{}
	}
	mock.lockACLDryRun.RLock()
	calls = mock.calls.ACLDryRun
	mock.lockACLDryRun.RUnlock()
	return calls
}

// ACLList calls ACLListFunc.
func (mock *GoRedisClientMock) ACLList(ctx context.Context) *redis.StringSliceCmd {
	if mock.ACLListFunc == nil {
		panic("GoRedisClientMock.ACLListFunc: method is nil but GoRedisClient.ACLList was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockACLList.Lock()
	mock.calls.ACLList = append(mock.calls.ACLList, callInfo)
	mock.lockACLList.Unlock()
	return mock.ACLListFunc(ctx)
}

// ACLListCalls gets all the calls that were made to ACLList.
// Check the length with:
//
//	len(mockedGoRedisClient.ACLListCalls())
func (mock *GoRedisClientMock) ACLListCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockACLList.RLock()
	calls = mock.calls.ACLList
	mock.lockACLList.RUnlock()
	return calls
}

// ACLLog calls ACLLogFunc.
func (mock *GoRedisClientMock) ACLLog(ctx context.Context, count int64) *redis.ACLLogCmd {
	if mock.ACLLogFunc == nil {
		panic("GoRedisClientMock.ACLLogFunc: method is nil but GoRedisClient.ACLLog was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Count int64
	}{
		Ctx:   ctx,
		Count: count,
	}
	mock.lockACLLog.Lock()
	mock.calls.ACLLog = append(mock.calls.ACLLog, callInfo)
	mock.lockACLLog.Unlock()
	return mock.ACLLogFunc(ctx, count)
}

// ACLLogCalls gets all the calls that were made to ACLLog.
// Check the length with:
//
//	len(mockedGoRedisClient.ACLLogCalls())
func (mock *GoRedisClientMock) ACLLogCalls() []struct {
	Ctx   context.Context
	Count int64
} {
	var calls []struct {
		Ctx   context.Context
		Count int64
	}
	mock.lockACLLog.RLock()
	calls = mock.calls.ACLLog
	mock.lockACLLog.RUnlock()
	return calls
}

// ACLLogReset calls ACLLogResetFunc.
func (mock *GoRedisClientMock) ACLLogReset(ctx context.Context) *redis.StatusCmd {
	if mock.ACLLogResetFunc == nil {
		panic("GoRedisClientMock.ACLLogResetFunc: method is nil but GoRedisClient.ACLLogReset was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockACLLogReset.Lock()
	mock.calls.ACLLogReset = append(mock.calls.ACLLogReset, callInfo)
	mock.lockACLLogReset.Unlock()
	return mock.ACLLogResetFunc(ctx)
}

// ACLLogResetCalls gets all the calls that were made to ACLLogReset.
// Check the length with:
//
//	len(mockedGoRedisClient.ACLLogResetCalls())
func (mock *GoRedisClientMock) ACLLogResetCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockACLLogReset.RLock()
	calls = mock.calls.ACLLogReset
	mock.lockACLLogReset.RUnlock()
	return calls
}

// ACLSetUser calls ACLSetUserFunc.
func (mock *GoRedisClientMock) ACLSetUser(ctx context.Context, username string, rules ...string) *redis.StatusCmd {
	if mock.ACLSetUserFunc == nil {
		panic("GoRedisClientMock.ACLSetUserFunc: method is nil but GoRedisClient.ACLSetUser was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Username string
		Rules    []string
	}{
		Ctx:      ctx,
		Username: username,
		Rules:    rules,
	}
	mock.lockACLSetUser.Lock()
	mock.calls.ACLSetUser = append(mock.calls.ACLSetUser, callInfo)
	mock.lockACLSetUser.Unlock()
	return mock.ACLSetUserFunc(ctx, username, rules...)
}

// ACLSetUserCalls gets all the calls that were made to ACLSetUser.
// Check the length with:
//
//	len(mockedGoRedisClient.ACLSetUserCalls())
func (mock *GoRedisClientMock) ACLSetUserCalls() []struct {
	Ctx      context.Context
	Username string
	Rules    []string
} {
	var calls []struct {
		Ctx      context.Context
		Username string
		Rules    []string
	}
	mock.lockACLSetUser.RLock()
	calls = mock.calls.ACLSetUser
	mock.lockACLSetUser.RUnlock()
	return calls
}

// AddHook calls AddHookFunc.
func (mock *GoRedisClientMock) AddHook(hook redis.Hook) {
	if mock.AddHookFunc == nil {
		panic("GoRedisClientMock.AddHookFunc: method is nil but GoRedisClient.AddHook was just called")
	}
	callInfo := struct {
		Hook redis.Hook
	}{
		Hook: hook,
	}
	mock.lockAddHook.Lock()
	mock.calls.AddHook = append(mock.calls.AddHook, callInfo)
	mock.lockAddHook.Unlock()
	mock.AddHookFunc(hook)
}

// AddHookCalls gets all the calls that were made to AddHook.
// Check the length with:
//
//	len(mockedGoRedisClient.AddHookCalls())
func (mock *GoRedisClientMock) AddHookCalls() []struct {
	Hook redis.Hook
} {
	var calls []struct {
		Hook redis.Hook
	}
	mock.lockAddHook.RLock()
	calls = mock.calls.AddHook
	mock.lockAddHook.RUnlock()
	return calls
}

// Append calls AppendFunc.
func (mock *GoRedisClientMock) Append(ctx context.Context, key string, value string) *redis.IntCmd {
	if mock.AppendFunc == nil {
		panic("GoRedisClientMock.AppendFunc: method is nil but GoRedisClient.Append was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Value string
	}{
		Ctx:   ctx,
		Key:   key,
		Value: value,
	}
	mock.lockAppend.Lock()
	mock.calls.Append = append(mock.calls.Append, callInfo)
	mock.lockAppend.Unlock()
	return mock.AppendFunc(ctx, key, value)
}

// AppendCalls gets all the calls that were made to Append.
// Check the length with:
//
//	len(mockedGoRedisClient.AppendCalls())
func (mock *GoRedisClientMock) AppendCalls() []struct {
	Ctx   context.Context
	Key   string
	Value string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Value string
	}
	mock.lockAppend.RLock()
	calls = mock.calls.Append
	mock.lockAppend.RUnlock()
	return calls
}

// BFAdd calls BFAddFunc.
func (mock *GoRedisClientMock) BFAdd(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
	if mock.BFAddFunc == nil {
		panic("GoRedisClientMock.BFAddFunc: method is nil but GoRedisClient.BFAdd was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Element: element,
	}
	mock.lockBFAdd.Lock()
	mock.calls.BFAdd = append(mock.calls.BFAdd, callInfo)
	mock.lockBFAdd.Unlock()
	return mock.BFAddFunc(ctx, key, element)
}

// BFAddCalls gets all the calls that were made to BFAdd.
// Check the length with:
//
//	len(mockedGoRedisClient.BFAddCalls())
func (mock *GoRedisClientMock) BFAddCalls() []struct {
	Ctx     context.Context
	Key     string
	Element interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}
	mock.lockBFAdd.RLock()
	calls = mock.calls.BFAdd
	mock.lockBFAdd.RUnlock()
	return calls
}

// BFCard calls BFCardFunc.
func (mock *GoRedisClientMock) BFCard(ctx context.Context, key string) *redis.IntCmd {
	if mock.BFCardFunc == nil {
		panic("GoRedisClientMock.BFCardFunc: method is nil but GoRedisClient.BFCard was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockBFCard.Lock()
	mock.calls.BFCard = append(mock.calls.BFCard, callInfo)
	mock.lockBFCard.Unlock()
	return mock.BFCardFunc(ctx, key)
}

// BFCardCalls gets all the calls that were made to BFCard.
// Check the length with:
//
//	len(mockedGoRedisClient.BFCardCalls())
func (mock *GoRedisClientMock) BFCardCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockBFCard.RLock()
	calls = mock.calls.BFCard
	mock.lockBFCard.RUnlock()
	return calls
}

// BFExists calls BFExistsFunc.
func (mock *GoRedisClientMock) BFExists(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
	if mock.BFExistsFunc == nil {
		panic("GoRedisClientMock.BFExistsFunc: method is nil but GoRedisClient.BFExists was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Element: element,
	}
	mock.lockBFExists.Lock()
	mock.calls.BFExists = append(mock.calls.BFExists, callInfo)
	mock.lockBFExists.Unlock()
	return mock.BFExistsFunc(ctx, key, element)
}

// BFExistsCalls gets all the calls that were made to BFExists.
// Check the length with:
//
//	len(mockedGoRedisClient.BFExistsCalls())
func (mock *GoRedisClientMock) BFExistsCalls() []struct {
	Ctx     context.Context
	Key     string
	Element interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}
	mock.lockBFExists.RLock()
	calls = mock.calls.BFExists
	mock.lockBFExists.RUnlock()
	return calls
}

// BFInfo calls BFInfoFunc.
func (mock *GoRedisClientMock) BFInfo(ctx context.Context, key string) *redis.BFInfoCmd {
	if mock.BFInfoFunc == nil {
		panic("GoRedisClientMock.BFInfoFunc: method is nil but GoRedisClient.BFInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockBFInfo.Lock()
	mock.calls.BFInfo = append(mock.calls.BFInfo, callInfo)
	mock.lockBFInfo.Unlock()
	return mock.BFInfoFunc(ctx, key)
}

// BFInfoCalls gets all the calls that were made to BFInfo.
// Check the length with:
//
//	len(mockedGoRedisClient.BFInfoCalls())
func (mock *GoRedisClientMock) BFInfoCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockBFInfo.RLock()
	calls = mock.calls.BFInfo
	mock.lockBFInfo.RUnlock()
	return calls
}

// BFInfoArg calls BFInfoArgFunc.
func (mock *GoRedisClientMock) BFInfoArg(ctx context.Context, key string, option string) *redis.BFInfoCmd {
	if mock.BFInfoArgFunc == nil {
		panic("GoRedisClientMock.BFInfoArgFunc: method is nil but GoRedisClient.BFInfoArg was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Option string
	}{
		Ctx:    ctx,
		Key:    key,
		Option: option,
	}
	mock.lockBFInfoArg.Lock()
	mock.calls.BFInfoArg = append(mock.calls.BFInfoArg, callInfo)
	mock.lockBFInfoArg.Unlock()
	return mock.BFInfoArgFunc(ctx, key, option)
}

// BFInfoArgCalls gets all the calls that were made to BFInfoArg.
// Check the length with:
//
//	len(mockedGoRedisClient.BFInfoArgCalls())
func (mock *GoRedisClientMock) BFInfoArgCalls() []struct {
	Ctx    context.Context
	Key    string
	Option string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Option string
	}
	mock.lockBFInfoArg.RLock()
	calls = mock.calls.BFInfoArg
	mock.lockBFInfoArg.RUnlock()
	return calls
}

// BFInfoCapacity calls BFInfoCapacityFunc.
func (mock *GoRedisClientMock) BFInfoCapacity(ctx context.Context, key string) *redis.BFInfoCmd {
	if mock.BFInfoCapacityFunc == nil {
		panic("GoRedisClientMock.BFInfoCapacityFunc: method is nil but GoRedisClient.BFInfoCapacity was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockBFInfoCapacity.Lock()
	mock.calls.BFInfoCapacity = append(mock.calls.BFInfoCapacity, callInfo)
	mock.lockBFInfoCapacity.Unlock()
	return mock.BFInfoCapacityFunc(ctx, key)
}

// BFInfoCapacityCalls gets all the calls that were made to BFInfoCapacity.
// Check the length with:
//
//	len(mockedGoRedisClient.BFInfoCapacityCalls())
func (mock *GoRedisClientMock) BFInfoCapacityCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockBFInfoCapacity.RLock()
	calls = mock.calls.BFInfoCapacity
	mock.lockBFInfoCapacity.RUnlock()
	return calls
}

// BFInfoExpansion calls BFInfoExpansionFunc.
func (mock *GoRedisClientMock) BFInfoExpansion(ctx context.Context, key string) *redis.BFInfoCmd {
	if mock.BFInfoExpansionFunc == nil {
		panic("GoRedisClientMock.BFInfoExpansionFunc: method is nil but GoRedisClient.BFInfoExpansion was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockBFInfoExpansion.Lock()
	mock.calls.BFInfoExpansion = append(mock.calls.BFInfoExpansion, callInfo)
	mock.lockBFInfoExpansion.Unlock()
	return mock.BFInfoExpansionFunc(ctx, key)
}

// BFInfoExpansionCalls gets all the calls that were made to BFInfoExpansion.
// Check the length with:
//
//	len(mockedGoRedisClient.BFInfoExpansionCalls())
func (mock *GoRedisClientMock) BFInfoExpansionCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockBFInfoExpansion.RLock()
	calls = mock.calls.BFInfoExpansion
	mock.lockBFInfoExpansion.RUnlock()
	return calls
}

// BFInfoFilters calls BFInfoFiltersFunc.
func (mock *GoRedisClientMock) BFInfoFilters(ctx context.Context, key string) *redis.BFInfoCmd {
	if mock.BFInfoFiltersFunc == nil {
		panic("GoRedisClientMock.BFInfoFiltersFunc: method is nil but GoRedisClient.BFInfoFilters was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockBFInfoFilters.Lock()
	mock.calls.BFInfoFilters = append(mock.calls.BFInfoFilters, callInfo)
	mock.lockBFInfoFilters.Unlock()
	return mock.BFInfoFiltersFunc(ctx, key)
}

// BFInfoFiltersCalls gets all the calls that were made to BFInfoFilters.
// Check the length with:
//
//	len(mockedGoRedisClient.BFInfoFiltersCalls())
func (mock *GoRedisClientMock) BFInfoFiltersCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockBFInfoFilters.RLock()
	calls = mock.calls.BFInfoFilters
	mock.lockBFInfoFilters.RUnlock()
	return calls
}

// BFInfoItems calls BFInfoItemsFunc.
func (mock *GoRedisClientMock) BFInfoItems(ctx context.Context, key string) *redis.BFInfoCmd {
	if mock.BFInfoItemsFunc == nil {
		panic("GoRedisClientMock.BFInfoItemsFunc: method is nil but GoRedisClient.BFInfoItems was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockBFInfoItems.Lock()
	mock.calls.BFInfoItems = append(mock.calls.BFInfoItems, callInfo)
	mock.lockBFInfoItems.Unlock()
	return mock.BFInfoItemsFunc(ctx, key)
}

// BFInfoItemsCalls gets all the calls that were made to BFInfoItems.
// Check the length with:
//
//	len(mockedGoRedisClient.BFInfoItemsCalls())
func (mock *GoRedisClientMock) BFInfoItemsCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockBFInfoItems.RLock()
	calls = mock.calls.BFInfoItems
	mock.lockBFInfoItems.RUnlock()
	return calls
}

// BFInfoSize calls BFInfoSizeFunc.
func (mock *GoRedisClientMock) BFInfoSize(ctx context.Context, key string) *redis.BFInfoCmd {
	if mock.BFInfoSizeFunc == nil {
		panic("GoRedisClientMock.BFInfoSizeFunc: method is nil but GoRedisClient.BFInfoSize was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockBFInfoSize.Lock()
	mock.calls.BFInfoSize = append(mock.calls.BFInfoSize, callInfo)
	mock.lockBFInfoSize.Unlock()
	return mock.BFInfoSizeFunc(ctx, key)
}

// BFInfoSizeCalls gets all the calls that were made to BFInfoSize.
// Check the length with:
//
//	len(mockedGoRedisClient.BFInfoSizeCalls())
func (mock *GoRedisClientMock) BFInfoSizeCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockBFInfoSize.RLock()
	calls = mock.calls.BFInfoSize
	mock.lockBFInfoSize.RUnlock()
	return calls
}

// BFInsert calls BFInsertFunc.
func (mock *GoRedisClientMock) BFInsert(ctx context.Context, key string, options *redis.BFInsertOptions, elements ...interface{}) *redis.BoolSliceCmd {
	if mock.BFInsertFunc == nil {
		panic("GoRedisClientMock.BFInsertFunc: method is nil but GoRedisClient.BFInsert was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Options  *redis.BFInsertOptions
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Options:  options,
		Elements: elements,
	}
	mock.lockBFInsert.Lock()
	mock.calls.BFInsert = append(mock.calls.BFInsert, callInfo)
	mock.lockBFInsert.Unlock()
	return mock.BFInsertFunc(ctx, key, options, elements...)
}

// BFInsertCalls gets all the calls that were made to BFInsert.
// Check the length with:
//
//	len(mockedGoRedisClient.BFInsertCalls())
func (mock *GoRedisClientMock) BFInsertCalls() []struct {
	Ctx      context.Context
	Key      string
	Options  *redis.BFInsertOptions
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Options  *redis.BFInsertOptions
		Elements []interface{}
	}
	mock.lockBFInsert.RLock()
	calls = mock.calls.BFInsert
	mock.lockBFInsert.RUnlock()
	return calls
}

// BFLoadChunk calls BFLoadChunkFunc.
func (mock *GoRedisClientMock) BFLoadChunk(ctx context.Context, key string, iterator int64, data interface{}) *redis.StatusCmd {
	if mock.BFLoadChunkFunc == nil {
		panic("GoRedisClientMock.BFLoadChunkFunc: method is nil but GoRedisClient.BFLoadChunk was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Iterator int64
		Data     interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Iterator: iterator,
		Data:     data,
	}
	mock.lockBFLoadChunk.Lock()
	mock.calls.BFLoadChunk = append(mock.calls.BFLoadChunk, callInfo)
	mock.lockBFLoadChunk.Unlock()
	return mock.BFLoadChunkFunc(ctx, key, iterator, data)
}

// BFLoadChunkCalls gets all the calls that were made to BFLoadChunk.
// Check the length with:
//
//	len(mockedGoRedisClient.BFLoadChunkCalls())
func (mock *GoRedisClientMock) BFLoadChunkCalls() []struct {
	Ctx      context.Context
	Key      string
	Iterator int64
	Data     interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Iterator int64
		Data     interface{}
	}
	mock.lockBFLoadChunk.RLock()
	calls = mock.calls.BFLoadChunk
	mock.lockBFLoadChunk.RUnlock()
	return calls
}

// BFMAdd calls BFMAddFunc.
func (mock *GoRedisClientMock) BFMAdd(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd {
	if mock.BFMAddFunc == nil {
		panic("GoRedisClientMock.BFMAddFunc: method is nil but GoRedisClient.BFMAdd was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockBFMAdd.Lock()
	mock.calls.BFMAdd = append(mock.calls.BFMAdd, callInfo)
	mock.lockBFMAdd.Unlock()
	return mock.BFMAddFunc(ctx, key, elements...)
}

// BFMAddCalls gets all the calls that were made to BFMAdd.
// Check the length with:
//
//	len(mockedGoRedisClient.BFMAddCalls())
func (mock *GoRedisClientMock) BFMAddCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}
	mock.lockBFMAdd.RLock()
	calls = mock.calls.BFMAdd
	mock.lockBFMAdd.RUnlock()
	return calls
}

// BFMExists calls BFMExistsFunc.
func (mock *GoRedisClientMock) BFMExists(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd {
	if mock.BFMExistsFunc == nil {
		panic("GoRedisClientMock.BFMExistsFunc: method is nil but GoRedisClient.BFMExists was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockBFMExists.Lock()
	mock.calls.BFMExists = append(mock.calls.BFMExists, callInfo)
	mock.lockBFMExists.Unlock()
	return mock.BFMExistsFunc(ctx, key, elements...)
}

// BFMExistsCalls gets all the calls that were made to BFMExists.
// Check the length with:
//
//	len(mockedGoRedisClient.BFMExistsCalls())
func (mock *GoRedisClientMock) BFMExistsCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}
	mock.lockBFMExists.RLock()
	calls = mock.calls.BFMExists
	mock.lockBFMExists.RUnlock()
	return calls
}

// BFReserve calls BFReserveFunc.
func (mock *GoRedisClientMock) BFReserve(ctx context.Context, key string, errorRate float64, capacity int64) *redis.StatusCmd {
	if mock.BFReserveFunc == nil {
		panic("GoRedisClientMock.BFReserveFunc: method is nil but GoRedisClient.BFReserve was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		ErrorRate float64
		Capacity  int64
	}{
		Ctx:       ctx,
		Key:       key,
		ErrorRate: errorRate,
		Capacity:  capacity,
	}
	mock.lockBFReserve.Lock()
	mock.calls.BFReserve = append(mock.calls.BFReserve, callInfo)
	mock.lockBFReserve.Unlock()
	return mock.BFReserveFunc(ctx, key, errorRate, capacity)
}

// BFReserveCalls gets all the calls that were made to BFReserve.
// Check the length with:
//
//	len(mockedGoRedisClient.BFReserveCalls())
func (mock *GoRedisClientMock) BFReserveCalls() []struct {
	Ctx       context.Context
	Key       string
	ErrorRate float64
	Capacity  int64
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		ErrorRate float64
		Capacity  int64
	}
	mock.lockBFReserve.RLock()
	calls = mock.calls.BFReserve
	mock.lockBFReserve.RUnlock()
	return calls
}

// BFReserveExpansion calls BFReserveExpansionFunc.
func (mock *GoRedisClientMock) BFReserveExpansion(ctx context.Context, key string, errorRate float64, capacity int64, expansion int64) *redis.StatusCmd {
	if mock.BFReserveExpansionFunc == nil {
		panic("GoRedisClientMock.BFReserveExpansionFunc: method is nil but GoRedisClient.BFReserveExpansion was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		ErrorRate float64
		Capacity  int64
		Expansion int64
	}{
		Ctx:       ctx,
		Key:       key,
		ErrorRate: errorRate,
		Capacity:  capacity,
		Expansion: expansion,
	}
	mock.lockBFReserveExpansion.Lock()
	mock.calls.BFReserveExpansion = append(mock.calls.BFReserveExpansion, callInfo)
	mock.lockBFReserveExpansion.Unlock()
	return mock.BFReserveExpansionFunc(ctx, key, errorRate, capacity, expansion)
}

// BFReserveExpansionCalls gets all the calls that were made to BFReserveExpansion.
// Check the length with:
//
//	len(mockedGoRedisClient.BFReserveExpansionCalls())
func (mock *GoRedisClientMock) BFReserveExpansionCalls() []struct {
	Ctx       context.Context
	Key       string
	ErrorRate float64
	Capacity  int64
	Expansion int64
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		ErrorRate float64
		Capacity  int64
		Expansion int64
	}
	mock.lockBFReserveExpansion.RLock()
	calls = mock.calls.BFReserveExpansion
	mock.lockBFReserveExpansion.RUnlock()
	return calls
}

// BFReserveNonScaling calls BFReserveNonScalingFunc.
func (mock *GoRedisClientMock) BFReserveNonScaling(ctx context.Context, key string, errorRate float64, capacity int64) *redis.StatusCmd {
	if mock.BFReserveNonScalingFunc == nil {
		panic("GoRedisClientMock.BFReserveNonScalingFunc: method is nil but GoRedisClient.BFReserveNonScaling was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		ErrorRate float64
		Capacity  int64
	}{
		Ctx:       ctx,
		Key:       key,
		ErrorRate: errorRate,
		Capacity:  capacity,
	}
	mock.lockBFReserveNonScaling.Lock()
	mock.calls.BFReserveNonScaling = append(mock.calls.BFReserveNonScaling, callInfo)
	mock.lockBFReserveNonScaling.Unlock()
	return mock.BFReserveNonScalingFunc(ctx, key, errorRate, capacity)
}

// BFReserveNonScalingCalls gets all the calls that were made to BFReserveNonScaling.
// Check the length with:
//
//	len(mockedGoRedisClient.BFReserveNonScalingCalls())
func (mock *GoRedisClientMock) BFReserveNonScalingCalls() []struct {
	Ctx       context.Context
	Key       string
	ErrorRate float64
	Capacity  int64
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		ErrorRate float64
		Capacity  int64
	}
	mock.lockBFReserveNonScaling.RLock()
	calls = mock.calls.BFReserveNonScaling
	mock.lockBFReserveNonScaling.RUnlock()
	return calls
}

// BFReserveWithArgs calls BFReserveWithArgsFunc.
func (mock *GoRedisClientMock) BFReserveWithArgs(ctx context.Context, key string, options *redis.BFReserveOptions) *redis.StatusCmd {
	if mock.BFReserveWithArgsFunc == nil {
		panic("GoRedisClientMock.BFReserveWithArgsFunc: method is nil but GoRedisClient.BFReserveWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Options *redis.BFReserveOptions
	}{
		Ctx:     ctx,
		Key:     key,
		Options: options,
	}
	mock.lockBFReserveWithArgs.Lock()
	mock.calls.BFReserveWithArgs = append(mock.calls.BFReserveWithArgs, callInfo)
	mock.lockBFReserveWithArgs.Unlock()
	return mock.BFReserveWithArgsFunc(ctx, key, options)
}

// BFReserveWithArgsCalls gets all the calls that were made to BFReserveWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.BFReserveWithArgsCalls())
func (mock *GoRedisClientMock) BFReserveWithArgsCalls() []struct {
	Ctx     context.Context
	Key     string
	Options *redis.BFReserveOptions
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Options *redis.BFReserveOptions
	}
	mock.lockBFReserveWithArgs.RLock()
	calls = mock.calls.BFReserveWithArgs
	mock.lockBFReserveWithArgs.RUnlock()
	return calls
}

// BFScanDump calls BFScanDumpFunc.
func (mock *GoRedisClientMock) BFScanDump(ctx context.Context, key string, iterator int64) *redis.ScanDumpCmd {
	if mock.BFScanDumpFunc == nil {
		panic("GoRedisClientMock.BFScanDumpFunc: method is nil but GoRedisClient.BFScanDump was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Iterator int64
	}{
		Ctx:      ctx,
		Key:      key,
		Iterator: iterator,
	}
	mock.lockBFScanDump.Lock()
	mock.calls.BFScanDump = append(mock.calls.BFScanDump, callInfo)
	mock.lockBFScanDump.Unlock()
	return mock.BFScanDumpFunc(ctx, key, iterator)
}

// BFScanDumpCalls gets all the calls that were made to BFScanDump.
// Check the length with:
//
//	len(mockedGoRedisClient.BFScanDumpCalls())
func (mock *GoRedisClientMock) BFScanDumpCalls() []struct {
	Ctx      context.Context
	Key      string
	Iterator int64
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Iterator int64
	}
	mock.lockBFScanDump.RLock()
	calls = mock.calls.BFScanDump
	mock.lockBFScanDump.RUnlock()
	return calls
}

// BLMPop calls BLMPopFunc.
func (mock *GoRedisClientMock) BLMPop(ctx context.Context, timeout time.Duration, direction string, count int64, keys ...string) *redis.KeyValuesCmd {
	if mock.BLMPopFunc == nil {
		panic("GoRedisClientMock.BLMPopFunc: method is nil but GoRedisClient.BLMPop was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Timeout   time.Duration
		Direction string
		Count     int64
		Keys      []string
	}{
		Ctx:       ctx,
		Timeout:   timeout,
		Direction: direction,
		Count:     count,
		Keys:      keys,
	}
	mock.lockBLMPop.Lock()
	mock.calls.BLMPop = append(mock.calls.BLMPop, callInfo)
	mock.lockBLMPop.Unlock()
	return mock.BLMPopFunc(ctx, timeout, direction, count, keys...)
}

// BLMPopCalls gets all the calls that were made to BLMPop.
// Check the length with:
//
//	len(mockedGoRedisClient.BLMPopCalls())
func (mock *GoRedisClientMock) BLMPopCalls() []struct {
	Ctx       context.Context
	Timeout   time.Duration
	Direction string
	Count     int64
	Keys      []string
} {
	var calls []struct {
		Ctx       context.Context
		Timeout   time.Duration
		Direction string
		Count     int64
		Keys      []string
	}
	mock.lockBLMPop.RLock()
	calls = mock.calls.BLMPop
	mock.lockBLMPop.RUnlock()
	return calls
}

// BLMove calls BLMoveFunc.
func (mock *GoRedisClientMock) BLMove(ctx context.Context, source string, destination string, srcpos string, destpos string, timeout time.Duration) *redis.StringCmd {
	if mock.BLMoveFunc == nil {
		panic("GoRedisClientMock.BLMoveFunc: method is nil but GoRedisClient.BLMove was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Source      string
		Destination string
		Srcpos      string
		Destpos     string
		Timeout     time.Duration
	}{
		Ctx:         ctx,
		Source:      source,
		Destination: destination,
		Srcpos:      srcpos,
		Destpos:     destpos,
		Timeout:     timeout,
	}
	mock.lockBLMove.Lock()
	mock.calls.BLMove = append(mock.calls.BLMove, callInfo)
	mock.lockBLMove.Unlock()
	return mock.BLMoveFunc(ctx, source, destination, srcpos, destpos, timeout)
}

// BLMoveCalls gets all the calls that were made to BLMove.
// Check the length with:
//
//	len(mockedGoRedisClient.BLMoveCalls())
func (mock *GoRedisClientMock) BLMoveCalls() []struct {
	Ctx         context.Context
	Source      string
	Destination string
	Srcpos      string
	Destpos     string
	Timeout     time.Duration
} {
	var calls []struct {
		Ctx         context.Context
		Source      string
		Destination string
		Srcpos      string
		Destpos     string
		Timeout     time.Duration
	}
	mock.lockBLMove.RLock()
	calls = mock.calls.BLMove
	mock.lockBLMove.RUnlock()
	return calls
}

// BLPop calls BLPopFunc.
func (mock *GoRedisClientMock) BLPop(ctx context.Context, timeout time.Duration, keys ...string) *redis.StringSliceCmd {
	if mock.BLPopFunc == nil {
		panic("GoRedisClientMock.BLPopFunc: method is nil but GoRedisClient.BLPop was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Timeout time.Duration
		Keys    []string
	}{
		Ctx:     ctx,
		Timeout: timeout,
		Keys:    keys,
	}
	mock.lockBLPop.Lock()
	mock.calls.BLPop = append(mock.calls.BLPop, callInfo)
	mock.lockBLPop.Unlock()
	return mock.BLPopFunc(ctx, timeout, keys...)
}

// BLPopCalls gets all the calls that were made to BLPop.
// Check the length with:
//
//	len(mockedGoRedisClient.BLPopCalls())
func (mock *GoRedisClientMock) BLPopCalls() []struct {
	Ctx     context.Context
	Timeout time.Duration
	Keys    []string
} {
	var calls []struct {
		Ctx     context.Context
		Timeout time.Duration
		Keys    []string
	}
	mock.lockBLPop.RLock()
	calls = mock.calls.BLPop
	mock.lockBLPop.RUnlock()
	return calls
}

// BRPop calls BRPopFunc.
func (mock *GoRedisClientMock) BRPop(ctx context.Context, timeout time.Duration, keys ...string) *redis.StringSliceCmd {
	if mock.BRPopFunc == nil {
		panic("GoRedisClientMock.BRPopFunc: method is nil but GoRedisClient.BRPop was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Timeout time.Duration
		Keys    []string
	}{
		Ctx:     ctx,
		Timeout: timeout,
		Keys:    keys,
	}
	mock.lockBRPop.Lock()
	mock.calls.BRPop = append(mock.calls.BRPop, callInfo)
	mock.lockBRPop.Unlock()
	return mock.BRPopFunc(ctx, timeout, keys...)
}

// BRPopCalls gets all the calls that were made to BRPop.
// Check the length with:
//
//	len(mockedGoRedisClient.BRPopCalls())
func (mock *GoRedisClientMock) BRPopCalls() []struct {
	Ctx     context.Context
	Timeout time.Duration
	Keys    []string
} {
	var calls []struct {
		Ctx     context.Context
		Timeout time.Duration
		Keys    []string
	}
	mock.lockBRPop.RLock()
	calls = mock.calls.BRPop
	mock.lockBRPop.RUnlock()
	return calls
}

// BRPopLPush calls BRPopLPushFunc.
func (mock *GoRedisClientMock) BRPopLPush(ctx context.Context, source string, destination string, timeout time.Duration) *redis.StringCmd {
	if mock.BRPopLPushFunc == nil {
		panic("GoRedisClientMock.BRPopLPushFunc: method is nil but GoRedisClient.BRPopLPush was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Source      string
		Destination string
		Timeout     time.Duration
	}{
		Ctx:         ctx,
		Source:      source,
		Destination: destination,
		Timeout:     timeout,
	}
	mock.lockBRPopLPush.Lock()
	mock.calls.BRPopLPush = append(mock.calls.BRPopLPush, callInfo)
	mock.lockBRPopLPush.Unlock()
	return mock.BRPopLPushFunc(ctx, source, destination, timeout)
}

// BRPopLPushCalls gets all the calls that were made to BRPopLPush.
// Check the length with:
//
//	len(mockedGoRedisClient.BRPopLPushCalls())
func (mock *GoRedisClientMock) BRPopLPushCalls() []struct {
	Ctx         context.Context
	Source      string
	Destination string
	Timeout     time.Duration
} {
	var calls []struct {
		Ctx         context.Context
		Source      string
		Destination string
		Timeout     time.Duration
	}
	mock.lockBRPopLPush.RLock()
	calls = mock.calls.BRPopLPush
	mock.lockBRPopLPush.RUnlock()
	return calls
}

// BZMPop calls BZMPopFunc.
func (mock *GoRedisClientMock) BZMPop(ctx context.Context, timeout time.Duration, order string, count int64, keys ...string) *redis.ZSliceWithKeyCmd {
	if mock.BZMPopFunc == nil {
		panic("GoRedisClientMock.BZMPopFunc: method is nil but GoRedisClient.BZMPop was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Timeout time.Duration
		Order   string
		Count   int64
		Keys    []string
	}{
		Ctx:     ctx,
		Timeout: timeout,
		Order:   order,
		Count:   count,
		Keys:    keys,
	}
	mock.lockBZMPop.Lock()
	mock.calls.BZMPop = append(mock.calls.BZMPop, callInfo)
	mock.lockBZMPop.Unlock()
	return mock.BZMPopFunc(ctx, timeout, order, count, keys...)
}

// BZMPopCalls gets all the calls that were made to BZMPop.
// Check the length with:
//
//	len(mockedGoRedisClient.BZMPopCalls())
func (mock *GoRedisClientMock) BZMPopCalls() []struct {
	Ctx     context.Context
	Timeout time.Duration
	Order   string
	Count   int64
	Keys    []string
} {
	var calls []struct {
		Ctx     context.Context
		Timeout time.Duration
		Order   string
		Count   int64
		Keys    []string
	}
	mock.lockBZMPop.RLock()
	calls = mock.calls.BZMPop
	mock.lockBZMPop.RUnlock()
	return calls
}

// BZPopMax calls BZPopMaxFunc.
func (mock *GoRedisClientMock) BZPopMax(ctx context.Context, timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
	if mock.BZPopMaxFunc == nil {
		panic("GoRedisClientMock.BZPopMaxFunc: method is nil but GoRedisClient.BZPopMax was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Timeout time.Duration
		Keys    []string
	}{
		Ctx:     ctx,
		Timeout: timeout,
		Keys:    keys,
	}
	mock.lockBZPopMax.Lock()
	mock.calls.BZPopMax = append(mock.calls.BZPopMax, callInfo)
	mock.lockBZPopMax.Unlock()
	return mock.BZPopMaxFunc(ctx, timeout, keys...)
}

// BZPopMaxCalls gets all the calls that were made to BZPopMax.
// Check the length with:
//
//	len(mockedGoRedisClient.BZPopMaxCalls())
func (mock *GoRedisClientMock) BZPopMaxCalls() []struct {
	Ctx     context.Context
	Timeout time.Duration
	Keys    []string
} {
	var calls []struct {
		Ctx     context.Context
		Timeout time.Duration
		Keys    []string
	}
	mock.lockBZPopMax.RLock()
	calls = mock.calls.BZPopMax
	mock.lockBZPopMax.RUnlock()
	return calls
}

// BZPopMin calls BZPopMinFunc.
func (mock *GoRedisClientMock) BZPopMin(ctx context.Context, timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
	if mock.BZPopMinFunc == nil {
		panic("GoRedisClientMock.BZPopMinFunc: method is nil but GoRedisClient.BZPopMin was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Timeout time.Duration
		Keys    []string
	}{
		Ctx:     ctx,
		Timeout: timeout,
		Keys:    keys,
	}
	mock.lockBZPopMin.Lock()
	mock.calls.BZPopMin = append(mock.calls.BZPopMin, callInfo)
	mock.lockBZPopMin.Unlock()
	return mock.BZPopMinFunc(ctx, timeout, keys...)
}

// BZPopMinCalls gets all the calls that were made to BZPopMin.
// Check the length with:
//
//	len(mockedGoRedisClient.BZPopMinCalls())
func (mock *GoRedisClientMock) BZPopMinCalls() []struct {
	Ctx     context.Context
	Timeout time.Duration
	Keys    []string
} {
	var calls []struct {
		Ctx     context.Context
		Timeout time.Duration
		Keys    []string
	}
	mock.lockBZPopMin.RLock()
	calls = mock.calls.BZPopMin
	mock.lockBZPopMin.RUnlock()
	return calls
}

// BgRewriteAOF calls BgRewriteAOFFunc.
func (mock *GoRedisClientMock) BgRewriteAOF(ctx context.Context) *redis.StatusCmd {
	if mock.BgRewriteAOFFunc == nil {
		panic("GoRedisClientMock.BgRewriteAOFFunc: method is nil but GoRedisClient.BgRewriteAOF was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockBgRewriteAOF.Lock()
	mock.calls.BgRewriteAOF = append(mock.calls.BgRewriteAOF, callInfo)
	mock.lockBgRewriteAOF.Unlock()
	return mock.BgRewriteAOFFunc(ctx)
}

// BgRewriteAOFCalls gets all the calls that were made to BgRewriteAOF.
// Check the length with:
//
//	len(mockedGoRedisClient.BgRewriteAOFCalls())
func (mock *GoRedisClientMock) BgRewriteAOFCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockBgRewriteAOF.RLock()
	calls = mock.calls.BgRewriteAOF
	mock.lockBgRewriteAOF.RUnlock()
	return calls
}

// BgSave calls BgSaveFunc.
func (mock *GoRedisClientMock) BgSave(ctx context.Context) *redis.StatusCmd {
	if mock.BgSaveFunc == nil {
		panic("GoRedisClientMock.BgSaveFunc: method is nil but GoRedisClient.BgSave was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockBgSave.Lock()
	mock.calls.BgSave = append(mock.calls.BgSave, callInfo)
	mock.lockBgSave.Unlock()
	return mock.BgSaveFunc(ctx)
}

// BgSaveCalls gets all the calls that were made to BgSave.
// Check the length with:
//
//	len(mockedGoRedisClient.BgSaveCalls())
func (mock *GoRedisClientMock) BgSaveCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockBgSave.RLock()
	calls = mock.calls.BgSave
	mock.lockBgSave.RUnlock()
	return calls
}

// BitCount calls BitCountFunc.
func (mock *GoRedisClientMock) BitCount(ctx context.Context, key string, bitCount *redis.BitCount) *redis.IntCmd {
	if mock.BitCountFunc == nil {
		panic("GoRedisClientMock.BitCountFunc: method is nil but GoRedisClient.BitCount was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		BitCount *redis.BitCount
	}{
		Ctx:      ctx,
		Key:      key,
		BitCount: bitCount,
	}
	mock.lockBitCount.Lock()
	mock.calls.BitCount = append(mock.calls.BitCount, callInfo)
	mock.lockBitCount.Unlock()
	return mock.BitCountFunc(ctx, key, bitCount)
}

// BitCountCalls gets all the calls that were made to BitCount.
// Check the length with:
//
//	len(mockedGoRedisClient.BitCountCalls())
func (mock *GoRedisClientMock) BitCountCalls() []struct {
	Ctx      context.Context
	Key      string
	BitCount *redis.BitCount
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		BitCount *redis.BitCount
	}
	mock.lockBitCount.RLock()
	calls = mock.calls.BitCount
	mock.lockBitCount.RUnlock()
	return calls
}

// BitField calls BitFieldFunc.
func (mock *GoRedisClientMock) BitField(ctx context.Context, key string, values ...interface{}) *redis.IntSliceCmd {
	if mock.BitFieldFunc == nil {
		panic("GoRedisClientMock.BitFieldFunc: method is nil but GoRedisClient.BitField was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}{
		Ctx:    ctx,
		Key:    key,
		Values: values,
	}
	mock.lockBitField.Lock()
	mock.calls.BitField = append(mock.calls.BitField, callInfo)
	mock.lockBitField.Unlock()
	return mock.BitFieldFunc(ctx, key, values...)
}

// BitFieldCalls gets all the calls that were made to BitField.
// Check the length with:
//
//	len(mockedGoRedisClient.BitFieldCalls())
func (mock *GoRedisClientMock) BitFieldCalls() []struct {
	Ctx    context.Context
	Key    string
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}
	mock.lockBitField.RLock()
	calls = mock.calls.BitField
	mock.lockBitField.RUnlock()
	return calls
}

// BitFieldRO calls BitFieldROFunc.
func (mock *GoRedisClientMock) BitFieldRO(ctx context.Context, key string, values ...interface{}) *redis.IntSliceCmd {
	if mock.BitFieldROFunc == nil {
		panic("GoRedisClientMock.BitFieldROFunc: method is nil but GoRedisClient.BitFieldRO was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}{
		Ctx:    ctx,
		Key:    key,
		Values: values,
	}
	mock.lockBitFieldRO.Lock()
	mock.calls.BitFieldRO = append(mock.calls.BitFieldRO, callInfo)
	mock.lockBitFieldRO.Unlock()
	return mock.BitFieldROFunc(ctx, key, values...)
}

// BitFieldROCalls gets all the calls that were made to BitFieldRO.
// Check the length with:
//
//	len(mockedGoRedisClient.BitFieldROCalls())
func (mock *GoRedisClientMock) BitFieldROCalls() []struct {
	Ctx    context.Context
	Key    string
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}
	mock.lockBitFieldRO.RLock()
	calls = mock.calls.BitFieldRO
	mock.lockBitFieldRO.RUnlock()
	return calls
}

// BitOpAnd calls BitOpAndFunc.
func (mock *GoRedisClientMock) BitOpAnd(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
	if mock.BitOpAndFunc == nil {
		panic("GoRedisClientMock.BitOpAndFunc: method is nil but GoRedisClient.BitOpAnd was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		DestKey string
		Keys    []string
	}{
		Ctx:     ctx,
		DestKey: destKey,
		Keys:    keys,
	}
	mock.lockBitOpAnd.Lock()
	mock.calls.BitOpAnd = append(mock.calls.BitOpAnd, callInfo)
	mock.lockBitOpAnd.Unlock()
	return mock.BitOpAndFunc(ctx, destKey, keys...)
}

// BitOpAndCalls gets all the calls that were made to BitOpAnd.
// Check the length with:
//
//	len(mockedGoRedisClient.BitOpAndCalls())
func (mock *GoRedisClientMock) BitOpAndCalls() []struct {
	Ctx     context.Context
	DestKey string
	Keys    []string
} {
	var calls []struct {
		Ctx     context.Context
		DestKey string
		Keys    []string
	}
	mock.lockBitOpAnd.RLock()
	calls = mock.calls.BitOpAnd
	mock.lockBitOpAnd.RUnlock()
	return calls
}

// BitOpNot calls BitOpNotFunc.
func (mock *GoRedisClientMock) BitOpNot(ctx context.Context, destKey string, key string) *redis.IntCmd {
	if mock.BitOpNotFunc == nil {
		panic("GoRedisClientMock.BitOpNotFunc: method is nil but GoRedisClient.BitOpNot was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		DestKey string
		Key     string
	}{
		Ctx:     ctx,
		DestKey: destKey,
		Key:     key,
	}
	mock.lockBitOpNot.Lock()
	mock.calls.BitOpNot = append(mock.calls.BitOpNot, callInfo)
	mock.lockBitOpNot.Unlock()
	return mock.BitOpNotFunc(ctx, destKey, key)
}

// BitOpNotCalls gets all the calls that were made to BitOpNot.
// Check the length with:
//
//	len(mockedGoRedisClient.BitOpNotCalls())
func (mock *GoRedisClientMock) BitOpNotCalls() []struct {
	Ctx     context.Context
	DestKey string
	Key     string
} {
	var calls []struct {
		Ctx     context.Context
		DestKey string
		Key     string
	}
	mock.lockBitOpNot.RLock()
	calls = mock.calls.BitOpNot
	mock.lockBitOpNot.RUnlock()
	return calls
}

// BitOpOr calls BitOpOrFunc.
func (mock *GoRedisClientMock) BitOpOr(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
	if mock.BitOpOrFunc == nil {
		panic("GoRedisClientMock.BitOpOrFunc: method is nil but GoRedisClient.BitOpOr was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		DestKey string
		Keys    []string
	}{
		Ctx:     ctx,
		DestKey: destKey,
		Keys:    keys,
	}
	mock.lockBitOpOr.Lock()
	mock.calls.BitOpOr = append(mock.calls.BitOpOr, callInfo)
	mock.lockBitOpOr.Unlock()
	return mock.BitOpOrFunc(ctx, destKey, keys...)
}

// BitOpOrCalls gets all the calls that were made to BitOpOr.
// Check the length with:
//
//	len(mockedGoRedisClient.BitOpOrCalls())
func (mock *GoRedisClientMock) BitOpOrCalls() []struct {
	Ctx     context.Context
	DestKey string
	Keys    []string
} {
	var calls []struct {
		Ctx     context.Context
		DestKey string
		Keys    []string
	}
	mock.lockBitOpOr.RLock()
	calls = mock.calls.BitOpOr
	mock.lockBitOpOr.RUnlock()
	return calls
}

// BitOpXor calls BitOpXorFunc.
func (mock *GoRedisClientMock) BitOpXor(ctx context.Context, destKey string, keys ...string) *redis.IntCmd {
	if mock.BitOpXorFunc == nil {
		panic("GoRedisClientMock.BitOpXorFunc: method is nil but GoRedisClient.BitOpXor was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		DestKey string
		Keys    []string
	}{
		Ctx:     ctx,
		DestKey: destKey,
		Keys:    keys,
	}
	mock.lockBitOpXor.Lock()
	mock.calls.BitOpXor = append(mock.calls.BitOpXor, callInfo)
	mock.lockBitOpXor.Unlock()
	return mock.BitOpXorFunc(ctx, destKey, keys...)
}

// BitOpXorCalls gets all the calls that were made to BitOpXor.
// Check the length with:
//
//	len(mockedGoRedisClient.BitOpXorCalls())
func (mock *GoRedisClientMock) BitOpXorCalls() []struct {
	Ctx     context.Context
	DestKey string
	Keys    []string
} {
	var calls []struct {
		Ctx     context.Context
		DestKey string
		Keys    []string
	}
	mock.lockBitOpXor.RLock()
	calls = mock.calls.BitOpXor
	mock.lockBitOpXor.RUnlock()
	return calls
}

// BitPos calls BitPosFunc.
func (mock *GoRedisClientMock) BitPos(ctx context.Context, key string, bit int64, pos ...int64) *redis.IntCmd {
	if mock.BitPosFunc == nil {
		panic("GoRedisClientMock.BitPosFunc: method is nil but GoRedisClient.BitPos was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Bit int64
		Pos []int64
	}{
		Ctx: ctx,
		Key: key,
		Bit: bit,
		Pos: pos,
	}
	mock.lockBitPos.Lock()
	mock.calls.BitPos = append(mock.calls.BitPos, callInfo)
	mock.lockBitPos.Unlock()
	return mock.BitPosFunc(ctx, key, bit, pos...)
}

// BitPosCalls gets all the calls that were made to BitPos.
// Check the length with:
//
//	len(mockedGoRedisClient.BitPosCalls())
func (mock *GoRedisClientMock) BitPosCalls() []struct {
	Ctx context.Context
	Key string
	Bit int64
	Pos []int64
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Bit int64
		Pos []int64
	}
	mock.lockBitPos.RLock()
	calls = mock.calls.BitPos
	mock.lockBitPos.RUnlock()
	return calls
}

// BitPosSpan calls BitPosSpanFunc.
func (mock *GoRedisClientMock) BitPosSpan(ctx context.Context, key string, bit int8, start int64, end int64, span string) *redis.IntCmd {
	if mock.BitPosSpanFunc == nil {
		panic("GoRedisClientMock.BitPosSpanFunc: method is nil but GoRedisClient.BitPosSpan was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Bit   int8
		Start int64
		End   int64
		Span  string
	}{
		Ctx:   ctx,
		Key:   key,
		Bit:   bit,
		Start: start,
		End:   end,
		Span:  span,
	}
	mock.lockBitPosSpan.Lock()
	mock.calls.BitPosSpan = append(mock.calls.BitPosSpan, callInfo)
	mock.lockBitPosSpan.Unlock()
	return mock.BitPosSpanFunc(ctx, key, bit, start, end, span)
}

// BitPosSpanCalls gets all the calls that were made to BitPosSpan.
// Check the length with:
//
//	len(mockedGoRedisClient.BitPosSpanCalls())
func (mock *GoRedisClientMock) BitPosSpanCalls() []struct {
	Ctx   context.Context
	Key   string
	Bit   int8
	Start int64
	End   int64
	Span  string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Bit   int8
		Start int64
		End   int64
		Span  string
	}
	mock.lockBitPosSpan.RLock()
	calls = mock.calls.BitPosSpan
	mock.lockBitPosSpan.RUnlock()
	return calls
}

// CFAdd calls CFAddFunc.
func (mock *GoRedisClientMock) CFAdd(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
	if mock.CFAddFunc == nil {
		panic("GoRedisClientMock.CFAddFunc: method is nil but GoRedisClient.CFAdd was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Element: element,
	}
	mock.lockCFAdd.Lock()
	mock.calls.CFAdd = append(mock.calls.CFAdd, callInfo)
	mock.lockCFAdd.Unlock()
	return mock.CFAddFunc(ctx, key, element)
}

// CFAddCalls gets all the calls that were made to CFAdd.
// Check the length with:
//
//	len(mockedGoRedisClient.CFAddCalls())
func (mock *GoRedisClientMock) CFAddCalls() []struct {
	Ctx     context.Context
	Key     string
	Element interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}
	mock.lockCFAdd.RLock()
	calls = mock.calls.CFAdd
	mock.lockCFAdd.RUnlock()
	return calls
}

// CFAddNX calls CFAddNXFunc.
func (mock *GoRedisClientMock) CFAddNX(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
	if mock.CFAddNXFunc == nil {
		panic("GoRedisClientMock.CFAddNXFunc: method is nil but GoRedisClient.CFAddNX was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Element: element,
	}
	mock.lockCFAddNX.Lock()
	mock.calls.CFAddNX = append(mock.calls.CFAddNX, callInfo)
	mock.lockCFAddNX.Unlock()
	return mock.CFAddNXFunc(ctx, key, element)
}

// CFAddNXCalls gets all the calls that were made to CFAddNX.
// Check the length with:
//
//	len(mockedGoRedisClient.CFAddNXCalls())
func (mock *GoRedisClientMock) CFAddNXCalls() []struct {
	Ctx     context.Context
	Key     string
	Element interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}
	mock.lockCFAddNX.RLock()
	calls = mock.calls.CFAddNX
	mock.lockCFAddNX.RUnlock()
	return calls
}

// CFCount calls CFCountFunc.
func (mock *GoRedisClientMock) CFCount(ctx context.Context, key string, element interface{}) *redis.IntCmd {
	if mock.CFCountFunc == nil {
		panic("GoRedisClientMock.CFCountFunc: method is nil but GoRedisClient.CFCount was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Element: element,
	}
	mock.lockCFCount.Lock()
	mock.calls.CFCount = append(mock.calls.CFCount, callInfo)
	mock.lockCFCount.Unlock()
	return mock.CFCountFunc(ctx, key, element)
}

// CFCountCalls gets all the calls that were made to CFCount.
// Check the length with:
//
//	len(mockedGoRedisClient.CFCountCalls())
func (mock *GoRedisClientMock) CFCountCalls() []struct {
	Ctx     context.Context
	Key     string
	Element interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}
	mock.lockCFCount.RLock()
	calls = mock.calls.CFCount
	mock.lockCFCount.RUnlock()
	return calls
}

// CFDel calls CFDelFunc.
func (mock *GoRedisClientMock) CFDel(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
	if mock.CFDelFunc == nil {
		panic("GoRedisClientMock.CFDelFunc: method is nil but GoRedisClient.CFDel was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Element: element,
	}
	mock.lockCFDel.Lock()
	mock.calls.CFDel = append(mock.calls.CFDel, callInfo)
	mock.lockCFDel.Unlock()
	return mock.CFDelFunc(ctx, key, element)
}

// CFDelCalls gets all the calls that were made to CFDel.
// Check the length with:
//
//	len(mockedGoRedisClient.CFDelCalls())
func (mock *GoRedisClientMock) CFDelCalls() []struct {
	Ctx     context.Context
	Key     string
	Element interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}
	mock.lockCFDel.RLock()
	calls = mock.calls.CFDel
	mock.lockCFDel.RUnlock()
	return calls
}

// CFExists calls CFExistsFunc.
func (mock *GoRedisClientMock) CFExists(ctx context.Context, key string, element interface{}) *redis.BoolCmd {
	if mock.CFExistsFunc == nil {
		panic("GoRedisClientMock.CFExistsFunc: method is nil but GoRedisClient.CFExists was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Element: element,
	}
	mock.lockCFExists.Lock()
	mock.calls.CFExists = append(mock.calls.CFExists, callInfo)
	mock.lockCFExists.Unlock()
	return mock.CFExistsFunc(ctx, key, element)
}

// CFExistsCalls gets all the calls that were made to CFExists.
// Check the length with:
//
//	len(mockedGoRedisClient.CFExistsCalls())
func (mock *GoRedisClientMock) CFExistsCalls() []struct {
	Ctx     context.Context
	Key     string
	Element interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Element interface{}
	}
	mock.lockCFExists.RLock()
	calls = mock.calls.CFExists
	mock.lockCFExists.RUnlock()
	return calls
}

// CFInfo calls CFInfoFunc.
func (mock *GoRedisClientMock) CFInfo(ctx context.Context, key string) *redis.CFInfoCmd {
	if mock.CFInfoFunc == nil {
		panic("GoRedisClientMock.CFInfoFunc: method is nil but GoRedisClient.CFInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockCFInfo.Lock()
	mock.calls.CFInfo = append(mock.calls.CFInfo, callInfo)
	mock.lockCFInfo.Unlock()
	return mock.CFInfoFunc(ctx, key)
}

// CFInfoCalls gets all the calls that were made to CFInfo.
// Check the length with:
//
//	len(mockedGoRedisClient.CFInfoCalls())
func (mock *GoRedisClientMock) CFInfoCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockCFInfo.RLock()
	calls = mock.calls.CFInfo
	mock.lockCFInfo.RUnlock()
	return calls
}

// CFInsert calls CFInsertFunc.
func (mock *GoRedisClientMock) CFInsert(ctx context.Context, key string, options *redis.CFInsertOptions, elements ...interface{}) *redis.BoolSliceCmd {
	if mock.CFInsertFunc == nil {
		panic("GoRedisClientMock.CFInsertFunc: method is nil but GoRedisClient.CFInsert was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Options  *redis.CFInsertOptions
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Options:  options,
		Elements: elements,
	}
	mock.lockCFInsert.Lock()
	mock.calls.CFInsert = append(mock.calls.CFInsert, callInfo)
	mock.lockCFInsert.Unlock()
	return mock.CFInsertFunc(ctx, key, options, elements...)
}

// CFInsertCalls gets all the calls that were made to CFInsert.
// Check the length with:
//
//	len(mockedGoRedisClient.CFInsertCalls())
func (mock *GoRedisClientMock) CFInsertCalls() []struct {
	Ctx      context.Context
	Key      string
	Options  *redis.CFInsertOptions
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Options  *redis.CFInsertOptions
		Elements []interface{}
	}
	mock.lockCFInsert.RLock()
	calls = mock.calls.CFInsert
	mock.lockCFInsert.RUnlock()
	return calls
}

// CFInsertNX calls CFInsertNXFunc.
func (mock *GoRedisClientMock) CFInsertNX(ctx context.Context, key string, options *redis.CFInsertOptions, elements ...interface{}) *redis.IntSliceCmd {
	if mock.CFInsertNXFunc == nil {
		panic("GoRedisClientMock.CFInsertNXFunc: method is nil but GoRedisClient.CFInsertNX was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Options  *redis.CFInsertOptions
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Options:  options,
		Elements: elements,
	}
	mock.lockCFInsertNX.Lock()
	mock.calls.CFInsertNX = append(mock.calls.CFInsertNX, callInfo)
	mock.lockCFInsertNX.Unlock()
	return mock.CFInsertNXFunc(ctx, key, options, elements...)
}

// CFInsertNXCalls gets all the calls that were made to CFInsertNX.
// Check the length with:
//
//	len(mockedGoRedisClient.CFInsertNXCalls())
func (mock *GoRedisClientMock) CFInsertNXCalls() []struct {
	Ctx      context.Context
	Key      string
	Options  *redis.CFInsertOptions
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Options  *redis.CFInsertOptions
		Elements []interface{}
	}
	mock.lockCFInsertNX.RLock()
	calls = mock.calls.CFInsertNX
	mock.lockCFInsertNX.RUnlock()
	return calls
}

// CFLoadChunk calls CFLoadChunkFunc.
func (mock *GoRedisClientMock) CFLoadChunk(ctx context.Context, key string, iterator int64, data interface{}) *redis.StatusCmd {
	if mock.CFLoadChunkFunc == nil {
		panic("GoRedisClientMock.CFLoadChunkFunc: method is nil but GoRedisClient.CFLoadChunk was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Iterator int64
		Data     interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Iterator: iterator,
		Data:     data,
	}
	mock.lockCFLoadChunk.Lock()
	mock.calls.CFLoadChunk = append(mock.calls.CFLoadChunk, callInfo)
	mock.lockCFLoadChunk.Unlock()
	return mock.CFLoadChunkFunc(ctx, key, iterator, data)
}

// CFLoadChunkCalls gets all the calls that were made to CFLoadChunk.
// Check the length with:
//
//	len(mockedGoRedisClient.CFLoadChunkCalls())
func (mock *GoRedisClientMock) CFLoadChunkCalls() []struct {
	Ctx      context.Context
	Key      string
	Iterator int64
	Data     interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Iterator int64
		Data     interface{}
	}
	mock.lockCFLoadChunk.RLock()
	calls = mock.calls.CFLoadChunk
	mock.lockCFLoadChunk.RUnlock()
	return calls
}

// CFMExists calls CFMExistsFunc.
func (mock *GoRedisClientMock) CFMExists(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd {
	if mock.CFMExistsFunc == nil {
		panic("GoRedisClientMock.CFMExistsFunc: method is nil but GoRedisClient.CFMExists was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockCFMExists.Lock()
	mock.calls.CFMExists = append(mock.calls.CFMExists, callInfo)
	mock.lockCFMExists.Unlock()
	return mock.CFMExistsFunc(ctx, key, elements...)
}

// CFMExistsCalls gets all the calls that were made to CFMExists.
// Check the length with:
//
//	len(mockedGoRedisClient.CFMExistsCalls())
func (mock *GoRedisClientMock) CFMExistsCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}
	mock.lockCFMExists.RLock()
	calls = mock.calls.CFMExists
	mock.lockCFMExists.RUnlock()
	return calls
}

// CFReserve calls CFReserveFunc.
func (mock *GoRedisClientMock) CFReserve(ctx context.Context, key string, capacity int64) *redis.StatusCmd {
	if mock.CFReserveFunc == nil {
		panic("GoRedisClientMock.CFReserveFunc: method is nil but GoRedisClient.CFReserve was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Capacity int64
	}{
		Ctx:      ctx,
		Key:      key,
		Capacity: capacity,
	}
	mock.lockCFReserve.Lock()
	mock.calls.CFReserve = append(mock.calls.CFReserve, callInfo)
	mock.lockCFReserve.Unlock()
	return mock.CFReserveFunc(ctx, key, capacity)
}

// CFReserveCalls gets all the calls that were made to CFReserve.
// Check the length with:
//
//	len(mockedGoRedisClient.CFReserveCalls())
func (mock *GoRedisClientMock) CFReserveCalls() []struct {
	Ctx      context.Context
	Key      string
	Capacity int64
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Capacity int64
	}
	mock.lockCFReserve.RLock()
	calls = mock.calls.CFReserve
	mock.lockCFReserve.RUnlock()
	return calls
}

// CFReserveBucketSize calls CFReserveBucketSizeFunc.
func (mock *GoRedisClientMock) CFReserveBucketSize(ctx context.Context, key string, capacity int64, bucketsize int64) *redis.StatusCmd {
	if mock.CFReserveBucketSizeFunc == nil {
		panic("GoRedisClientMock.CFReserveBucketSizeFunc: method is nil but GoRedisClient.CFReserveBucketSize was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Capacity   int64
		Bucketsize int64
	}{
		Ctx:        ctx,
		Key:        key,
		Capacity:   capacity,
		Bucketsize: bucketsize,
	}
	mock.lockCFReserveBucketSize.Lock()
	mock.calls.CFReserveBucketSize = append(mock.calls.CFReserveBucketSize, callInfo)
	mock.lockCFReserveBucketSize.Unlock()
	return mock.CFReserveBucketSizeFunc(ctx, key, capacity, bucketsize)
}

// CFReserveBucketSizeCalls gets all the calls that were made to CFReserveBucketSize.
// Check the length with:
//
//	len(mockedGoRedisClient.CFReserveBucketSizeCalls())
func (mock *GoRedisClientMock) CFReserveBucketSizeCalls() []struct {
	Ctx        context.Context
	Key        string
	Capacity   int64
	Bucketsize int64
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Capacity   int64
		Bucketsize int64
	}
	mock.lockCFReserveBucketSize.RLock()
	calls = mock.calls.CFReserveBucketSize
	mock.lockCFReserveBucketSize.RUnlock()
	return calls
}

// CFReserveExpansion calls CFReserveExpansionFunc.
func (mock *GoRedisClientMock) CFReserveExpansion(ctx context.Context, key string, capacity int64, expansion int64) *redis.StatusCmd {
	if mock.CFReserveExpansionFunc == nil {
		panic("GoRedisClientMock.CFReserveExpansionFunc: method is nil but GoRedisClient.CFReserveExpansion was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		Capacity  int64
		Expansion int64
	}{
		Ctx:       ctx,
		Key:       key,
		Capacity:  capacity,
		Expansion: expansion,
	}
	mock.lockCFReserveExpansion.Lock()
	mock.calls.CFReserveExpansion = append(mock.calls.CFReserveExpansion, callInfo)
	mock.lockCFReserveExpansion.Unlock()
	return mock.CFReserveExpansionFunc(ctx, key, capacity, expansion)
}

// CFReserveExpansionCalls gets all the calls that were made to CFReserveExpansion.
// Check the length with:
//
//	len(mockedGoRedisClient.CFReserveExpansionCalls())
func (mock *GoRedisClientMock) CFReserveExpansionCalls() []struct {
	Ctx       context.Context
	Key       string
	Capacity  int64
	Expansion int64
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		Capacity  int64
		Expansion int64
	}
	mock.lockCFReserveExpansion.RLock()
	calls = mock.calls.CFReserveExpansion
	mock.lockCFReserveExpansion.RUnlock()
	return calls
}

// CFReserveMaxIterations calls CFReserveMaxIterationsFunc.
func (mock *GoRedisClientMock) CFReserveMaxIterations(ctx context.Context, key string, capacity int64, maxiterations int64) *redis.StatusCmd {
	if mock.CFReserveMaxIterationsFunc == nil {
		panic("GoRedisClientMock.CFReserveMaxIterationsFunc: method is nil but GoRedisClient.CFReserveMaxIterations was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Key           string
		Capacity      int64
		Maxiterations int64
	}{
		Ctx:           ctx,
		Key:           key,
		Capacity:      capacity,
		Maxiterations: maxiterations,
	}
	mock.lockCFReserveMaxIterations.Lock()
	mock.calls.CFReserveMaxIterations = append(mock.calls.CFReserveMaxIterations, callInfo)
	mock.lockCFReserveMaxIterations.Unlock()
	return mock.CFReserveMaxIterationsFunc(ctx, key, capacity, maxiterations)
}

// CFReserveMaxIterationsCalls gets all the calls that were made to CFReserveMaxIterations.
// Check the length with:
//
//	len(mockedGoRedisClient.CFReserveMaxIterationsCalls())
func (mock *GoRedisClientMock) CFReserveMaxIterationsCalls() []struct {
	Ctx           context.Context
	Key           string
	Capacity      int64
	Maxiterations int64
} {
	var calls []struct {
		Ctx           context.Context
		Key           string
		Capacity      int64
		Maxiterations int64
	}
	mock.lockCFReserveMaxIterations.RLock()
	calls = mock.calls.CFReserveMaxIterations
	mock.lockCFReserveMaxIterations.RUnlock()
	return calls
}

// CFReserveWithArgs calls CFReserveWithArgsFunc.
func (mock *GoRedisClientMock) CFReserveWithArgs(ctx context.Context, key string, options *redis.CFReserveOptions) *redis.StatusCmd {
	if mock.CFReserveWithArgsFunc == nil {
		panic("GoRedisClientMock.CFReserveWithArgsFunc: method is nil but GoRedisClient.CFReserveWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Options *redis.CFReserveOptions
	}{
		Ctx:     ctx,
		Key:     key,
		Options: options,
	}
	mock.lockCFReserveWithArgs.Lock()
	mock.calls.CFReserveWithArgs = append(mock.calls.CFReserveWithArgs, callInfo)
	mock.lockCFReserveWithArgs.Unlock()
	return mock.CFReserveWithArgsFunc(ctx, key, options)
}

// CFReserveWithArgsCalls gets all the calls that were made to CFReserveWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.CFReserveWithArgsCalls())
func (mock *GoRedisClientMock) CFReserveWithArgsCalls() []struct {
	Ctx     context.Context
	Key     string
	Options *redis.CFReserveOptions
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Options *redis.CFReserveOptions
	}
	mock.lockCFReserveWithArgs.RLock()
	calls = mock.calls.CFReserveWithArgs
	mock.lockCFReserveWithArgs.RUnlock()
	return calls
}

// CFScanDump calls CFScanDumpFunc.
func (mock *GoRedisClientMock) CFScanDump(ctx context.Context, key string, iterator int64) *redis.ScanDumpCmd {
	if mock.CFScanDumpFunc == nil {
		panic("GoRedisClientMock.CFScanDumpFunc: method is nil but GoRedisClient.CFScanDump was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Iterator int64
	}{
		Ctx:      ctx,
		Key:      key,
		Iterator: iterator,
	}
	mock.lockCFScanDump.Lock()
	mock.calls.CFScanDump = append(mock.calls.CFScanDump, callInfo)
	mock.lockCFScanDump.Unlock()
	return mock.CFScanDumpFunc(ctx, key, iterator)
}

// CFScanDumpCalls gets all the calls that were made to CFScanDump.
// Check the length with:
//
//	len(mockedGoRedisClient.CFScanDumpCalls())
func (mock *GoRedisClientMock) CFScanDumpCalls() []struct {
	Ctx      context.Context
	Key      string
	Iterator int64
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Iterator int64
	}
	mock.lockCFScanDump.RLock()
	calls = mock.calls.CFScanDump
	mock.lockCFScanDump.RUnlock()
	return calls
}

// CMSIncrBy calls CMSIncrByFunc.
func (mock *GoRedisClientMock) CMSIncrBy(ctx context.Context, key string, elements ...interface{}) *redis.IntSliceCmd {
	if mock.CMSIncrByFunc == nil {
		panic("GoRedisClientMock.CMSIncrByFunc: method is nil but GoRedisClient.CMSIncrBy was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockCMSIncrBy.Lock()
	mock.calls.CMSIncrBy = append(mock.calls.CMSIncrBy, callInfo)
	mock.lockCMSIncrBy.Unlock()
	return mock.CMSIncrByFunc(ctx, key, elements...)
}

// CMSIncrByCalls gets all the calls that were made to CMSIncrBy.
// Check the length with:
//
//	len(mockedGoRedisClient.CMSIncrByCalls())
func (mock *GoRedisClientMock) CMSIncrByCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}
	mock.lockCMSIncrBy.RLock()
	calls = mock.calls.CMSIncrBy
	mock.lockCMSIncrBy.RUnlock()
	return calls
}

// CMSInfo calls CMSInfoFunc.
func (mock *GoRedisClientMock) CMSInfo(ctx context.Context, key string) *redis.CMSInfoCmd {
	if mock.CMSInfoFunc == nil {
		panic("GoRedisClientMock.CMSInfoFunc: method is nil but GoRedisClient.CMSInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockCMSInfo.Lock()
	mock.calls.CMSInfo = append(mock.calls.CMSInfo, callInfo)
	mock.lockCMSInfo.Unlock()
	return mock.CMSInfoFunc(ctx, key)
}

// CMSInfoCalls gets all the calls that were made to CMSInfo.
// Check the length with:
//
//	len(mockedGoRedisClient.CMSInfoCalls())
func (mock *GoRedisClientMock) CMSInfoCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockCMSInfo.RLock()
	calls = mock.calls.CMSInfo
	mock.lockCMSInfo.RUnlock()
	return calls
}

// CMSInitByDim calls CMSInitByDimFunc.
func (mock *GoRedisClientMock) CMSInitByDim(ctx context.Context, key string, width int64, height int64) *redis.StatusCmd {
	if mock.CMSInitByDimFunc == nil {
		panic("GoRedisClientMock.CMSInitByDimFunc: method is nil but GoRedisClient.CMSInitByDim was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Width  int64
		Height int64
	}{
		Ctx:    ctx,
		Key:    key,
		Width:  width,
		Height: height,
	}
	mock.lockCMSInitByDim.Lock()
	mock.calls.CMSInitByDim = append(mock.calls.CMSInitByDim, callInfo)
	mock.lockCMSInitByDim.Unlock()
	return mock.CMSInitByDimFunc(ctx, key, width, height)
}

// CMSInitByDimCalls gets all the calls that were made to CMSInitByDim.
// Check the length with:
//
//	len(mockedGoRedisClient.CMSInitByDimCalls())
func (mock *GoRedisClientMock) CMSInitByDimCalls() []struct {
	Ctx    context.Context
	Key    string
	Width  int64
	Height int64
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Width  int64
		Height int64
	}
	mock.lockCMSInitByDim.RLock()
	calls = mock.calls.CMSInitByDim
	mock.lockCMSInitByDim.RUnlock()
	return calls
}

// CMSInitByProb calls CMSInitByProbFunc.
func (mock *GoRedisClientMock) CMSInitByProb(ctx context.Context, key string, errorRate float64, probability float64) *redis.StatusCmd {
	if mock.CMSInitByProbFunc == nil {
		panic("GoRedisClientMock.CMSInitByProbFunc: method is nil but GoRedisClient.CMSInitByProb was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Key         string
		ErrorRate   float64
		Probability float64
	}{
		Ctx:         ctx,
		Key:         key,
		ErrorRate:   errorRate,
		Probability: probability,
	}
	mock.lockCMSInitByProb.Lock()
	mock.calls.CMSInitByProb = append(mock.calls.CMSInitByProb, callInfo)
	mock.lockCMSInitByProb.Unlock()
	return mock.CMSInitByProbFunc(ctx, key, errorRate, probability)
}

// CMSInitByProbCalls gets all the calls that were made to CMSInitByProb.
// Check the length with:
//
//	len(mockedGoRedisClient.CMSInitByProbCalls())
func (mock *GoRedisClientMock) CMSInitByProbCalls() []struct {
	Ctx         context.Context
	Key         string
	ErrorRate   float64
	Probability float64
} {
	var calls []struct {
		Ctx         context.Context
		Key         string
		ErrorRate   float64
		Probability float64
	}
	mock.lockCMSInitByProb.RLock()
	calls = mock.calls.CMSInitByProb
	mock.lockCMSInitByProb.RUnlock()
	return calls
}

// CMSMerge calls CMSMergeFunc.
func (mock *GoRedisClientMock) CMSMerge(ctx context.Context, destKey string, sourceKeys ...string) *redis.StatusCmd {
	if mock.CMSMergeFunc == nil {
		panic("GoRedisClientMock.CMSMergeFunc: method is nil but GoRedisClient.CMSMerge was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		DestKey    string
		SourceKeys []string
	}{
		Ctx:        ctx,
		DestKey:    destKey,
		SourceKeys: sourceKeys,
	}
	mock.lockCMSMerge.Lock()
	mock.calls.CMSMerge = append(mock.calls.CMSMerge, callInfo)
	mock.lockCMSMerge.Unlock()
	return mock.CMSMergeFunc(ctx, destKey, sourceKeys...)
}

// CMSMergeCalls gets all the calls that were made to CMSMerge.
// Check the length with:
//
//	len(mockedGoRedisClient.CMSMergeCalls())
func (mock *GoRedisClientMock) CMSMergeCalls() []struct {
	Ctx        context.Context
	DestKey    string
	SourceKeys []string
} {
	var calls []struct {
		Ctx        context.Context
		DestKey    string
		SourceKeys []string
	}
	mock.lockCMSMerge.RLock()
	calls = mock.calls.CMSMerge
	mock.lockCMSMerge.RUnlock()
	return calls
}

// CMSMergeWithWeight calls CMSMergeWithWeightFunc.
func (mock *GoRedisClientMock) CMSMergeWithWeight(ctx context.Context, destKey string, sourceKeys map[string]int64) *redis.StatusCmd {
	if mock.CMSMergeWithWeightFunc == nil {
		panic("GoRedisClientMock.CMSMergeWithWeightFunc: method is nil but GoRedisClient.CMSMergeWithWeight was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		DestKey    string
		SourceKeys map[string]int64
	}{
		Ctx:        ctx,
		DestKey:    destKey,
		SourceKeys: sourceKeys,
	}
	mock.lockCMSMergeWithWeight.Lock()
	mock.calls.CMSMergeWithWeight = append(mock.calls.CMSMergeWithWeight, callInfo)
	mock.lockCMSMergeWithWeight.Unlock()
	return mock.CMSMergeWithWeightFunc(ctx, destKey, sourceKeys)
}

// CMSMergeWithWeightCalls gets all the calls that were made to CMSMergeWithWeight.
// Check the length with:
//
//	len(mockedGoRedisClient.CMSMergeWithWeightCalls())
func (mock *GoRedisClientMock) CMSMergeWithWeightCalls() []struct {
	Ctx        context.Context
	DestKey    string
	SourceKeys map[string]int64
} {
	var calls []struct {
		Ctx        context.Context
		DestKey    string
		SourceKeys map[string]int64
	}
	mock.lockCMSMergeWithWeight.RLock()
	calls = mock.calls.CMSMergeWithWeight
	mock.lockCMSMergeWithWeight.RUnlock()
	return calls
}

// CMSQuery calls CMSQueryFunc.
func (mock *GoRedisClientMock) CMSQuery(ctx context.Context, key string, elements ...interface{}) *redis.IntSliceCmd {
	if mock.CMSQueryFunc == nil {
		panic("GoRedisClientMock.CMSQueryFunc: method is nil but GoRedisClient.CMSQuery was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockCMSQuery.Lock()
	mock.calls.CMSQuery = append(mock.calls.CMSQuery, callInfo)
	mock.lockCMSQuery.Unlock()
	return mock.CMSQueryFunc(ctx, key, elements...)
}

// CMSQueryCalls gets all the calls that were made to CMSQuery.
// Check the length with:
//
//	len(mockedGoRedisClient.CMSQueryCalls())
func (mock *GoRedisClientMock) CMSQueryCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}
	mock.lockCMSQuery.RLock()
	calls = mock.calls.CMSQuery
	mock.lockCMSQuery.RUnlock()
	return calls
}

// ClientGetName calls ClientGetNameFunc.
func (mock *GoRedisClientMock) ClientGetName(ctx context.Context) *redis.StringCmd {
	if mock.ClientGetNameFunc == nil {
		panic("GoRedisClientMock.ClientGetNameFunc: method is nil but GoRedisClient.ClientGetName was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClientGetName.Lock()
	mock.calls.ClientGetName = append(mock.calls.ClientGetName, callInfo)
	mock.lockClientGetName.Unlock()
	return mock.ClientGetNameFunc(ctx)
}

// ClientGetNameCalls gets all the calls that were made to ClientGetName.
// Check the length with:
//
//	len(mockedGoRedisClient.ClientGetNameCalls())
func (mock *GoRedisClientMock) ClientGetNameCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClientGetName.RLock()
	calls = mock.calls.ClientGetName
	mock.lockClientGetName.RUnlock()
	return calls
}

// ClientID calls ClientIDFunc.
func (mock *GoRedisClientMock) ClientID(ctx context.Context) *redis.IntCmd {
	if mock.ClientIDFunc == nil {
		panic("GoRedisClientMock.ClientIDFunc: method is nil but GoRedisClient.ClientID was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClientID.Lock()
	mock.calls.ClientID = append(mock.calls.ClientID, callInfo)
	mock.lockClientID.Unlock()
	return mock.ClientIDFunc(ctx)
}

// ClientIDCalls gets all the calls that were made to ClientID.
// Check the length with:
//
//	len(mockedGoRedisClient.ClientIDCalls())
func (mock *GoRedisClientMock) ClientIDCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClientID.RLock()
	calls = mock.calls.ClientID
	mock.lockClientID.RUnlock()
	return calls
}

// ClientInfo calls ClientInfoFunc.
func (mock *GoRedisClientMock) ClientInfo(ctx context.Context) *redis.ClientInfoCmd {
	if mock.ClientInfoFunc == nil {
		panic("GoRedisClientMock.ClientInfoFunc: method is nil but GoRedisClient.ClientInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClientInfo.Lock()
	mock.calls.ClientInfo = append(mock.calls.ClientInfo, callInfo)
	mock.lockClientInfo.Unlock()
	return mock.ClientInfoFunc(ctx)
}

// ClientInfoCalls gets all the calls that were made to ClientInfo.
// Check the length with:
//
//	len(mockedGoRedisClient.ClientInfoCalls())
func (mock *GoRedisClientMock) ClientInfoCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClientInfo.RLock()
	calls = mock.calls.ClientInfo
	mock.lockClientInfo.RUnlock()
	return calls
}

// ClientKill calls ClientKillFunc.
func (mock *GoRedisClientMock) ClientKill(ctx context.Context, ipPort string) *redis.StatusCmd {
	if mock.ClientKillFunc == nil {
		panic("GoRedisClientMock.ClientKillFunc: method is nil but GoRedisClient.ClientKill was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		IpPort string
	}{
		Ctx:    ctx,
		IpPort: ipPort,
	}
	mock.lockClientKill.Lock()
	mock.calls.ClientKill = append(mock.calls.ClientKill, callInfo)
	mock.lockClientKill.Unlock()
	return mock.ClientKillFunc(ctx, ipPort)
}

// ClientKillCalls gets all the calls that were made to ClientKill.
// Check the length with:
//
//	len(mockedGoRedisClient.ClientKillCalls())
func (mock *GoRedisClientMock) ClientKillCalls() []struct {
	Ctx    context.Context
	IpPort string
} {
	var calls []struct {
		Ctx    context.Context
		IpPort string
	}
	mock.lockClientKill.RLock()
	calls = mock.calls.ClientKill
	mock.lockClientKill.RUnlock()
	return calls
}

// ClientKillByFilter calls ClientKillByFilterFunc.
func (mock *GoRedisClientMock) ClientKillByFilter(ctx context.Context, keys ...string) *redis.IntCmd {
	if mock.ClientKillByFilterFunc == nil {
		panic("GoRedisClientMock.ClientKillByFilterFunc: method is nil but GoRedisClient.ClientKillByFilter was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockClientKillByFilter.Lock()
	mock.calls.ClientKillByFilter = append(mock.calls.ClientKillByFilter, callInfo)
	mock.lockClientKillByFilter.Unlock()
	return mock.ClientKillByFilterFunc(ctx, keys...)
}

// ClientKillByFilterCalls gets all the calls that were made to ClientKillByFilter.
// Check the length with:
//
//	len(mockedGoRedisClient.ClientKillByFilterCalls())
func (mock *GoRedisClientMock) ClientKillByFilterCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockClientKillByFilter.RLock()
	calls = mock.calls.ClientKillByFilter
	mock.lockClientKillByFilter.RUnlock()
	return calls
}

// ClientList calls ClientListFunc.
func (mock *GoRedisClientMock) ClientList(ctx context.Context) *redis.StringCmd {
	if mock.ClientListFunc == nil {
		panic("GoRedisClientMock.ClientListFunc: method is nil but GoRedisClient.ClientList was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClientList.Lock()
	mock.calls.ClientList = append(mock.calls.ClientList, callInfo)
	mock.lockClientList.Unlock()
	return mock.ClientListFunc(ctx)
}

// ClientListCalls gets all the calls that were made to ClientList.
// Check the length with:
//
//	len(mockedGoRedisClient.ClientListCalls())
func (mock *GoRedisClientMock) ClientListCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClientList.RLock()
	calls = mock.calls.ClientList
	mock.lockClientList.RUnlock()
	return calls
}

// ClientPause calls ClientPauseFunc.
func (mock *GoRedisClientMock) ClientPause(ctx context.Context, dur time.Duration) *redis.BoolCmd {
	if mock.ClientPauseFunc == nil {
		panic("GoRedisClientMock.ClientPauseFunc: method is nil but GoRedisClient.ClientPause was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Dur time.Duration
	}{
		Ctx: ctx,
		Dur: dur,
	}
	mock.lockClientPause.Lock()
	mock.calls.ClientPause = append(mock.calls.ClientPause, callInfo)
	mock.lockClientPause.Unlock()
	return mock.ClientPauseFunc(ctx, dur)
}

// ClientPauseCalls gets all the calls that were made to ClientPause.
// Check the length with:
//
//	len(mockedGoRedisClient.ClientPauseCalls())
func (mock *GoRedisClientMock) ClientPauseCalls() []struct {
	Ctx context.Context
	Dur time.Duration
} {
	var calls []struct {
		Ctx context.Context
		Dur time.Duration
	}
	mock.lockClientPause.RLock()
	calls = mock.calls.ClientPause
	mock.lockClientPause.RUnlock()
	return calls
}

// ClientUnblock calls ClientUnblockFunc.
func (mock *GoRedisClientMock) ClientUnblock(ctx context.Context, id int64) *redis.IntCmd {
	if mock.ClientUnblockFunc == nil {
		panic("GoRedisClientMock.ClientUnblockFunc: method is nil but GoRedisClient.ClientUnblock was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockClientUnblock.Lock()
	mock.calls.ClientUnblock = append(mock.calls.ClientUnblock, callInfo)
	mock.lockClientUnblock.Unlock()
	return mock.ClientUnblockFunc(ctx, id)
}

// ClientUnblockCalls gets all the calls that were made to ClientUnblock.
// Check the length with:
//
//	len(mockedGoRedisClient.ClientUnblockCalls())
func (mock *GoRedisClientMock) ClientUnblockCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockClientUnblock.RLock()
	calls = mock.calls.ClientUnblock
	mock.lockClientUnblock.RUnlock()
	return calls
}

// ClientUnblockWithError calls ClientUnblockWithErrorFunc.
func (mock *GoRedisClientMock) ClientUnblockWithError(ctx context.Context, id int64) *redis.IntCmd {
	if mock.ClientUnblockWithErrorFunc == nil {
		panic("GoRedisClientMock.ClientUnblockWithErrorFunc: method is nil but GoRedisClient.ClientUnblockWithError was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  int64
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockClientUnblockWithError.Lock()
	mock.calls.ClientUnblockWithError = append(mock.calls.ClientUnblockWithError, callInfo)
	mock.lockClientUnblockWithError.Unlock()
	return mock.ClientUnblockWithErrorFunc(ctx, id)
}

// ClientUnblockWithErrorCalls gets all the calls that were made to ClientUnblockWithError.
// Check the length with:
//
//	len(mockedGoRedisClient.ClientUnblockWithErrorCalls())
func (mock *GoRedisClientMock) ClientUnblockWithErrorCalls() []struct {
	Ctx context.Context
	ID  int64
} {
	var calls []struct {
		Ctx context.Context
		ID  int64
	}
	mock.lockClientUnblockWithError.RLock()
	calls = mock.calls.ClientUnblockWithError
	mock.lockClientUnblockWithError.RUnlock()
	return calls
}

// ClientUnpause calls ClientUnpauseFunc.
func (mock *GoRedisClientMock) ClientUnpause(ctx context.Context) *redis.BoolCmd {
	if mock.ClientUnpauseFunc == nil {
		panic("GoRedisClientMock.ClientUnpauseFunc: method is nil but GoRedisClient.ClientUnpause was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClientUnpause.Lock()
	mock.calls.ClientUnpause = append(mock.calls.ClientUnpause, callInfo)
	mock.lockClientUnpause.Unlock()
	return mock.ClientUnpauseFunc(ctx)
}

// ClientUnpauseCalls gets all the calls that were made to ClientUnpause.
// Check the length with:
//
//	len(mockedGoRedisClient.ClientUnpauseCalls())
func (mock *GoRedisClientMock) ClientUnpauseCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClientUnpause.RLock()
	calls = mock.calls.ClientUnpause
	mock.lockClientUnpause.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *GoRedisClientMock) Close() error {
	if mock.CloseFunc == nil {
		panic("GoRedisClientMock.CloseFunc: method is nil but GoRedisClient.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedGoRedisClient.CloseCalls())
func (mock *GoRedisClientMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// ClusterAddSlots calls ClusterAddSlotsFunc.
func (mock *GoRedisClientMock) ClusterAddSlots(ctx context.Context, slots ...int) *redis.StatusCmd {
	if mock.ClusterAddSlotsFunc == nil {
		panic("GoRedisClientMock.ClusterAddSlotsFunc: method is nil but GoRedisClient.ClusterAddSlots was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Slots []int
	}{
		Ctx:   ctx,
		Slots: slots,
	}
	mock.lockClusterAddSlots.Lock()
	mock.calls.ClusterAddSlots = append(mock.calls.ClusterAddSlots, callInfo)
	mock.lockClusterAddSlots.Unlock()
	return mock.ClusterAddSlotsFunc(ctx, slots...)
}

// ClusterAddSlotsCalls gets all the calls that were made to ClusterAddSlots.
// Check the length with:
//
//	len(mockedGoRedisClient.ClusterAddSlotsCalls())
func (mock *GoRedisClientMock) ClusterAddSlotsCalls() []struct {
	Ctx   context.Context
	Slots []int
} {
	var calls []struct {
		Ctx   context.Context
		Slots []int
	}
	mock.lockClusterAddSlots.RLock()
	calls = mock.calls.ClusterAddSlots
	mock.lockClusterAddSlots.RUnlock()
	return calls
}

// ClusterAddSlotsRange calls ClusterAddSlotsRangeFunc.
func (mock *GoRedisClientMock) ClusterAddSlotsRange(ctx context.Context, min int, max int) *redis.StatusCmd {
	if mock.ClusterAddSlotsRangeFunc == nil {
		panic("GoRedisClientMock.ClusterAddSlotsRangeFunc: method is nil but GoRedisClient.ClusterAddSlotsRange was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Min int
		Max int
	}{
		Ctx: ctx,
		Min: min,
		Max: max,
	}
	mock.lockClusterAddSlotsRange.Lock()
	mock.calls.ClusterAddSlotsRange = append(mock.calls.ClusterAddSlotsRange, callInfo)
	mock.lockClusterAddSlotsRange.Unlock()
	return mock.ClusterAddSlotsRangeFunc(ctx, min, max)
}

// ClusterAddSlotsRangeCalls gets all the calls that were made to ClusterAddSlotsRange.
// Check the length with:
//
//	len(mockedGoRedisClient.ClusterAddSlotsRangeCalls())
func (mock *GoRedisClientMock) ClusterAddSlotsRangeCalls() []struct {
	Ctx context.Context
	Min int
	Max int
} {
	var calls []struct {
		Ctx context.Context
		Min int
		Max int
	}
	mock.lockClusterAddSlotsRange.RLock()
	calls = mock.calls.ClusterAddSlotsRange
	mock.lockClusterAddSlotsRange.RUnlock()
	return calls
}

// ClusterCountFailureReports calls ClusterCountFailureReportsFunc.
func (mock *GoRedisClientMock) ClusterCountFailureReports(ctx context.Context, nodeID string) *redis.IntCmd {
	if mock.ClusterCountFailureReportsFunc == nil {
		panic("GoRedisClientMock.ClusterCountFailureReportsFunc: method is nil but GoRedisClient.ClusterCountFailureReports was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		NodeID string
	}{
		Ctx:    ctx,
		NodeID: nodeID,
	}
	mock.lockClusterCountFailureReports.Lock()
	mock.calls.ClusterCountFailureReports = append(mock.calls.ClusterCountFailureReports, callInfo)
	mock.lockClusterCountFailureReports.Unlock()
	return mock.ClusterCountFailureReportsFunc(ctx, nodeID)
}

// ClusterCountFailureReportsCalls gets all the calls that were made to ClusterCountFailureReports.
// Check the length with:
//
//	len(mockedGoRedisClient.ClusterCountFailureReportsCalls())
func (mock *GoRedisClientMock) ClusterCountFailureReportsCalls() []struct {
	Ctx    context.Context
	NodeID string
} {
	var calls []struct {
		Ctx    context.Context
		NodeID string
	}
	mock.lockClusterCountFailureReports.RLock()
	calls = mock.calls.ClusterCountFailureReports
	mock.lockClusterCountFailureReports.RUnlock()
	return calls
}

// ClusterCountKeysInSlot calls ClusterCountKeysInSlotFunc.
func (mock *GoRedisClientMock) ClusterCountKeysInSlot(ctx context.Context, slot int) *redis.IntCmd {
	if mock.ClusterCountKeysInSlotFunc == nil {
		panic("GoRedisClientMock.ClusterCountKeysInSlotFunc: method is nil but GoRedisClient.ClusterCountKeysInSlot was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Slot int
	}{
		Ctx:  ctx,
		Slot: slot,
	}
	mock.lockClusterCountKeysInSlot.Lock()
	mock.calls.ClusterCountKeysInSlot = append(mock.calls.ClusterCountKeysInSlot, callInfo)
	mock.lockClusterCountKeysInSlot.Unlock()
	return mock.ClusterCountKeysInSlotFunc(ctx, slot)
}

// ClusterCountKeysInSlotCalls gets all the calls that were made to ClusterCountKeysInSlot.
// Check the length with:
//
//	len(mockedGoRedisClient.ClusterCountKeysInSlotCalls())
func (mock *GoRedisClientMock) ClusterCountKeysInSlotCalls() []struct {
	Ctx  context.Context
	Slot int
} {
	var calls []struct {
		Ctx  context.Context
		Slot int
	}
	mock.lockClusterCountKeysInSlot.RLock()
	calls = mock.calls.ClusterCountKeysInSlot
	mock.lockClusterCountKeysInSlot.RUnlock()
	return calls
}

// ClusterDelSlots calls ClusterDelSlotsFunc.
func (mock *GoRedisClientMock) ClusterDelSlots(ctx context.Context, slots ...int) *redis.StatusCmd {
	if mock.ClusterDelSlotsFunc == nil {
		panic("GoRedisClientMock.ClusterDelSlotsFunc: method is nil but GoRedisClient.ClusterDelSlots was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Slots []int
	}{
		Ctx:   ctx,
		Slots: slots,
	}
	mock.lockClusterDelSlots.Lock()
	mock.calls.ClusterDelSlots = append(mock.calls.ClusterDelSlots, callInfo)
	mock.lockClusterDelSlots.Unlock()
	return mock.ClusterDelSlotsFunc(ctx, slots...)
}

// ClusterDelSlotsCalls gets all the calls that were made to ClusterDelSlots.
// Check the length with:
//
//	len(mockedGoRedisClient.ClusterDelSlotsCalls())
func (mock *GoRedisClientMock) ClusterDelSlotsCalls() []struct {
	Ctx   context.Context
	Slots []int
} {
	var calls []struct {
		Ctx   context.Context
		Slots []int
	}
	mock.lockClusterDelSlots.RLock()
	calls = mock.calls.ClusterDelSlots
	mock.lockClusterDelSlots.RUnlock()
	return calls
}

// ClusterDelSlotsRange calls ClusterDelSlotsRangeFunc.
func (mock *GoRedisClientMock) ClusterDelSlotsRange(ctx context.Context, min int, max int) *redis.StatusCmd {
	if mock.ClusterDelSlotsRangeFunc == nil {
		panic("GoRedisClientMock.ClusterDelSlotsRangeFunc: method is nil but GoRedisClient.ClusterDelSlotsRange was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Min int
		Max int
	}{
		Ctx: ctx,
		Min: min,
		Max: max,
	}
	mock.lockClusterDelSlotsRange.Lock()
	mock.calls.ClusterDelSlotsRange = append(mock.calls.ClusterDelSlotsRange, callInfo)
	mock.lockClusterDelSlotsRange.Unlock()
	return mock.ClusterDelSlotsRangeFunc(ctx, min, max)
}

// ClusterDelSlotsRangeCalls gets all the calls that were made to ClusterDelSlotsRange.
// Check the length with:
//
//	len(mockedGoRedisClient.ClusterDelSlotsRangeCalls())
func (mock *GoRedisClientMock) ClusterDelSlotsRangeCalls() []struct {
	Ctx context.Context
	Min int
	Max int
} {
	var calls []struct {
		Ctx context.Context
		Min int
		Max int
	}
	mock.lockClusterDelSlotsRange.RLock()
	calls = mock.calls.ClusterDelSlotsRange
	mock.lockClusterDelSlotsRange.RUnlock()
	return calls
}

// ClusterFailover calls ClusterFailoverFunc.
func (mock *GoRedisClientMock) ClusterFailover(ctx context.Context) *redis.StatusCmd {
	if mock.ClusterFailoverFunc == nil {
		panic("GoRedisClientMock.ClusterFailoverFunc: method is nil but GoRedisClient.ClusterFailover was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClusterFailover.Lock()
	mock.calls.ClusterFailover = append(mock.calls.ClusterFailover, callInfo)
	mock.lockClusterFailover.Unlock()
	return mock.ClusterFailoverFunc(ctx)
}

// ClusterFailoverCalls gets all the calls that were made to ClusterFailover.
// Check the length with:
//
//	len(mockedGoRedisClient.ClusterFailoverCalls())
func (mock *GoRedisClientMock) ClusterFailoverCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClusterFailover.RLock()
	calls = mock.calls.ClusterFailover
	mock.lockClusterFailover.RUnlock()
	return calls
}

// ClusterForget calls ClusterForgetFunc.
func (mock *GoRedisClientMock) ClusterForget(ctx context.Context, nodeID string) *redis.StatusCmd {
	if mock.ClusterForgetFunc == nil {
		panic("GoRedisClientMock.ClusterForgetFunc: method is nil but GoRedisClient.ClusterForget was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		NodeID string
	}{
		Ctx:    ctx,
		NodeID: nodeID,
	}
	mock.lockClusterForget.Lock()
	mock.calls.ClusterForget = append(mock.calls.ClusterForget, callInfo)
	mock.lockClusterForget.Unlock()
	return mock.ClusterForgetFunc(ctx, nodeID)
}

// ClusterForgetCalls gets all the calls that were made to ClusterForget.
// Check the length with:
//
//	len(mockedGoRedisClient.ClusterForgetCalls())
func (mock *GoRedisClientMock) ClusterForgetCalls() []struct {
	Ctx    context.Context
	NodeID string
} {
	var calls []struct {
		Ctx    context.Context
		NodeID string
	}
	mock.lockClusterForget.RLock()
	calls = mock.calls.ClusterForget
	mock.lockClusterForget.RUnlock()
	return calls
}

// ClusterGetKeysInSlot calls ClusterGetKeysInSlotFunc.
func (mock *GoRedisClientMock) ClusterGetKeysInSlot(ctx context.Context, slot int, count int) *redis.StringSliceCmd {
	if mock.ClusterGetKeysInSlotFunc == nil {
		panic("GoRedisClientMock.ClusterGetKeysInSlotFunc: method is nil but GoRedisClient.ClusterGetKeysInSlot was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Slot  int
		Count int
	}{
		Ctx:   ctx,
		Slot:  slot,
		Count: count,
	}
	mock.lockClusterGetKeysInSlot.Lock()
	mock.calls.ClusterGetKeysInSlot = append(mock.calls.ClusterGetKeysInSlot, callInfo)
	mock.lockClusterGetKeysInSlot.Unlock()
	return mock.ClusterGetKeysInSlotFunc(ctx, slot, count)
}

// ClusterGetKeysInSlotCalls gets all the calls that were made to ClusterGetKeysInSlot.
// Check the length with:
//
//	len(mockedGoRedisClient.ClusterGetKeysInSlotCalls())
func (mock *GoRedisClientMock) ClusterGetKeysInSlotCalls() []struct {
	Ctx   context.Context
	Slot  int
	Count int
} {
	var calls []struct {
		Ctx   context.Context
		Slot  int
		Count int
	}
	mock.lockClusterGetKeysInSlot.RLock()
	calls = mock.calls.ClusterGetKeysInSlot
	mock.lockClusterGetKeysInSlot.RUnlock()
	return calls
}

// ClusterInfo calls ClusterInfoFunc.
func (mock *GoRedisClientMock) ClusterInfo(ctx context.Context) *redis.StringCmd {
	if mock.ClusterInfoFunc == nil {
		panic("GoRedisClientMock.ClusterInfoFunc: method is nil but GoRedisClient.ClusterInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClusterInfo.Lock()
	mock.calls.ClusterInfo = append(mock.calls.ClusterInfo, callInfo)
	mock.lockClusterInfo.Unlock()
	return mock.ClusterInfoFunc(ctx)
}

// ClusterInfoCalls gets all the calls that were made to ClusterInfo.
// Check the length with:
//
//	len(mockedGoRedisClient.ClusterInfoCalls())
func (mock *GoRedisClientMock) ClusterInfoCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClusterInfo.RLock()
	calls = mock.calls.ClusterInfo
	mock.lockClusterInfo.RUnlock()
	return calls
}

// ClusterKeySlot calls ClusterKeySlotFunc.
func (mock *GoRedisClientMock) ClusterKeySlot(ctx context.Context, key string) *redis.IntCmd {
	if mock.ClusterKeySlotFunc == nil {
		panic("GoRedisClientMock.ClusterKeySlotFunc: method is nil but GoRedisClient.ClusterKeySlot was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockClusterKeySlot.Lock()
	mock.calls.ClusterKeySlot = append(mock.calls.ClusterKeySlot, callInfo)
	mock.lockClusterKeySlot.Unlock()
	return mock.ClusterKeySlotFunc(ctx, key)
}

// ClusterKeySlotCalls gets all the calls that were made to ClusterKeySlot.
// Check the length with:
//
//	len(mockedGoRedisClient.ClusterKeySlotCalls())
func (mock *GoRedisClientMock) ClusterKeySlotCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockClusterKeySlot.RLock()
	calls = mock.calls.ClusterKeySlot
	mock.lockClusterKeySlot.RUnlock()
	return calls
}

// ClusterLinks calls ClusterLinksFunc.
func (mock *GoRedisClientMock) ClusterLinks(ctx context.Context) *redis.ClusterLinksCmd {
	if mock.ClusterLinksFunc == nil {
		panic("GoRedisClientMock.ClusterLinksFunc: method is nil but GoRedisClient.ClusterLinks was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClusterLinks.Lock()
	mock.calls.ClusterLinks = append(mock.calls.ClusterLinks, callInfo)
	mock.lockClusterLinks.Unlock()
	return mock.ClusterLinksFunc(ctx)
}

// ClusterLinksCalls gets all the calls that were made to ClusterLinks.
// Check the length with:
//
//	len(mockedGoRedisClient.ClusterLinksCalls())
func (mock *GoRedisClientMock) ClusterLinksCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClusterLinks.RLock()
	calls = mock.calls.ClusterLinks
	mock.lockClusterLinks.RUnlock()
	return calls
}

// ClusterMeet calls ClusterMeetFunc.
func (mock *GoRedisClientMock) ClusterMeet(ctx context.Context, host string, port string) *redis.StatusCmd {
	if mock.ClusterMeetFunc == nil {
		panic("GoRedisClientMock.ClusterMeetFunc: method is nil but GoRedisClient.ClusterMeet was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Host string
		Port string
	}{
		Ctx:  ctx,
		Host: host,
		Port: port,
	}
	mock.lockClusterMeet.Lock()
	mock.calls.ClusterMeet = append(mock.calls.ClusterMeet, callInfo)
	mock.lockClusterMeet.Unlock()
	return mock.ClusterMeetFunc(ctx, host, port)
}

// ClusterMeetCalls gets all the calls that were made to ClusterMeet.
// Check the length with:
//
//	len(mockedGoRedisClient.ClusterMeetCalls())
func (mock *GoRedisClientMock) ClusterMeetCalls() []struct {
	Ctx  context.Context
	Host string
	Port string
} {
	var calls []struct {
		Ctx  context.Context
		Host string
		Port string
	}
	mock.lockClusterMeet.RLock()
	calls = mock.calls.ClusterMeet
	mock.lockClusterMeet.RUnlock()
	return calls
}

// ClusterMyID calls ClusterMyIDFunc.
func (mock *GoRedisClientMock) ClusterMyID(ctx context.Context) *redis.StringCmd {
	if mock.ClusterMyIDFunc == nil {
		panic("GoRedisClientMock.ClusterMyIDFunc: method is nil but GoRedisClient.ClusterMyID was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClusterMyID.Lock()
	mock.calls.ClusterMyID = append(mock.calls.ClusterMyID, callInfo)
	mock.lockClusterMyID.Unlock()
	return mock.ClusterMyIDFunc(ctx)
}

// ClusterMyIDCalls gets all the calls that were made to ClusterMyID.
// Check the length with:
//
//	len(mockedGoRedisClient.ClusterMyIDCalls())
func (mock *GoRedisClientMock) ClusterMyIDCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClusterMyID.RLock()
	calls = mock.calls.ClusterMyID
	mock.lockClusterMyID.RUnlock()
	return calls
}

// ClusterMyShardID calls ClusterMyShardIDFunc.
func (mock *GoRedisClientMock) ClusterMyShardID(ctx context.Context) *redis.StringCmd {
	if mock.ClusterMyShardIDFunc == nil {
		panic("GoRedisClientMock.ClusterMyShardIDFunc: method is nil but GoRedisClient.ClusterMyShardID was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClusterMyShardID.Lock()
	mock.calls.ClusterMyShardID = append(mock.calls.ClusterMyShardID, callInfo)
	mock.lockClusterMyShardID.Unlock()
	return mock.ClusterMyShardIDFunc(ctx)
}

// ClusterMyShardIDCalls gets all the calls that were made to ClusterMyShardID.
// Check the length with:
//
//	len(mockedGoRedisClient.ClusterMyShardIDCalls())
func (mock *GoRedisClientMock) ClusterMyShardIDCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClusterMyShardID.RLock()
	calls = mock.calls.ClusterMyShardID
	mock.lockClusterMyShardID.RUnlock()
	return calls
}

// ClusterNodes calls ClusterNodesFunc.
func (mock *GoRedisClientMock) ClusterNodes(ctx context.Context) *redis.StringCmd {
	if mock.ClusterNodesFunc == nil {
		panic("GoRedisClientMock.ClusterNodesFunc: method is nil but GoRedisClient.ClusterNodes was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClusterNodes.Lock()
	mock.calls.ClusterNodes = append(mock.calls.ClusterNodes, callInfo)
	mock.lockClusterNodes.Unlock()
	return mock.ClusterNodesFunc(ctx)
}

// ClusterNodesCalls gets all the calls that were made to ClusterNodes.
// Check the length with:
//
//	len(mockedGoRedisClient.ClusterNodesCalls())
func (mock *GoRedisClientMock) ClusterNodesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClusterNodes.RLock()
	calls = mock.calls.ClusterNodes
	mock.lockClusterNodes.RUnlock()
	return calls
}

// ClusterReplicate calls ClusterReplicateFunc.
func (mock *GoRedisClientMock) ClusterReplicate(ctx context.Context, nodeID string) *redis.StatusCmd {
	if mock.ClusterReplicateFunc == nil {
		panic("GoRedisClientMock.ClusterReplicateFunc: method is nil but GoRedisClient.ClusterReplicate was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		NodeID string
	}{
		Ctx:    ctx,
		NodeID: nodeID,
	}
	mock.lockClusterReplicate.Lock()
	mock.calls.ClusterReplicate = append(mock.calls.ClusterReplicate, callInfo)
	mock.lockClusterReplicate.Unlock()
	return mock.ClusterReplicateFunc(ctx, nodeID)
}

// ClusterReplicateCalls gets all the calls that were made to ClusterReplicate.
// Check the length with:
//
//	len(mockedGoRedisClient.ClusterReplicateCalls())
func (mock *GoRedisClientMock) ClusterReplicateCalls() []struct {
	Ctx    context.Context
	NodeID string
} {
	var calls []struct {
		Ctx    context.Context
		NodeID string
	}
	mock.lockClusterReplicate.RLock()
	calls = mock.calls.ClusterReplicate
	mock.lockClusterReplicate.RUnlock()
	return calls
}

// ClusterResetHard calls ClusterResetHardFunc.
func (mock *GoRedisClientMock) ClusterResetHard(ctx context.Context) *redis.StatusCmd {
	if mock.ClusterResetHardFunc == nil {
		panic("GoRedisClientMock.ClusterResetHardFunc: method is nil but GoRedisClient.ClusterResetHard was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClusterResetHard.Lock()
	mock.calls.ClusterResetHard = append(mock.calls.ClusterResetHard, callInfo)
	mock.lockClusterResetHard.Unlock()
	return mock.ClusterResetHardFunc(ctx)
}

// ClusterResetHardCalls gets all the calls that were made to ClusterResetHard.
// Check the length with:
//
//	len(mockedGoRedisClient.ClusterResetHardCalls())
func (mock *GoRedisClientMock) ClusterResetHardCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClusterResetHard.RLock()
	calls = mock.calls.ClusterResetHard
	mock.lockClusterResetHard.RUnlock()
	return calls
}

// ClusterResetSoft calls ClusterResetSoftFunc.
func (mock *GoRedisClientMock) ClusterResetSoft(ctx context.Context) *redis.StatusCmd {
	if mock.ClusterResetSoftFunc == nil {
		panic("GoRedisClientMock.ClusterResetSoftFunc: method is nil but GoRedisClient.ClusterResetSoft was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClusterResetSoft.Lock()
	mock.calls.ClusterResetSoft = append(mock.calls.ClusterResetSoft, callInfo)
	mock.lockClusterResetSoft.Unlock()
	return mock.ClusterResetSoftFunc(ctx)
}

// ClusterResetSoftCalls gets all the calls that were made to ClusterResetSoft.
// Check the length with:
//
//	len(mockedGoRedisClient.ClusterResetSoftCalls())
func (mock *GoRedisClientMock) ClusterResetSoftCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClusterResetSoft.RLock()
	calls = mock.calls.ClusterResetSoft
	mock.lockClusterResetSoft.RUnlock()
	return calls
}

// ClusterSaveConfig calls ClusterSaveConfigFunc.
func (mock *GoRedisClientMock) ClusterSaveConfig(ctx context.Context) *redis.StatusCmd {
	if mock.ClusterSaveConfigFunc == nil {
		panic("GoRedisClientMock.ClusterSaveConfigFunc: method is nil but GoRedisClient.ClusterSaveConfig was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClusterSaveConfig.Lock()
	mock.calls.ClusterSaveConfig = append(mock.calls.ClusterSaveConfig, callInfo)
	mock.lockClusterSaveConfig.Unlock()
	return mock.ClusterSaveConfigFunc(ctx)
}

// ClusterSaveConfigCalls gets all the calls that were made to ClusterSaveConfig.
// Check the length with:
//
//	len(mockedGoRedisClient.ClusterSaveConfigCalls())
func (mock *GoRedisClientMock) ClusterSaveConfigCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClusterSaveConfig.RLock()
	calls = mock.calls.ClusterSaveConfig
	mock.lockClusterSaveConfig.RUnlock()
	return calls
}

// ClusterShards calls ClusterShardsFunc.
func (mock *GoRedisClientMock) ClusterShards(ctx context.Context) *redis.ClusterShardsCmd {
	if mock.ClusterShardsFunc == nil {
		panic("GoRedisClientMock.ClusterShardsFunc: method is nil but GoRedisClient.ClusterShards was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClusterShards.Lock()
	mock.calls.ClusterShards = append(mock.calls.ClusterShards, callInfo)
	mock.lockClusterShards.Unlock()
	return mock.ClusterShardsFunc(ctx)
}

// ClusterShardsCalls gets all the calls that were made to ClusterShards.
// Check the length with:
//
//	len(mockedGoRedisClient.ClusterShardsCalls())
func (mock *GoRedisClientMock) ClusterShardsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClusterShards.RLock()
	calls = mock.calls.ClusterShards
	mock.lockClusterShards.RUnlock()
	return calls
}

// ClusterSlaves calls ClusterSlavesFunc.
func (mock *GoRedisClientMock) ClusterSlaves(ctx context.Context, nodeID string) *redis.StringSliceCmd {
	if mock.ClusterSlavesFunc == nil {
		panic("GoRedisClientMock.ClusterSlavesFunc: method is nil but GoRedisClient.ClusterSlaves was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		NodeID string
	}{
		Ctx:    ctx,
		NodeID: nodeID,
	}
	mock.lockClusterSlaves.Lock()
	mock.calls.ClusterSlaves = append(mock.calls.ClusterSlaves, callInfo)
	mock.lockClusterSlaves.Unlock()
	return mock.ClusterSlavesFunc(ctx, nodeID)
}

// ClusterSlavesCalls gets all the calls that were made to ClusterSlaves.
// Check the length with:
//
//	len(mockedGoRedisClient.ClusterSlavesCalls())
func (mock *GoRedisClientMock) ClusterSlavesCalls() []struct {
	Ctx    context.Context
	NodeID string
} {
	var calls []struct {
		Ctx    context.Context
		NodeID string
	}
	mock.lockClusterSlaves.RLock()
	calls = mock.calls.ClusterSlaves
	mock.lockClusterSlaves.RUnlock()
	return calls
}

// ClusterSlots calls ClusterSlotsFunc.
func (mock *GoRedisClientMock) ClusterSlots(ctx context.Context) *redis.ClusterSlotsCmd {
	if mock.ClusterSlotsFunc == nil {
		panic("GoRedisClientMock.ClusterSlotsFunc: method is nil but GoRedisClient.ClusterSlots was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockClusterSlots.Lock()
	mock.calls.ClusterSlots = append(mock.calls.ClusterSlots, callInfo)
	mock.lockClusterSlots.Unlock()
	return mock.ClusterSlotsFunc(ctx)
}

// ClusterSlotsCalls gets all the calls that were made to ClusterSlots.
// Check the length with:
//
//	len(mockedGoRedisClient.ClusterSlotsCalls())
func (mock *GoRedisClientMock) ClusterSlotsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockClusterSlots.RLock()
	calls = mock.calls.ClusterSlots
	mock.lockClusterSlots.RUnlock()
	return calls
}

// Command calls CommandFunc.
func (mock *GoRedisClientMock) Command(ctx context.Context) *redis.CommandsInfoCmd {
	if mock.CommandFunc == nil {
		panic("GoRedisClientMock.CommandFunc: method is nil but GoRedisClient.Command was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockCommand.Lock()
	mock.calls.Command = append(mock.calls.Command, callInfo)
	mock.lockCommand.Unlock()
	return mock.CommandFunc(ctx)
}

// CommandCalls gets all the calls that were made to Command.
// Check the length with:
//
//	len(mockedGoRedisClient.CommandCalls())
func (mock *GoRedisClientMock) CommandCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockCommand.RLock()
	calls = mock.calls.Command
	mock.lockCommand.RUnlock()
	return calls
}

// CommandGetKeys calls CommandGetKeysFunc.
func (mock *GoRedisClientMock) CommandGetKeys(ctx context.Context, commands ...interface{}) *redis.StringSliceCmd {
	if mock.CommandGetKeysFunc == nil {
		panic("GoRedisClientMock.CommandGetKeysFunc: method is nil but GoRedisClient.CommandGetKeys was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Commands []interface{}
	}{
		Ctx:      ctx,
		Commands: commands,
	}
	mock.lockCommandGetKeys.Lock()
	mock.calls.CommandGetKeys = append(mock.calls.CommandGetKeys, callInfo)
	mock.lockCommandGetKeys.Unlock()
	return mock.CommandGetKeysFunc(ctx, commands...)
}

// CommandGetKeysCalls gets all the calls that were made to CommandGetKeys.
// Check the length with:
//
//	len(mockedGoRedisClient.CommandGetKeysCalls())
func (mock *GoRedisClientMock) CommandGetKeysCalls() []struct {
	Ctx      context.Context
	Commands []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Commands []interface{}
	}
	mock.lockCommandGetKeys.RLock()
	calls = mock.calls.CommandGetKeys
	mock.lockCommandGetKeys.RUnlock()
	return calls
}

// CommandGetKeysAndFlags calls CommandGetKeysAndFlagsFunc.
func (mock *GoRedisClientMock) CommandGetKeysAndFlags(ctx context.Context, commands ...interface{}) *redis.KeyFlagsCmd {
	if mock.CommandGetKeysAndFlagsFunc == nil {
		panic("GoRedisClientMock.CommandGetKeysAndFlagsFunc: method is nil but GoRedisClient.CommandGetKeysAndFlags was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Commands []interface{}
	}{
		Ctx:      ctx,
		Commands: commands,
	}
	mock.lockCommandGetKeysAndFlags.Lock()
	mock.calls.CommandGetKeysAndFlags = append(mock.calls.CommandGetKeysAndFlags, callInfo)
	mock.lockCommandGetKeysAndFlags.Unlock()
	return mock.CommandGetKeysAndFlagsFunc(ctx, commands...)
}

// CommandGetKeysAndFlagsCalls gets all the calls that were made to CommandGetKeysAndFlags.
// Check the length with:
//
//	len(mockedGoRedisClient.CommandGetKeysAndFlagsCalls())
func (mock *GoRedisClientMock) CommandGetKeysAndFlagsCalls() []struct {
	Ctx      context.Context
	Commands []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Commands []interface{}
	}
	mock.lockCommandGetKeysAndFlags.RLock()
	calls = mock.calls.CommandGetKeysAndFlags
	mock.lockCommandGetKeysAndFlags.RUnlock()
	return calls
}

// CommandList calls CommandListFunc.
func (mock *GoRedisClientMock) CommandList(ctx context.Context, filter *redis.FilterBy) *redis.StringSliceCmd {
	if mock.CommandListFunc == nil {
		panic("GoRedisClientMock.CommandListFunc: method is nil but GoRedisClient.CommandList was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Filter *redis.FilterBy
	}{
		Ctx:    ctx,
		Filter: filter,
	}
	mock.lockCommandList.Lock()
	mock.calls.CommandList = append(mock.calls.CommandList, callInfo)
	mock.lockCommandList.Unlock()
	return mock.CommandListFunc(ctx, filter)
}

// CommandListCalls gets all the calls that were made to CommandList.
// Check the length with:
//
//	len(mockedGoRedisClient.CommandListCalls())
func (mock *GoRedisClientMock) CommandListCalls() []struct {
	Ctx    context.Context
	Filter *redis.FilterBy
} {
	var calls []struct {
		Ctx    context.Context
		Filter *redis.FilterBy
	}
	mock.lockCommandList.RLock()
	calls = mock.calls.CommandList
	mock.lockCommandList.RUnlock()
	return calls
}

// ConfigGet calls ConfigGetFunc.
func (mock *GoRedisClientMock) ConfigGet(ctx context.Context, parameter string) *redis.MapStringStringCmd {
	if mock.ConfigGetFunc == nil {
		panic("GoRedisClientMock.ConfigGetFunc: method is nil but GoRedisClient.ConfigGet was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Parameter string
	}{
		Ctx:       ctx,
		Parameter: parameter,
	}
	mock.lockConfigGet.Lock()
	mock.calls.ConfigGet = append(mock.calls.ConfigGet, callInfo)
	mock.lockConfigGet.Unlock()
	return mock.ConfigGetFunc(ctx, parameter)
}

// ConfigGetCalls gets all the calls that were made to ConfigGet.
// Check the length with:
//
//	len(mockedGoRedisClient.ConfigGetCalls())
func (mock *GoRedisClientMock) ConfigGetCalls() []struct {
	Ctx       context.Context
	Parameter string
} {
	var calls []struct {
		Ctx       context.Context
		Parameter string
	}
	mock.lockConfigGet.RLock()
	calls = mock.calls.ConfigGet
	mock.lockConfigGet.RUnlock()
	return calls
}

// ConfigResetStat calls ConfigResetStatFunc.
func (mock *GoRedisClientMock) ConfigResetStat(ctx context.Context) *redis.StatusCmd {
	if mock.ConfigResetStatFunc == nil {
		panic("GoRedisClientMock.ConfigResetStatFunc: method is nil but GoRedisClient.ConfigResetStat was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockConfigResetStat.Lock()
	mock.calls.ConfigResetStat = append(mock.calls.ConfigResetStat, callInfo)
	mock.lockConfigResetStat.Unlock()
	return mock.ConfigResetStatFunc(ctx)
}

// ConfigResetStatCalls gets all the calls that were made to ConfigResetStat.
// Check the length with:
//
//	len(mockedGoRedisClient.ConfigResetStatCalls())
func (mock *GoRedisClientMock) ConfigResetStatCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockConfigResetStat.RLock()
	calls = mock.calls.ConfigResetStat
	mock.lockConfigResetStat.RUnlock()
	return calls
}

// ConfigRewrite calls ConfigRewriteFunc.
func (mock *GoRedisClientMock) ConfigRewrite(ctx context.Context) *redis.StatusCmd {
	if mock.ConfigRewriteFunc == nil {
		panic("GoRedisClientMock.ConfigRewriteFunc: method is nil but GoRedisClient.ConfigRewrite was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockConfigRewrite.Lock()
	mock.calls.ConfigRewrite = append(mock.calls.ConfigRewrite, callInfo)
	mock.lockConfigRewrite.Unlock()
	return mock.ConfigRewriteFunc(ctx)
}

// ConfigRewriteCalls gets all the calls that were made to ConfigRewrite.
// Check the length with:
//
//	len(mockedGoRedisClient.ConfigRewriteCalls())
func (mock *GoRedisClientMock) ConfigRewriteCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockConfigRewrite.RLock()
	calls = mock.calls.ConfigRewrite
	mock.lockConfigRewrite.RUnlock()
	return calls
}

// ConfigSet calls ConfigSetFunc.
func (mock *GoRedisClientMock) ConfigSet(ctx context.Context, parameter string, value string) *redis.StatusCmd {
	if mock.ConfigSetFunc == nil {
		panic("GoRedisClientMock.ConfigSetFunc: method is nil but GoRedisClient.ConfigSet was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Parameter string
		Value     string
	}{
		Ctx:       ctx,
		Parameter: parameter,
		Value:     value,
	}
	mock.lockConfigSet.Lock()
	mock.calls.ConfigSet = append(mock.calls.ConfigSet, callInfo)
	mock.lockConfigSet.Unlock()
	return mock.ConfigSetFunc(ctx, parameter, value)
}

// ConfigSetCalls gets all the calls that were made to ConfigSet.
// Check the length with:
//
//	len(mockedGoRedisClient.ConfigSetCalls())
func (mock *GoRedisClientMock) ConfigSetCalls() []struct {
	Ctx       context.Context
	Parameter string
	Value     string
} {
	var calls []struct {
		Ctx       context.Context
		Parameter string
		Value     string
	}
	mock.lockConfigSet.RLock()
	calls = mock.calls.ConfigSet
	mock.lockConfigSet.RUnlock()
	return calls
}

// Copy calls CopyFunc.
func (mock *GoRedisClientMock) Copy(ctx context.Context, sourceKey string, destKey string, db int, replace bool) *redis.IntCmd {
	if mock.CopyFunc == nil {
		panic("GoRedisClientMock.CopyFunc: method is nil but GoRedisClient.Copy was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		SourceKey string
		DestKey   string
		Db        int
		Replace   bool
	}{
		Ctx:       ctx,
		SourceKey: sourceKey,
		DestKey:   destKey,
		Db:        db,
		Replace:   replace,
	}
	mock.lockCopy.Lock()
	mock.calls.Copy = append(mock.calls.Copy, callInfo)
	mock.lockCopy.Unlock()
	return mock.CopyFunc(ctx, sourceKey, destKey, db, replace)
}

// CopyCalls gets all the calls that were made to Copy.
// Check the length with:
//
//	len(mockedGoRedisClient.CopyCalls())
func (mock *GoRedisClientMock) CopyCalls() []struct {
	Ctx       context.Context
	SourceKey string
	DestKey   string
	Db        int
	Replace   bool
} {
	var calls []struct {
		Ctx       context.Context
		SourceKey string
		DestKey   string
		Db        int
		Replace   bool
	}
	mock.lockCopy.RLock()
	calls = mock.calls.Copy
	mock.lockCopy.RUnlock()
	return calls
}

// DBSize calls DBSizeFunc.
func (mock *GoRedisClientMock) DBSize(ctx context.Context) *redis.IntCmd {
	if mock.DBSizeFunc == nil {
		panic("GoRedisClientMock.DBSizeFunc: method is nil but GoRedisClient.DBSize was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockDBSize.Lock()
	mock.calls.DBSize = append(mock.calls.DBSize, callInfo)
	mock.lockDBSize.Unlock()
	return mock.DBSizeFunc(ctx)
}

// DBSizeCalls gets all the calls that were made to DBSize.
// Check the length with:
//
//	len(mockedGoRedisClient.DBSizeCalls())
func (mock *GoRedisClientMock) DBSizeCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockDBSize.RLock()
	calls = mock.calls.DBSize
	mock.lockDBSize.RUnlock()
	return calls
}

// DebugObject calls DebugObjectFunc.
func (mock *GoRedisClientMock) DebugObject(ctx context.Context, key string) *redis.StringCmd {
	if mock.DebugObjectFunc == nil {
		panic("GoRedisClientMock.DebugObjectFunc: method is nil but GoRedisClient.DebugObject was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockDebugObject.Lock()
	mock.calls.DebugObject = append(mock.calls.DebugObject, callInfo)
	mock.lockDebugObject.Unlock()
	return mock.DebugObjectFunc(ctx, key)
}

// DebugObjectCalls gets all the calls that were made to DebugObject.
// Check the length with:
//
//	len(mockedGoRedisClient.DebugObjectCalls())
func (mock *GoRedisClientMock) DebugObjectCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockDebugObject.RLock()
	calls = mock.calls.DebugObject
	mock.lockDebugObject.RUnlock()
	return calls
}

// Decr calls DecrFunc.
func (mock *GoRedisClientMock) Decr(ctx context.Context, key string) *redis.IntCmd {
	if mock.DecrFunc == nil {
		panic("GoRedisClientMock.DecrFunc: method is nil but GoRedisClient.Decr was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockDecr.Lock()
	mock.calls.Decr = append(mock.calls.Decr, callInfo)
	mock.lockDecr.Unlock()
	return mock.DecrFunc(ctx, key)
}

// DecrCalls gets all the calls that were made to Decr.
// Check the length with:
//
//	len(mockedGoRedisClient.DecrCalls())
func (mock *GoRedisClientMock) DecrCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockDecr.RLock()
	calls = mock.calls.Decr
	mock.lockDecr.RUnlock()
	return calls
}

// DecrBy calls DecrByFunc.
func (mock *GoRedisClientMock) DecrBy(ctx context.Context, key string, decrement int64) *redis.IntCmd {
	if mock.DecrByFunc == nil {
		panic("GoRedisClientMock.DecrByFunc: method is nil but GoRedisClient.DecrBy was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		Decrement int64
	}{
		Ctx:       ctx,
		Key:       key,
		Decrement: decrement,
	}
	mock.lockDecrBy.Lock()
	mock.calls.DecrBy = append(mock.calls.DecrBy, callInfo)
	mock.lockDecrBy.Unlock()
	return mock.DecrByFunc(ctx, key, decrement)
}

// DecrByCalls gets all the calls that were made to DecrBy.
// Check the length with:
//
//	len(mockedGoRedisClient.DecrByCalls())
func (mock *GoRedisClientMock) DecrByCalls() []struct {
	Ctx       context.Context
	Key       string
	Decrement int64
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		Decrement int64
	}
	mock.lockDecrBy.RLock()
	calls = mock.calls.DecrBy
	mock.lockDecrBy.RUnlock()
	return calls
}

// Del calls DelFunc.
func (mock *GoRedisClientMock) Del(ctx context.Context, keys ...string) *redis.IntCmd {
	if mock.DelFunc == nil {
		panic("GoRedisClientMock.DelFunc: method is nil but GoRedisClient.Del was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockDel.Lock()
	mock.calls.Del = append(mock.calls.Del, callInfo)
	mock.lockDel.Unlock()
	return mock.DelFunc(ctx, keys...)
}

// DelCalls gets all the calls that were made to Del.
// Check the length with:
//
//	len(mockedGoRedisClient.DelCalls())
func (mock *GoRedisClientMock) DelCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockDel.RLock()
	calls = mock.calls.Del
	mock.lockDel.RUnlock()
	return calls
}

// Do calls DoFunc.
func (mock *GoRedisClientMock) Do(ctx context.Context, args ...interface{}) *redis.Cmd {
	if mock.DoFunc == nil {
		panic("GoRedisClientMock.DoFunc: method is nil but GoRedisClient.Do was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Args []interface{}
	}{
		Ctx:  ctx,
		Args: args,
	}
	mock.lockDo.Lock()
	mock.calls.Do = append(mock.calls.Do, callInfo)
	mock.lockDo.Unlock()
	return mock.DoFunc(ctx, args...)
}

// DoCalls gets all the calls that were made to Do.
// Check the length with:
//
//	len(mockedGoRedisClient.DoCalls())
func (mock *GoRedisClientMock) DoCalls() []struct {
	Ctx  context.Context
	Args []interface{}
} {
	var calls []struct {
		Ctx  context.Context
		Args []interface{}
	}
	mock.lockDo.RLock()
	calls = mock.calls.Do
	mock.lockDo.RUnlock()
	return calls
}

// Dump calls DumpFunc.
func (mock *GoRedisClientMock) Dump(ctx context.Context, key string) *redis.StringCmd {
	if mock.DumpFunc == nil {
		panic("GoRedisClientMock.DumpFunc: method is nil but GoRedisClient.Dump was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockDump.Lock()
	mock.calls.Dump = append(mock.calls.Dump, callInfo)
	mock.lockDump.Unlock()
	return mock.DumpFunc(ctx, key)
}

// DumpCalls gets all the calls that were made to Dump.
// Check the length with:
//
//	len(mockedGoRedisClient.DumpCalls())
func (mock *GoRedisClientMock) DumpCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockDump.RLock()
	calls = mock.calls.Dump
	mock.lockDump.RUnlock()
	return calls
}

// Echo calls EchoFunc.
func (mock *GoRedisClientMock) Echo(ctx context.Context, message interface{}) *redis.StringCmd {
	if mock.EchoFunc == nil {
		panic("GoRedisClientMock.EchoFunc: method is nil but GoRedisClient.Echo was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Message interface{}
	}{
		Ctx:     ctx,
		Message: message,
	}
	mock.lockEcho.Lock()
	mock.calls.Echo = append(mock.calls.Echo, callInfo)
	mock.lockEcho.Unlock()
	return mock.EchoFunc(ctx, message)
}

// EchoCalls gets all the calls that were made to Echo.
// Check the length with:
//
//	len(mockedGoRedisClient.EchoCalls())
func (mock *GoRedisClientMock) EchoCalls() []struct {
	Ctx     context.Context
	Message interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Message interface{}
	}
	mock.lockEcho.RLock()
	calls = mock.calls.Echo
	mock.lockEcho.RUnlock()
	return calls
}

// Eval calls EvalFunc.
func (mock *GoRedisClientMock) Eval(ctx context.Context, script string, keys []string, args ...interface{}) *redis.Cmd {
	if mock.EvalFunc == nil {
		panic("GoRedisClientMock.EvalFunc: method is nil but GoRedisClient.Eval was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Script string
		Keys   []string
		Args   []interface{}
	}{
		Ctx:    ctx,
		Script: script,
		Keys:   keys,
		Args:   args,
	}
	mock.lockEval.Lock()
	mock.calls.Eval = append(mock.calls.Eval, callInfo)
	mock.lockEval.Unlock()
	return mock.EvalFunc(ctx, script, keys, args...)
}

// EvalCalls gets all the calls that were made to Eval.
// Check the length with:
//
//	len(mockedGoRedisClient.EvalCalls())
func (mock *GoRedisClientMock) EvalCalls() []struct {
	Ctx    context.Context
	Script string
	Keys   []string
	Args   []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Script string
		Keys   []string
		Args   []interface{}
	}
	mock.lockEval.RLock()
	calls = mock.calls.Eval
	mock.lockEval.RUnlock()
	return calls
}

// EvalRO calls EvalROFunc.
func (mock *GoRedisClientMock) EvalRO(ctx context.Context, script string, keys []string, args ...interface{}) *redis.Cmd {
	if mock.EvalROFunc == nil {
		panic("GoRedisClientMock.EvalROFunc: method is nil but GoRedisClient.EvalRO was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Script string
		Keys   []string
		Args   []interface{}
	}{
		Ctx:    ctx,
		Script: script,
		Keys:   keys,
		Args:   args,
	}
	mock.lockEvalRO.Lock()
	mock.calls.EvalRO = append(mock.calls.EvalRO, callInfo)
	mock.lockEvalRO.Unlock()
	return mock.EvalROFunc(ctx, script, keys, args...)
}

// EvalROCalls gets all the calls that were made to EvalRO.
// Check the length with:
//
//	len(mockedGoRedisClient.EvalROCalls())
func (mock *GoRedisClientMock) EvalROCalls() []struct {
	Ctx    context.Context
	Script string
	Keys   []string
	Args   []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Script string
		Keys   []string
		Args   []interface{}
	}
	mock.lockEvalRO.RLock()
	calls = mock.calls.EvalRO
	mock.lockEvalRO.RUnlock()
	return calls
}

// EvalSha calls EvalShaFunc.
func (mock *GoRedisClientMock) EvalSha(ctx context.Context, sha1 string, keys []string, args ...interface{}) *redis.Cmd {
	if mock.EvalShaFunc == nil {
		panic("GoRedisClientMock.EvalShaFunc: method is nil but GoRedisClient.EvalSha was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Sha1 string
		Keys []string
		Args []interface{}
	}{
		Ctx:  ctx,
		Sha1: sha1,
		Keys: keys,
		Args: args,
	}
	mock.lockEvalSha.Lock()
	mock.calls.EvalSha = append(mock.calls.EvalSha, callInfo)
	mock.lockEvalSha.Unlock()
	return mock.EvalShaFunc(ctx, sha1, keys, args...)
}

// EvalShaCalls gets all the calls that were made to EvalSha.
// Check the length with:
//
//	len(mockedGoRedisClient.EvalShaCalls())
func (mock *GoRedisClientMock) EvalShaCalls() []struct {
	Ctx  context.Context
	Sha1 string
	Keys []string
	Args []interface{}
} {
	var calls []struct {
		Ctx  context.Context
		Sha1 string
		Keys []string
		Args []interface{}
	}
	mock.lockEvalSha.RLock()
	calls = mock.calls.EvalSha
	mock.lockEvalSha.RUnlock()
	return calls
}

// EvalShaRO calls EvalShaROFunc.
func (mock *GoRedisClientMock) EvalShaRO(ctx context.Context, sha1 string, keys []string, args ...interface{}) *redis.Cmd {
	if mock.EvalShaROFunc == nil {
		panic("GoRedisClientMock.EvalShaROFunc: method is nil but GoRedisClient.EvalShaRO was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Sha1 string
		Keys []string
		Args []interface{}
	}{
		Ctx:  ctx,
		Sha1: sha1,
		Keys: keys,
		Args: args,
	}
	mock.lockEvalShaRO.Lock()
	mock.calls.EvalShaRO = append(mock.calls.EvalShaRO, callInfo)
	mock.lockEvalShaRO.Unlock()
	return mock.EvalShaROFunc(ctx, sha1, keys, args...)
}

// EvalShaROCalls gets all the calls that were made to EvalShaRO.
// Check the length with:
//
//	len(mockedGoRedisClient.EvalShaROCalls())
func (mock *GoRedisClientMock) EvalShaROCalls() []struct {
	Ctx  context.Context
	Sha1 string
	Keys []string
	Args []interface{}
} {
	var calls []struct {
		Ctx  context.Context
		Sha1 string
		Keys []string
		Args []interface{}
	}
	mock.lockEvalShaRO.RLock()
	calls = mock.calls.EvalShaRO
	mock.lockEvalShaRO.RUnlock()
	return calls
}

// Exists calls ExistsFunc.
func (mock *GoRedisClientMock) Exists(ctx context.Context, keys ...string) *redis.IntCmd {
	if mock.ExistsFunc == nil {
		panic("GoRedisClientMock.ExistsFunc: method is nil but GoRedisClient.Exists was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockExists.Lock()
	mock.calls.Exists = append(mock.calls.Exists, callInfo)
	mock.lockExists.Unlock()
	return mock.ExistsFunc(ctx, keys...)
}

// ExistsCalls gets all the calls that were made to Exists.
// Check the length with:
//
//	len(mockedGoRedisClient.ExistsCalls())
func (mock *GoRedisClientMock) ExistsCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockExists.RLock()
	calls = mock.calls.Exists
	mock.lockExists.RUnlock()
	return calls
}

// Expire calls ExpireFunc.
func (mock *GoRedisClientMock) Expire(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	if mock.ExpireFunc == nil {
		panic("GoRedisClientMock.ExpireFunc: method is nil but GoRedisClient.Expire was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Expiration: expiration,
	}
	mock.lockExpire.Lock()
	mock.calls.Expire = append(mock.calls.Expire, callInfo)
	mock.lockExpire.Unlock()
	return mock.ExpireFunc(ctx, key, expiration)
}

// ExpireCalls gets all the calls that were made to Expire.
// Check the length with:
//
//	len(mockedGoRedisClient.ExpireCalls())
func (mock *GoRedisClientMock) ExpireCalls() []struct {
	Ctx        context.Context
	Key        string
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}
	mock.lockExpire.RLock()
	calls = mock.calls.Expire
	mock.lockExpire.RUnlock()
	return calls
}

// ExpireAt calls ExpireAtFunc.
func (mock *GoRedisClientMock) ExpireAt(ctx context.Context, key string, tm time.Time) *redis.BoolCmd {
	if mock.ExpireAtFunc == nil {
		panic("GoRedisClientMock.ExpireAtFunc: method is nil but GoRedisClient.ExpireAt was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Tm  time.Time
	}{
		Ctx: ctx,
		Key: key,
		Tm:  tm,
	}
	mock.lockExpireAt.Lock()
	mock.calls.ExpireAt = append(mock.calls.ExpireAt, callInfo)
	mock.lockExpireAt.Unlock()
	return mock.ExpireAtFunc(ctx, key, tm)
}

// ExpireAtCalls gets all the calls that were made to ExpireAt.
// Check the length with:
//
//	len(mockedGoRedisClient.ExpireAtCalls())
func (mock *GoRedisClientMock) ExpireAtCalls() []struct {
	Ctx context.Context
	Key string
	Tm  time.Time
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Tm  time.Time
	}
	mock.lockExpireAt.RLock()
	calls = mock.calls.ExpireAt
	mock.lockExpireAt.RUnlock()
	return calls
}

// ExpireGT calls ExpireGTFunc.
func (mock *GoRedisClientMock) ExpireGT(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	if mock.ExpireGTFunc == nil {
		panic("GoRedisClientMock.ExpireGTFunc: method is nil but GoRedisClient.ExpireGT was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Expiration: expiration,
	}
	mock.lockExpireGT.Lock()
	mock.calls.ExpireGT = append(mock.calls.ExpireGT, callInfo)
	mock.lockExpireGT.Unlock()
	return mock.ExpireGTFunc(ctx, key, expiration)
}

// ExpireGTCalls gets all the calls that were made to ExpireGT.
// Check the length with:
//
//	len(mockedGoRedisClient.ExpireGTCalls())
func (mock *GoRedisClientMock) ExpireGTCalls() []struct {
	Ctx        context.Context
	Key        string
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}
	mock.lockExpireGT.RLock()
	calls = mock.calls.ExpireGT
	mock.lockExpireGT.RUnlock()
	return calls
}

// ExpireLT calls ExpireLTFunc.
func (mock *GoRedisClientMock) ExpireLT(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	if mock.ExpireLTFunc == nil {
		panic("GoRedisClientMock.ExpireLTFunc: method is nil but GoRedisClient.ExpireLT was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Expiration: expiration,
	}
	mock.lockExpireLT.Lock()
	mock.calls.ExpireLT = append(mock.calls.ExpireLT, callInfo)
	mock.lockExpireLT.Unlock()
	return mock.ExpireLTFunc(ctx, key, expiration)
}

// ExpireLTCalls gets all the calls that were made to ExpireLT.
// Check the length with:
//
//	len(mockedGoRedisClient.ExpireLTCalls())
func (mock *GoRedisClientMock) ExpireLTCalls() []struct {
	Ctx        context.Context
	Key        string
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}
	mock.lockExpireLT.RLock()
	calls = mock.calls.ExpireLT
	mock.lockExpireLT.RUnlock()
	return calls
}

// ExpireNX calls ExpireNXFunc.
func (mock *GoRedisClientMock) ExpireNX(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	if mock.ExpireNXFunc == nil {
		panic("GoRedisClientMock.ExpireNXFunc: method is nil but GoRedisClient.ExpireNX was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Expiration: expiration,
	}
	mock.lockExpireNX.Lock()
	mock.calls.ExpireNX = append(mock.calls.ExpireNX, callInfo)
	mock.lockExpireNX.Unlock()
	return mock.ExpireNXFunc(ctx, key, expiration)
}

// ExpireNXCalls gets all the calls that were made to ExpireNX.
// Check the length with:
//
//	len(mockedGoRedisClient.ExpireNXCalls())
func (mock *GoRedisClientMock) ExpireNXCalls() []struct {
	Ctx        context.Context
	Key        string
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}
	mock.lockExpireNX.RLock()
	calls = mock.calls.ExpireNX
	mock.lockExpireNX.RUnlock()
	return calls
}

// ExpireTime calls ExpireTimeFunc.
func (mock *GoRedisClientMock) ExpireTime(ctx context.Context, key string) *redis.DurationCmd {
	if mock.ExpireTimeFunc == nil {
		panic("GoRedisClientMock.ExpireTimeFunc: method is nil but GoRedisClient.ExpireTime was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockExpireTime.Lock()
	mock.calls.ExpireTime = append(mock.calls.ExpireTime, callInfo)
	mock.lockExpireTime.Unlock()
	return mock.ExpireTimeFunc(ctx, key)
}

// ExpireTimeCalls gets all the calls that were made to ExpireTime.
// Check the length with:
//
//	len(mockedGoRedisClient.ExpireTimeCalls())
func (mock *GoRedisClientMock) ExpireTimeCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockExpireTime.RLock()
	calls = mock.calls.ExpireTime
	mock.lockExpireTime.RUnlock()
	return calls
}

// ExpireXX calls ExpireXXFunc.
func (mock *GoRedisClientMock) ExpireXX(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	if mock.ExpireXXFunc == nil {
		panic("GoRedisClientMock.ExpireXXFunc: method is nil but GoRedisClient.ExpireXX was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Expiration: expiration,
	}
	mock.lockExpireXX.Lock()
	mock.calls.ExpireXX = append(mock.calls.ExpireXX, callInfo)
	mock.lockExpireXX.Unlock()
	return mock.ExpireXXFunc(ctx, key, expiration)
}

// ExpireXXCalls gets all the calls that were made to ExpireXX.
// Check the length with:
//
//	len(mockedGoRedisClient.ExpireXXCalls())
func (mock *GoRedisClientMock) ExpireXXCalls() []struct {
	Ctx        context.Context
	Key        string
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}
	mock.lockExpireXX.RLock()
	calls = mock.calls.ExpireXX
	mock.lockExpireXX.RUnlock()
	return calls
}

// FCall calls FCallFunc.
func (mock *GoRedisClientMock) FCall(ctx context.Context, function string, keys []string, args ...interface{}) *redis.Cmd {
	if mock.FCallFunc == nil {
		panic("GoRedisClientMock.FCallFunc: method is nil but GoRedisClient.FCall was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Function string
		Keys     []string
		Args     []interface{}
	}{
		Ctx:      ctx,
		Function: function,
		Keys:     keys,
		Args:     args,
	}
	mock.lockFCall.Lock()
	mock.calls.FCall = append(mock.calls.FCall, callInfo)
	mock.lockFCall.Unlock()
	return mock.FCallFunc(ctx, function, keys, args...)
}

// FCallCalls gets all the calls that were made to FCall.
// Check the length with:
//
//	len(mockedGoRedisClient.FCallCalls())
func (mock *GoRedisClientMock) FCallCalls() []struct {
	Ctx      context.Context
	Function string
	Keys     []string
	Args     []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Function string
		Keys     []string
		Args     []interface{}
	}
	mock.lockFCall.RLock()
	calls = mock.calls.FCall
	mock.lockFCall.RUnlock()
	return calls
}

// FCallRO calls FCallROFunc.
func (mock *GoRedisClientMock) FCallRO(ctx context.Context, function string, keys []string, args ...interface{}) *redis.Cmd {
	if mock.FCallROFunc == nil {
		panic("GoRedisClientMock.FCallROFunc: method is nil but GoRedisClient.FCallRO was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Function string
		Keys     []string
		Args     []interface{}
	}{
		Ctx:      ctx,
		Function: function,
		Keys:     keys,
		Args:     args,
	}
	mock.lockFCallRO.Lock()
	mock.calls.FCallRO = append(mock.calls.FCallRO, callInfo)
	mock.lockFCallRO.Unlock()
	return mock.FCallROFunc(ctx, function, keys, args...)
}

// FCallROCalls gets all the calls that were made to FCallRO.
// Check the length with:
//
//	len(mockedGoRedisClient.FCallROCalls())
func (mock *GoRedisClientMock) FCallROCalls() []struct {
	Ctx      context.Context
	Function string
	Keys     []string
	Args     []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Function string
		Keys     []string
		Args     []interface{}
	}
	mock.lockFCallRO.RLock()
	calls = mock.calls.FCallRO
	mock.lockFCallRO.RUnlock()
	return calls
}

// FCallRo calls FCallRoFunc.
func (mock *GoRedisClientMock) FCallRo(ctx context.Context, function string, keys []string, args ...interface{}) *redis.Cmd {
	if mock.FCallRoFunc == nil {
		panic("GoRedisClientMock.FCallRoFunc: method is nil but GoRedisClient.FCallRo was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Function string
		Keys     []string
		Args     []interface{}
	}{
		Ctx:      ctx,
		Function: function,
		Keys:     keys,
		Args:     args,
	}
	mock.lockFCallRo.Lock()
	mock.calls.FCallRo = append(mock.calls.FCallRo, callInfo)
	mock.lockFCallRo.Unlock()
	return mock.FCallRoFunc(ctx, function, keys, args...)
}

// FCallRoCalls gets all the calls that were made to FCallRo.
// Check the length with:
//
//	len(mockedGoRedisClient.FCallRoCalls())
func (mock *GoRedisClientMock) FCallRoCalls() []struct {
	Ctx      context.Context
	Function string
	Keys     []string
	Args     []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Function string
		Keys     []string
		Args     []interface{}
	}
	mock.lockFCallRo.RLock()
	calls = mock.calls.FCallRo
	mock.lockFCallRo.RUnlock()
	return calls
}

// FTAggregate calls FTAggregateFunc.
func (mock *GoRedisClientMock) FTAggregate(ctx context.Context, index string, query string) *redis.MapStringInterfaceCmd {
	if mock.FTAggregateFunc == nil {
		panic("GoRedisClientMock.FTAggregateFunc: method is nil but GoRedisClient.FTAggregate was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Index string
		Query string
	}{
		Ctx:   ctx,
		Index: index,
		Query: query,
	}
	mock.lockFTAggregate.Lock()
	mock.calls.FTAggregate = append(mock.calls.FTAggregate, callInfo)
	mock.lockFTAggregate.Unlock()
	return mock.FTAggregateFunc(ctx, index, query)
}

// FTAggregateCalls gets all the calls that were made to FTAggregate.
// Check the length with:
//
//	len(mockedGoRedisClient.FTAggregateCalls())
func (mock *GoRedisClientMock) FTAggregateCalls() []struct {
	Ctx   context.Context
	Index string
	Query string
} {
	var calls []struct {
		Ctx   context.Context
		Index string
		Query string
	}
	mock.lockFTAggregate.RLock()
	calls = mock.calls.FTAggregate
	mock.lockFTAggregate.RUnlock()
	return calls
}

// FTAggregateWithArgs calls FTAggregateWithArgsFunc.
func (mock *GoRedisClientMock) FTAggregateWithArgs(ctx context.Context, index string, query string, options *redis.FTAggregateOptions) *redis.AggregateCmd {
	if mock.FTAggregateWithArgsFunc == nil {
		panic("GoRedisClientMock.FTAggregateWithArgsFunc: method is nil but GoRedisClient.FTAggregateWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Index   string
		Query   string
		Options *redis.FTAggregateOptions
	}{
		Ctx:     ctx,
		Index:   index,
		Query:   query,
		Options: options,
	}
	mock.lockFTAggregateWithArgs.Lock()
	mock.calls.FTAggregateWithArgs = append(mock.calls.FTAggregateWithArgs, callInfo)
	mock.lockFTAggregateWithArgs.Unlock()
	return mock.FTAggregateWithArgsFunc(ctx, index, query, options)
}

// FTAggregateWithArgsCalls gets all the calls that were made to FTAggregateWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.FTAggregateWithArgsCalls())
func (mock *GoRedisClientMock) FTAggregateWithArgsCalls() []struct {
	Ctx     context.Context
	Index   string
	Query   string
	Options *redis.FTAggregateOptions
} {
	var calls []struct {
		Ctx     context.Context
		Index   string
		Query   string
		Options *redis.FTAggregateOptions
	}
	mock.lockFTAggregateWithArgs.RLock()
	calls = mock.calls.FTAggregateWithArgs
	mock.lockFTAggregateWithArgs.RUnlock()
	return calls
}

// FTAliasAdd calls FTAliasAddFunc.
func (mock *GoRedisClientMock) FTAliasAdd(ctx context.Context, index string, alias string) *redis.StatusCmd {
	if mock.FTAliasAddFunc == nil {
		panic("GoRedisClientMock.FTAliasAddFunc: method is nil but GoRedisClient.FTAliasAdd was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Index string
		Alias string
	}{
		Ctx:   ctx,
		Index: index,
		Alias: alias,
	}
	mock.lockFTAliasAdd.Lock()
	mock.calls.FTAliasAdd = append(mock.calls.FTAliasAdd, callInfo)
	mock.lockFTAliasAdd.Unlock()
	return mock.FTAliasAddFunc(ctx, index, alias)
}

// FTAliasAddCalls gets all the calls that were made to FTAliasAdd.
// Check the length with:
//
//	len(mockedGoRedisClient.FTAliasAddCalls())
func (mock *GoRedisClientMock) FTAliasAddCalls() []struct {
	Ctx   context.Context
	Index string
	Alias string
} {
	var calls []struct {
		Ctx   context.Context
		Index string
		Alias string
	}
	mock.lockFTAliasAdd.RLock()
	calls = mock.calls.FTAliasAdd
	mock.lockFTAliasAdd.RUnlock()
	return calls
}

// FTAliasDel calls FTAliasDelFunc.
func (mock *GoRedisClientMock) FTAliasDel(ctx context.Context, alias string) *redis.StatusCmd {
	if mock.FTAliasDelFunc == nil {
		panic("GoRedisClientMock.FTAliasDelFunc: method is nil but GoRedisClient.FTAliasDel was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Alias string
	}{
		Ctx:   ctx,
		Alias: alias,
	}
	mock.lockFTAliasDel.Lock()
	mock.calls.FTAliasDel = append(mock.calls.FTAliasDel, callInfo)
	mock.lockFTAliasDel.Unlock()
	return mock.FTAliasDelFunc(ctx, alias)
}

// FTAliasDelCalls gets all the calls that were made to FTAliasDel.
// Check the length with:
//
//	len(mockedGoRedisClient.FTAliasDelCalls())
func (mock *GoRedisClientMock) FTAliasDelCalls() []struct {
	Ctx   context.Context
	Alias string
} {
	var calls []struct {
		Ctx   context.Context
		Alias string
	}
	mock.lockFTAliasDel.RLock()
	calls = mock.calls.FTAliasDel
	mock.lockFTAliasDel.RUnlock()
	return calls
}

// FTAliasUpdate calls FTAliasUpdateFunc.
func (mock *GoRedisClientMock) FTAliasUpdate(ctx context.Context, index string, alias string) *redis.StatusCmd {
	if mock.FTAliasUpdateFunc == nil {
		panic("GoRedisClientMock.FTAliasUpdateFunc: method is nil but GoRedisClient.FTAliasUpdate was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Index string
		Alias string
	}{
		Ctx:   ctx,
		Index: index,
		Alias: alias,
	}
	mock.lockFTAliasUpdate.Lock()
	mock.calls.FTAliasUpdate = append(mock.calls.FTAliasUpdate, callInfo)
	mock.lockFTAliasUpdate.Unlock()
	return mock.FTAliasUpdateFunc(ctx, index, alias)
}

// FTAliasUpdateCalls gets all the calls that were made to FTAliasUpdate.
// Check the length with:
//
//	len(mockedGoRedisClient.FTAliasUpdateCalls())
func (mock *GoRedisClientMock) FTAliasUpdateCalls() []struct {
	Ctx   context.Context
	Index string
	Alias string
} {
	var calls []struct {
		Ctx   context.Context
		Index string
		Alias string
	}
	mock.lockFTAliasUpdate.RLock()
	calls = mock.calls.FTAliasUpdate
	mock.lockFTAliasUpdate.RUnlock()
	return calls
}

// FTAlter calls FTAlterFunc.
func (mock *GoRedisClientMock) FTAlter(ctx context.Context, index string, skipInitialScan bool, definition []interface{}) *redis.StatusCmd {
	if mock.FTAlterFunc == nil {
		panic("GoRedisClientMock.FTAlterFunc: method is nil but GoRedisClient.FTAlter was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		Index           string
		SkipInitialScan bool
		Definition      []interface{}
	}{
		Ctx:             ctx,
		Index:           index,
		SkipInitialScan: skipInitialScan,
		Definition:      definition,
	}
	mock.lockFTAlter.Lock()
	mock.calls.FTAlter = append(mock.calls.FTAlter, callInfo)
	mock.lockFTAlter.Unlock()
	return mock.FTAlterFunc(ctx, index, skipInitialScan, definition)
}

// FTAlterCalls gets all the calls that were made to FTAlter.
// Check the length with:
//
//	len(mockedGoRedisClient.FTAlterCalls())
func (mock *GoRedisClientMock) FTAlterCalls() []struct {
	Ctx             context.Context
	Index           string
	SkipInitialScan bool
	Definition      []interface{}
} {
	var calls []struct {
		Ctx             context.Context
		Index           string
		SkipInitialScan bool
		Definition      []interface{}
	}
	mock.lockFTAlter.RLock()
	calls = mock.calls.FTAlter
	mock.lockFTAlter.RUnlock()
	return calls
}

// FTConfigGet calls FTConfigGetFunc.
func (mock *GoRedisClientMock) FTConfigGet(ctx context.Context, option string) *redis.MapMapStringInterfaceCmd {
	if mock.FTConfigGetFunc == nil {
		panic("GoRedisClientMock.FTConfigGetFunc: method is nil but GoRedisClient.FTConfigGet was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Option string
	}{
		Ctx:    ctx,
		Option: option,
	}
	mock.lockFTConfigGet.Lock()
	mock.calls.FTConfigGet = append(mock.calls.FTConfigGet, callInfo)
	mock.lockFTConfigGet.Unlock()
	return mock.FTConfigGetFunc(ctx, option)
}

// FTConfigGetCalls gets all the calls that were made to FTConfigGet.
// Check the length with:
//
//	len(mockedGoRedisClient.FTConfigGetCalls())
func (mock *GoRedisClientMock) FTConfigGetCalls() []struct {
	Ctx    context.Context
	Option string
} {
	var calls []struct {
		Ctx    context.Context
		Option string
	}
	mock.lockFTConfigGet.RLock()
	calls = mock.calls.FTConfigGet
	mock.lockFTConfigGet.RUnlock()
	return calls
}

// FTConfigSet calls FTConfigSetFunc.
func (mock *GoRedisClientMock) FTConfigSet(ctx context.Context, option string, value interface{}) *redis.StatusCmd {
	if mock.FTConfigSetFunc == nil {
		panic("GoRedisClientMock.FTConfigSetFunc: method is nil but GoRedisClient.FTConfigSet was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Option string
		Value  interface{}
	}{
		Ctx:    ctx,
		Option: option,
		Value:  value,
	}
	mock.lockFTConfigSet.Lock()
	mock.calls.FTConfigSet = append(mock.calls.FTConfigSet, callInfo)
	mock.lockFTConfigSet.Unlock()
	return mock.FTConfigSetFunc(ctx, option, value)
}

// FTConfigSetCalls gets all the calls that were made to FTConfigSet.
// Check the length with:
//
//	len(mockedGoRedisClient.FTConfigSetCalls())
func (mock *GoRedisClientMock) FTConfigSetCalls() []struct {
	Ctx    context.Context
	Option string
	Value  interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Option string
		Value  interface{}
	}
	mock.lockFTConfigSet.RLock()
	calls = mock.calls.FTConfigSet
	mock.lockFTConfigSet.RUnlock()
	return calls
}

// FTCreate calls FTCreateFunc.
func (mock *GoRedisClientMock) FTCreate(ctx context.Context, index string, options *redis.FTCreateOptions, schema ...*redis.FieldSchema) *redis.StatusCmd {
	if mock.FTCreateFunc == nil {
		panic("GoRedisClientMock.FTCreateFunc: method is nil but GoRedisClient.FTCreate was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Index   string
		Options *redis.FTCreateOptions
		Schema  []*redis.FieldSchema
	}{
		Ctx:     ctx,
		Index:   index,
		Options: options,
		Schema:  schema,
	}
	mock.lockFTCreate.Lock()
	mock.calls.FTCreate = append(mock.calls.FTCreate, callInfo)
	mock.lockFTCreate.Unlock()
	return mock.FTCreateFunc(ctx, index, options, schema...)
}

// FTCreateCalls gets all the calls that were made to FTCreate.
// Check the length with:
//
//	len(mockedGoRedisClient.FTCreateCalls())
func (mock *GoRedisClientMock) FTCreateCalls() []struct {
	Ctx     context.Context
	Index   string
	Options *redis.FTCreateOptions
	Schema  []*redis.FieldSchema
} {
	var calls []struct {
		Ctx     context.Context
		Index   string
		Options *redis.FTCreateOptions
		Schema  []*redis.FieldSchema
	}
	mock.lockFTCreate.RLock()
	calls = mock.calls.FTCreate
	mock.lockFTCreate.RUnlock()
	return calls
}

// FTCursorDel calls FTCursorDelFunc.
func (mock *GoRedisClientMock) FTCursorDel(ctx context.Context, index string, cursorId int) *redis.StatusCmd {
	if mock.FTCursorDelFunc == nil {
		panic("GoRedisClientMock.FTCursorDelFunc: method is nil but GoRedisClient.FTCursorDel was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Index    string
		CursorId int
	}{
		Ctx:      ctx,
		Index:    index,
		CursorId: cursorId,
	}
	mock.lockFTCursorDel.Lock()
	mock.calls.FTCursorDel = append(mock.calls.FTCursorDel, callInfo)
	mock.lockFTCursorDel.Unlock()
	return mock.FTCursorDelFunc(ctx, index, cursorId)
}

// FTCursorDelCalls gets all the calls that were made to FTCursorDel.
// Check the length with:
//
//	len(mockedGoRedisClient.FTCursorDelCalls())
func (mock *GoRedisClientMock) FTCursorDelCalls() []struct {
	Ctx      context.Context
	Index    string
	CursorId int
} {
	var calls []struct {
		Ctx      context.Context
		Index    string
		CursorId int
	}
	mock.lockFTCursorDel.RLock()
	calls = mock.calls.FTCursorDel
	mock.lockFTCursorDel.RUnlock()
	return calls
}

// FTCursorRead calls FTCursorReadFunc.
func (mock *GoRedisClientMock) FTCursorRead(ctx context.Context, index string, cursorId int, count int) *redis.MapStringInterfaceCmd {
	if mock.FTCursorReadFunc == nil {
		panic("GoRedisClientMock.FTCursorReadFunc: method is nil but GoRedisClient.FTCursorRead was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Index    string
		CursorId int
		Count    int
	}{
		Ctx:      ctx,
		Index:    index,
		CursorId: cursorId,
		Count:    count,
	}
	mock.lockFTCursorRead.Lock()
	mock.calls.FTCursorRead = append(mock.calls.FTCursorRead, callInfo)
	mock.lockFTCursorRead.Unlock()
	return mock.FTCursorReadFunc(ctx, index, cursorId, count)
}

// FTCursorReadCalls gets all the calls that were made to FTCursorRead.
// Check the length with:
//
//	len(mockedGoRedisClient.FTCursorReadCalls())
func (mock *GoRedisClientMock) FTCursorReadCalls() []struct {
	Ctx      context.Context
	Index    string
	CursorId int
	Count    int
} {
	var calls []struct {
		Ctx      context.Context
		Index    string
		CursorId int
		Count    int
	}
	mock.lockFTCursorRead.RLock()
	calls = mock.calls.FTCursorRead
	mock.lockFTCursorRead.RUnlock()
	return calls
}

// FTDictAdd calls FTDictAddFunc.
func (mock *GoRedisClientMock) FTDictAdd(ctx context.Context, dict string, term ...interface{}) *redis.IntCmd {
	if mock.FTDictAddFunc == nil {
		panic("GoRedisClientMock.FTDictAddFunc: method is nil but GoRedisClient.FTDictAdd was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Dict string
		Term []interface{}
	}{
		Ctx:  ctx,
		Dict: dict,
		Term: term,
	}
	mock.lockFTDictAdd.Lock()
	mock.calls.FTDictAdd = append(mock.calls.FTDictAdd, callInfo)
	mock.lockFTDictAdd.Unlock()
	return mock.FTDictAddFunc(ctx, dict, term...)
}

// FTDictAddCalls gets all the calls that were made to FTDictAdd.
// Check the length with:
//
//	len(mockedGoRedisClient.FTDictAddCalls())
func (mock *GoRedisClientMock) FTDictAddCalls() []struct {
	Ctx  context.Context
	Dict string
	Term []interface{}
} {
	var calls []struct {
		Ctx  context.Context
		Dict string
		Term []interface{}
	}
	mock.lockFTDictAdd.RLock()
	calls = mock.calls.FTDictAdd
	mock.lockFTDictAdd.RUnlock()
	return calls
}

// FTDictDel calls FTDictDelFunc.
func (mock *GoRedisClientMock) FTDictDel(ctx context.Context, dict string, term ...interface{}) *redis.IntCmd {
	if mock.FTDictDelFunc == nil {
		panic("GoRedisClientMock.FTDictDelFunc: method is nil but GoRedisClient.FTDictDel was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Dict string
		Term []interface{}
	}{
		Ctx:  ctx,
		Dict: dict,
		Term: term,
	}
	mock.lockFTDictDel.Lock()
	mock.calls.FTDictDel = append(mock.calls.FTDictDel, callInfo)
	mock.lockFTDictDel.Unlock()
	return mock.FTDictDelFunc(ctx, dict, term...)
}

// FTDictDelCalls gets all the calls that were made to FTDictDel.
// Check the length with:
//
//	len(mockedGoRedisClient.FTDictDelCalls())
func (mock *GoRedisClientMock) FTDictDelCalls() []struct {
	Ctx  context.Context
	Dict string
	Term []interface{}
} {
	var calls []struct {
		Ctx  context.Context
		Dict string
		Term []interface{}
	}
	mock.lockFTDictDel.RLock()
	calls = mock.calls.FTDictDel
	mock.lockFTDictDel.RUnlock()
	return calls
}

// FTDictDump calls FTDictDumpFunc.
func (mock *GoRedisClientMock) FTDictDump(ctx context.Context, dict string) *redis.StringSliceCmd {
	if mock.FTDictDumpFunc == nil {
		panic("GoRedisClientMock.FTDictDumpFunc: method is nil but GoRedisClient.FTDictDump was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Dict string
	}{
		Ctx:  ctx,
		Dict: dict,
	}
	mock.lockFTDictDump.Lock()
	mock.calls.FTDictDump = append(mock.calls.FTDictDump, callInfo)
	mock.lockFTDictDump.Unlock()
	return mock.FTDictDumpFunc(ctx, dict)
}

// FTDictDumpCalls gets all the calls that were made to FTDictDump.
// Check the length with:
//
//	len(mockedGoRedisClient.FTDictDumpCalls())
func (mock *GoRedisClientMock) FTDictDumpCalls() []struct {
	Ctx  context.Context
	Dict string
} {
	var calls []struct {
		Ctx  context.Context
		Dict string
	}
	mock.lockFTDictDump.RLock()
	calls = mock.calls.FTDictDump
	mock.lockFTDictDump.RUnlock()
	return calls
}

// FTDropIndex calls FTDropIndexFunc.
func (mock *GoRedisClientMock) FTDropIndex(ctx context.Context, index string) *redis.StatusCmd {
	if mock.FTDropIndexFunc == nil {
		panic("GoRedisClientMock.FTDropIndexFunc: method is nil but GoRedisClient.FTDropIndex was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Index string
	}{
		Ctx:   ctx,
		Index: index,
	}
	mock.lockFTDropIndex.Lock()
	mock.calls.FTDropIndex = append(mock.calls.FTDropIndex, callInfo)
	mock.lockFTDropIndex.Unlock()
	return mock.FTDropIndexFunc(ctx, index)
}

// FTDropIndexCalls gets all the calls that were made to FTDropIndex.
// Check the length with:
//
//	len(mockedGoRedisClient.FTDropIndexCalls())
func (mock *GoRedisClientMock) FTDropIndexCalls() []struct {
	Ctx   context.Context
	Index string
} {
	var calls []struct {
		Ctx   context.Context
		Index string
	}
	mock.lockFTDropIndex.RLock()
	calls = mock.calls.FTDropIndex
	mock.lockFTDropIndex.RUnlock()
	return calls
}

// FTDropIndexWithArgs calls FTDropIndexWithArgsFunc.
func (mock *GoRedisClientMock) FTDropIndexWithArgs(ctx context.Context, index string, options *redis.FTDropIndexOptions) *redis.StatusCmd {
	if mock.FTDropIndexWithArgsFunc == nil {
		panic("GoRedisClientMock.FTDropIndexWithArgsFunc: method is nil but GoRedisClient.FTDropIndexWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Index   string
		Options *redis.FTDropIndexOptions
	}{
		Ctx:     ctx,
		Index:   index,
		Options: options,
	}
	mock.lockFTDropIndexWithArgs.Lock()
	mock.calls.FTDropIndexWithArgs = append(mock.calls.FTDropIndexWithArgs, callInfo)
	mock.lockFTDropIndexWithArgs.Unlock()
	return mock.FTDropIndexWithArgsFunc(ctx, index, options)
}

// FTDropIndexWithArgsCalls gets all the calls that were made to FTDropIndexWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.FTDropIndexWithArgsCalls())
func (mock *GoRedisClientMock) FTDropIndexWithArgsCalls() []struct {
	Ctx     context.Context
	Index   string
	Options *redis.FTDropIndexOptions
} {
	var calls []struct {
		Ctx     context.Context
		Index   string
		Options *redis.FTDropIndexOptions
	}
	mock.lockFTDropIndexWithArgs.RLock()
	calls = mock.calls.FTDropIndexWithArgs
	mock.lockFTDropIndexWithArgs.RUnlock()
	return calls
}

// FTExplain calls FTExplainFunc.
func (mock *GoRedisClientMock) FTExplain(ctx context.Context, index string, query string) *redis.StringCmd {
	if mock.FTExplainFunc == nil {
		panic("GoRedisClientMock.FTExplainFunc: method is nil but GoRedisClient.FTExplain was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Index string
		Query string
	}{
		Ctx:   ctx,
		Index: index,
		Query: query,
	}
	mock.lockFTExplain.Lock()
	mock.calls.FTExplain = append(mock.calls.FTExplain, callInfo)
	mock.lockFTExplain.Unlock()
	return mock.FTExplainFunc(ctx, index, query)
}

// FTExplainCalls gets all the calls that were made to FTExplain.
// Check the length with:
//
//	len(mockedGoRedisClient.FTExplainCalls())
func (mock *GoRedisClientMock) FTExplainCalls() []struct {
	Ctx   context.Context
	Index string
	Query string
} {
	var calls []struct {
		Ctx   context.Context
		Index string
		Query string
	}
	mock.lockFTExplain.RLock()
	calls = mock.calls.FTExplain
	mock.lockFTExplain.RUnlock()
	return calls
}

// FTExplainWithArgs calls FTExplainWithArgsFunc.
func (mock *GoRedisClientMock) FTExplainWithArgs(ctx context.Context, index string, query string, options *redis.FTExplainOptions) *redis.StringCmd {
	if mock.FTExplainWithArgsFunc == nil {
		panic("GoRedisClientMock.FTExplainWithArgsFunc: method is nil but GoRedisClient.FTExplainWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Index   string
		Query   string
		Options *redis.FTExplainOptions
	}{
		Ctx:     ctx,
		Index:   index,
		Query:   query,
		Options: options,
	}
	mock.lockFTExplainWithArgs.Lock()
	mock.calls.FTExplainWithArgs = append(mock.calls.FTExplainWithArgs, callInfo)
	mock.lockFTExplainWithArgs.Unlock()
	return mock.FTExplainWithArgsFunc(ctx, index, query, options)
}

// FTExplainWithArgsCalls gets all the calls that were made to FTExplainWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.FTExplainWithArgsCalls())
func (mock *GoRedisClientMock) FTExplainWithArgsCalls() []struct {
	Ctx     context.Context
	Index   string
	Query   string
	Options *redis.FTExplainOptions
} {
	var calls []struct {
		Ctx     context.Context
		Index   string
		Query   string
		Options *redis.FTExplainOptions
	}
	mock.lockFTExplainWithArgs.RLock()
	calls = mock.calls.FTExplainWithArgs
	mock.lockFTExplainWithArgs.RUnlock()
	return calls
}

// FTInfo calls FTInfoFunc.
func (mock *GoRedisClientMock) FTInfo(ctx context.Context, index string) *redis.FTInfoCmd {
	if mock.FTInfoFunc == nil {
		panic("GoRedisClientMock.FTInfoFunc: method is nil but GoRedisClient.FTInfo was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Index string
	}{
		Ctx:   ctx,
		Index: index,
	}
	mock.lockFTInfo.Lock()
	mock.calls.FTInfo = append(mock.calls.FTInfo, callInfo)
	mock.lockFTInfo.Unlock()
	return mock.FTInfoFunc(ctx, index)
}

// FTInfoCalls gets all the calls that were made to FTInfo.
// Check the length with:
//
//	len(mockedGoRedisClient.FTInfoCalls())
func (mock *GoRedisClientMock) FTInfoCalls() []struct {
	Ctx   context.Context
	Index string
} {
	var calls []struct {
		Ctx   context.Context
		Index string
	}
	mock.lockFTInfo.RLock()
	calls = mock.calls.FTInfo
	mock.lockFTInfo.RUnlock()
	return calls
}

// FTSearch calls FTSearchFunc.
func (mock *GoRedisClientMock) FTSearch(ctx context.Context, index string, query string) *redis.FTSearchCmd {
	if mock.FTSearchFunc == nil {
		panic("GoRedisClientMock.FTSearchFunc: method is nil but GoRedisClient.FTSearch was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Index string
		Query string
	}{
		Ctx:   ctx,
		Index: index,
		Query: query,
	}
	mock.lockFTSearch.Lock()
	mock.calls.FTSearch = append(mock.calls.FTSearch, callInfo)
	mock.lockFTSearch.Unlock()
	return mock.FTSearchFunc(ctx, index, query)
}

// FTSearchCalls gets all the calls that were made to FTSearch.
// Check the length with:
//
//	len(mockedGoRedisClient.FTSearchCalls())
func (mock *GoRedisClientMock) FTSearchCalls() []struct {
	Ctx   context.Context
	Index string
	Query string
} {
	var calls []struct {
		Ctx   context.Context
		Index string
		Query string
	}
	mock.lockFTSearch.RLock()
	calls = mock.calls.FTSearch
	mock.lockFTSearch.RUnlock()
	return calls
}

// FTSearchWithArgs calls FTSearchWithArgsFunc.
func (mock *GoRedisClientMock) FTSearchWithArgs(ctx context.Context, index string, query string, options *redis.FTSearchOptions) *redis.FTSearchCmd {
	if mock.FTSearchWithArgsFunc == nil {
		panic("GoRedisClientMock.FTSearchWithArgsFunc: method is nil but GoRedisClient.FTSearchWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Index   string
		Query   string
		Options *redis.FTSearchOptions
	}{
		Ctx:     ctx,
		Index:   index,
		Query:   query,
		Options: options,
	}
	mock.lockFTSearchWithArgs.Lock()
	mock.calls.FTSearchWithArgs = append(mock.calls.FTSearchWithArgs, callInfo)
	mock.lockFTSearchWithArgs.Unlock()
	return mock.FTSearchWithArgsFunc(ctx, index, query, options)
}

// FTSearchWithArgsCalls gets all the calls that were made to FTSearchWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.FTSearchWithArgsCalls())
func (mock *GoRedisClientMock) FTSearchWithArgsCalls() []struct {
	Ctx     context.Context
	Index   string
	Query   string
	Options *redis.FTSearchOptions
} {
	var calls []struct {
		Ctx     context.Context
		Index   string
		Query   string
		Options *redis.FTSearchOptions
	}
	mock.lockFTSearchWithArgs.RLock()
	calls = mock.calls.FTSearchWithArgs
	mock.lockFTSearchWithArgs.RUnlock()
	return calls
}

// FTSpellCheck calls FTSpellCheckFunc.
func (mock *GoRedisClientMock) FTSpellCheck(ctx context.Context, index string, query string) *redis.FTSpellCheckCmd {
	if mock.FTSpellCheckFunc == nil {
		panic("GoRedisClientMock.FTSpellCheckFunc: method is nil but GoRedisClient.FTSpellCheck was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Index string
		Query string
	}{
		Ctx:   ctx,
		Index: index,
		Query: query,
	}
	mock.lockFTSpellCheck.Lock()
	mock.calls.FTSpellCheck = append(mock.calls.FTSpellCheck, callInfo)
	mock.lockFTSpellCheck.Unlock()
	return mock.FTSpellCheckFunc(ctx, index, query)
}

// FTSpellCheckCalls gets all the calls that were made to FTSpellCheck.
// Check the length with:
//
//	len(mockedGoRedisClient.FTSpellCheckCalls())
func (mock *GoRedisClientMock) FTSpellCheckCalls() []struct {
	Ctx   context.Context
	Index string
	Query string
} {
	var calls []struct {
		Ctx   context.Context
		Index string
		Query string
	}
	mock.lockFTSpellCheck.RLock()
	calls = mock.calls.FTSpellCheck
	mock.lockFTSpellCheck.RUnlock()
	return calls
}

// FTSpellCheckWithArgs calls FTSpellCheckWithArgsFunc.
func (mock *GoRedisClientMock) FTSpellCheckWithArgs(ctx context.Context, index string, query string, options *redis.FTSpellCheckOptions) *redis.FTSpellCheckCmd {
	if mock.FTSpellCheckWithArgsFunc == nil {
		panic("GoRedisClientMock.FTSpellCheckWithArgsFunc: method is nil but GoRedisClient.FTSpellCheckWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Index   string
		Query   string
		Options *redis.FTSpellCheckOptions
	}{
		Ctx:     ctx,
		Index:   index,
		Query:   query,
		Options: options,
	}
	mock.lockFTSpellCheckWithArgs.Lock()
	mock.calls.FTSpellCheckWithArgs = append(mock.calls.FTSpellCheckWithArgs, callInfo)
	mock.lockFTSpellCheckWithArgs.Unlock()
	return mock.FTSpellCheckWithArgsFunc(ctx, index, query, options)
}

// FTSpellCheckWithArgsCalls gets all the calls that were made to FTSpellCheckWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.FTSpellCheckWithArgsCalls())
func (mock *GoRedisClientMock) FTSpellCheckWithArgsCalls() []struct {
	Ctx     context.Context
	Index   string
	Query   string
	Options *redis.FTSpellCheckOptions
} {
	var calls []struct {
		Ctx     context.Context
		Index   string
		Query   string
		Options *redis.FTSpellCheckOptions
	}
	mock.lockFTSpellCheckWithArgs.RLock()
	calls = mock.calls.FTSpellCheckWithArgs
	mock.lockFTSpellCheckWithArgs.RUnlock()
	return calls
}

// FTSynDump calls FTSynDumpFunc.
func (mock *GoRedisClientMock) FTSynDump(ctx context.Context, index string) *redis.FTSynDumpCmd {
	if mock.FTSynDumpFunc == nil {
		panic("GoRedisClientMock.FTSynDumpFunc: method is nil but GoRedisClient.FTSynDump was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Index string
	}{
		Ctx:   ctx,
		Index: index,
	}
	mock.lockFTSynDump.Lock()
	mock.calls.FTSynDump = append(mock.calls.FTSynDump, callInfo)
	mock.lockFTSynDump.Unlock()
	return mock.FTSynDumpFunc(ctx, index)
}

// FTSynDumpCalls gets all the calls that were made to FTSynDump.
// Check the length with:
//
//	len(mockedGoRedisClient.FTSynDumpCalls())
func (mock *GoRedisClientMock) FTSynDumpCalls() []struct {
	Ctx   context.Context
	Index string
} {
	var calls []struct {
		Ctx   context.Context
		Index string
	}
	mock.lockFTSynDump.RLock()
	calls = mock.calls.FTSynDump
	mock.lockFTSynDump.RUnlock()
	return calls
}

// FTSynUpdate calls FTSynUpdateFunc.
func (mock *GoRedisClientMock) FTSynUpdate(ctx context.Context, index string, synGroupId interface{}, terms []interface{}) *redis.StatusCmd {
	if mock.FTSynUpdateFunc == nil {
		panic("GoRedisClientMock.FTSynUpdateFunc: method is nil but GoRedisClient.FTSynUpdate was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Index      string
		SynGroupId interface{}
		Terms      []interface{}
	}{
		Ctx:        ctx,
		Index:      index,
		SynGroupId: synGroupId,
		Terms:      terms,
	}
	mock.lockFTSynUpdate.Lock()
	mock.calls.FTSynUpdate = append(mock.calls.FTSynUpdate, callInfo)
	mock.lockFTSynUpdate.Unlock()
	return mock.FTSynUpdateFunc(ctx, index, synGroupId, terms)
}

// FTSynUpdateCalls gets all the calls that were made to FTSynUpdate.
// Check the length with:
//
//	len(mockedGoRedisClient.FTSynUpdateCalls())
func (mock *GoRedisClientMock) FTSynUpdateCalls() []struct {
	Ctx        context.Context
	Index      string
	SynGroupId interface{}
	Terms      []interface{}
} {
	var calls []struct {
		Ctx        context.Context
		Index      string
		SynGroupId interface{}
		Terms      []interface{}
	}
	mock.lockFTSynUpdate.RLock()
	calls = mock.calls.FTSynUpdate
	mock.lockFTSynUpdate.RUnlock()
	return calls
}

// FTSynUpdateWithArgs calls FTSynUpdateWithArgsFunc.
func (mock *GoRedisClientMock) FTSynUpdateWithArgs(ctx context.Context, index string, synGroupId interface{}, options *redis.FTSynUpdateOptions, terms []interface{}) *redis.StatusCmd {
	if mock.FTSynUpdateWithArgsFunc == nil {
		panic("GoRedisClientMock.FTSynUpdateWithArgsFunc: method is nil but GoRedisClient.FTSynUpdateWithArgs was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Index      string
		SynGroupId interface{}
		Options    *redis.FTSynUpdateOptions
		Terms      []interface{}
	}{
		Ctx:        ctx,
		Index:      index,
		SynGroupId: synGroupId,
		Options:    options,
		Terms:      terms,
	}
	mock.lockFTSynUpdateWithArgs.Lock()
	mock.calls.FTSynUpdateWithArgs = append(mock.calls.FTSynUpdateWithArgs, callInfo)
	mock.lockFTSynUpdateWithArgs.Unlock()
	return mock.FTSynUpdateWithArgsFunc(ctx, index, synGroupId, options, terms)
}

// FTSynUpdateWithArgsCalls gets all the calls that were made to FTSynUpdateWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.FTSynUpdateWithArgsCalls())
func (mock *GoRedisClientMock) FTSynUpdateWithArgsCalls() []struct {
	Ctx        context.Context
	Index      string
	SynGroupId interface{}
	Options    *redis.FTSynUpdateOptions
	Terms      []interface{}
} {
	var calls []struct {
		Ctx        context.Context
		Index      string
		SynGroupId interface{}
		Options    *redis.FTSynUpdateOptions
		Terms      []interface{}
	}
	mock.lockFTSynUpdateWithArgs.RLock()
	calls = mock.calls.FTSynUpdateWithArgs
	mock.lockFTSynUpdateWithArgs.RUnlock()
	return calls
}

// FTTagVals calls FTTagValsFunc.
func (mock *GoRedisClientMock) FTTagVals(ctx context.Context, index string, field string) *redis.StringSliceCmd {
	if mock.FTTagValsFunc == nil {
		panic("GoRedisClientMock.FTTagValsFunc: method is nil but GoRedisClient.FTTagVals was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Index string
		Field string
	}{
		Ctx:   ctx,
		Index: index,
		Field: field,
	}
	mock.lockFTTagVals.Lock()
	mock.calls.FTTagVals = append(mock.calls.FTTagVals, callInfo)
	mock.lockFTTagVals.Unlock()
	return mock.FTTagValsFunc(ctx, index, field)
}

// FTTagValsCalls gets all the calls that were made to FTTagVals.
// Check the length with:
//
//	len(mockedGoRedisClient.FTTagValsCalls())
func (mock *GoRedisClientMock) FTTagValsCalls() []struct {
	Ctx   context.Context
	Index string
	Field string
} {
	var calls []struct {
		Ctx   context.Context
		Index string
		Field string
	}
	mock.lockFTTagVals.RLock()
	calls = mock.calls.FTTagVals
	mock.lockFTTagVals.RUnlock()
	return calls
}

// FT_List calls FT_ListFunc.
func (mock *GoRedisClientMock) FT_List(ctx context.Context) *redis.StringSliceCmd {
	if mock.FT_ListFunc == nil {
		panic("GoRedisClientMock.FT_ListFunc: method is nil but GoRedisClient.FT_List was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFT_List.Lock()
	mock.calls.FT_List = append(mock.calls.FT_List, callInfo)
	mock.lockFT_List.Unlock()
	return mock.FT_ListFunc(ctx)
}

// FT_ListCalls gets all the calls that were made to FT_List.
// Check the length with:
//
//	len(mockedGoRedisClient.FT_ListCalls())
func (mock *GoRedisClientMock) FT_ListCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFT_List.RLock()
	calls = mock.calls.FT_List
	mock.lockFT_List.RUnlock()
	return calls
}

// FlushAll calls FlushAllFunc.
func (mock *GoRedisClientMock) FlushAll(ctx context.Context) *redis.StatusCmd {
	if mock.FlushAllFunc == nil {
		panic("GoRedisClientMock.FlushAllFunc: method is nil but GoRedisClient.FlushAll was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFlushAll.Lock()
	mock.calls.FlushAll = append(mock.calls.FlushAll, callInfo)
	mock.lockFlushAll.Unlock()
	return mock.FlushAllFunc(ctx)
}

// FlushAllCalls gets all the calls that were made to FlushAll.
// Check the length with:
//
//	len(mockedGoRedisClient.FlushAllCalls())
func (mock *GoRedisClientMock) FlushAllCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFlushAll.RLock()
	calls = mock.calls.FlushAll
	mock.lockFlushAll.RUnlock()
	return calls
}

// FlushAllAsync calls FlushAllAsyncFunc.
func (mock *GoRedisClientMock) FlushAllAsync(ctx context.Context) *redis.StatusCmd {
	if mock.FlushAllAsyncFunc == nil {
		panic("GoRedisClientMock.FlushAllAsyncFunc: method is nil but GoRedisClient.FlushAllAsync was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFlushAllAsync.Lock()
	mock.calls.FlushAllAsync = append(mock.calls.FlushAllAsync, callInfo)
	mock.lockFlushAllAsync.Unlock()
	return mock.FlushAllAsyncFunc(ctx)
}

// FlushAllAsyncCalls gets all the calls that were made to FlushAllAsync.
// Check the length with:
//
//	len(mockedGoRedisClient.FlushAllAsyncCalls())
func (mock *GoRedisClientMock) FlushAllAsyncCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFlushAllAsync.RLock()
	calls = mock.calls.FlushAllAsync
	mock.lockFlushAllAsync.RUnlock()
	return calls
}

// FlushDB calls FlushDBFunc.
func (mock *GoRedisClientMock) FlushDB(ctx context.Context) *redis.StatusCmd {
	if mock.FlushDBFunc == nil {
		panic("GoRedisClientMock.FlushDBFunc: method is nil but GoRedisClient.FlushDB was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFlushDB.Lock()
	mock.calls.FlushDB = append(mock.calls.FlushDB, callInfo)
	mock.lockFlushDB.Unlock()
	return mock.FlushDBFunc(ctx)
}

// FlushDBCalls gets all the calls that were made to FlushDB.
// Check the length with:
//
//	len(mockedGoRedisClient.FlushDBCalls())
func (mock *GoRedisClientMock) FlushDBCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFlushDB.RLock()
	calls = mock.calls.FlushDB
	mock.lockFlushDB.RUnlock()
	return calls
}

// FlushDBAsync calls FlushDBAsyncFunc.
func (mock *GoRedisClientMock) FlushDBAsync(ctx context.Context) *redis.StatusCmd {
	if mock.FlushDBAsyncFunc == nil {
		panic("GoRedisClientMock.FlushDBAsyncFunc: method is nil but GoRedisClient.FlushDBAsync was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFlushDBAsync.Lock()
	mock.calls.FlushDBAsync = append(mock.calls.FlushDBAsync, callInfo)
	mock.lockFlushDBAsync.Unlock()
	return mock.FlushDBAsyncFunc(ctx)
}

// FlushDBAsyncCalls gets all the calls that were made to FlushDBAsync.
// Check the length with:
//
//	len(mockedGoRedisClient.FlushDBAsyncCalls())
func (mock *GoRedisClientMock) FlushDBAsyncCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFlushDBAsync.RLock()
	calls = mock.calls.FlushDBAsync
	mock.lockFlushDBAsync.RUnlock()
	return calls
}

// FunctionDelete calls FunctionDeleteFunc.
func (mock *GoRedisClientMock) FunctionDelete(ctx context.Context, libName string) *redis.StringCmd {
	if mock.FunctionDeleteFunc == nil {
		panic("GoRedisClientMock.FunctionDeleteFunc: method is nil but GoRedisClient.FunctionDelete was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		LibName string
	}{
		Ctx:     ctx,
		LibName: libName,
	}
	mock.lockFunctionDelete.Lock()
	mock.calls.FunctionDelete = append(mock.calls.FunctionDelete, callInfo)
	mock.lockFunctionDelete.Unlock()
	return mock.FunctionDeleteFunc(ctx, libName)
}

// FunctionDeleteCalls gets all the calls that were made to FunctionDelete.
// Check the length with:
//
//	len(mockedGoRedisClient.FunctionDeleteCalls())
func (mock *GoRedisClientMock) FunctionDeleteCalls() []struct {
	Ctx     context.Context
	LibName string
} {
	var calls []struct {
		Ctx     context.Context
		LibName string
	}
	mock.lockFunctionDelete.RLock()
	calls = mock.calls.FunctionDelete
	mock.lockFunctionDelete.RUnlock()
	return calls
}

// FunctionDump calls FunctionDumpFunc.
func (mock *GoRedisClientMock) FunctionDump(ctx context.Context) *redis.StringCmd {
	if mock.FunctionDumpFunc == nil {
		panic("GoRedisClientMock.FunctionDumpFunc: method is nil but GoRedisClient.FunctionDump was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFunctionDump.Lock()
	mock.calls.FunctionDump = append(mock.calls.FunctionDump, callInfo)
	mock.lockFunctionDump.Unlock()
	return mock.FunctionDumpFunc(ctx)
}

// FunctionDumpCalls gets all the calls that were made to FunctionDump.
// Check the length with:
//
//	len(mockedGoRedisClient.FunctionDumpCalls())
func (mock *GoRedisClientMock) FunctionDumpCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFunctionDump.RLock()
	calls = mock.calls.FunctionDump
	mock.lockFunctionDump.RUnlock()
	return calls
}

// FunctionFlush calls FunctionFlushFunc.
func (mock *GoRedisClientMock) FunctionFlush(ctx context.Context) *redis.StringCmd {
	if mock.FunctionFlushFunc == nil {
		panic("GoRedisClientMock.FunctionFlushFunc: method is nil but GoRedisClient.FunctionFlush was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFunctionFlush.Lock()
	mock.calls.FunctionFlush = append(mock.calls.FunctionFlush, callInfo)
	mock.lockFunctionFlush.Unlock()
	return mock.FunctionFlushFunc(ctx)
}

// FunctionFlushCalls gets all the calls that were made to FunctionFlush.
// Check the length with:
//
//	len(mockedGoRedisClient.FunctionFlushCalls())
func (mock *GoRedisClientMock) FunctionFlushCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFunctionFlush.RLock()
	calls = mock.calls.FunctionFlush
	mock.lockFunctionFlush.RUnlock()
	return calls
}

// FunctionFlushAsync calls FunctionFlushAsyncFunc.
func (mock *GoRedisClientMock) FunctionFlushAsync(ctx context.Context) *redis.StringCmd {
	if mock.FunctionFlushAsyncFunc == nil {
		panic("GoRedisClientMock.FunctionFlushAsyncFunc: method is nil but GoRedisClient.FunctionFlushAsync was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFunctionFlushAsync.Lock()
	mock.calls.FunctionFlushAsync = append(mock.calls.FunctionFlushAsync, callInfo)
	mock.lockFunctionFlushAsync.Unlock()
	return mock.FunctionFlushAsyncFunc(ctx)
}

// FunctionFlushAsyncCalls gets all the calls that were made to FunctionFlushAsync.
// Check the length with:
//
//	len(mockedGoRedisClient.FunctionFlushAsyncCalls())
func (mock *GoRedisClientMock) FunctionFlushAsyncCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFunctionFlushAsync.RLock()
	calls = mock.calls.FunctionFlushAsync
	mock.lockFunctionFlushAsync.RUnlock()
	return calls
}

// FunctionKill calls FunctionKillFunc.
func (mock *GoRedisClientMock) FunctionKill(ctx context.Context) *redis.StringCmd {
	if mock.FunctionKillFunc == nil {
		panic("GoRedisClientMock.FunctionKillFunc: method is nil but GoRedisClient.FunctionKill was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFunctionKill.Lock()
	mock.calls.FunctionKill = append(mock.calls.FunctionKill, callInfo)
	mock.lockFunctionKill.Unlock()
	return mock.FunctionKillFunc(ctx)
}

// FunctionKillCalls gets all the calls that were made to FunctionKill.
// Check the length with:
//
//	len(mockedGoRedisClient.FunctionKillCalls())
func (mock *GoRedisClientMock) FunctionKillCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFunctionKill.RLock()
	calls = mock.calls.FunctionKill
	mock.lockFunctionKill.RUnlock()
	return calls
}

// FunctionList calls FunctionListFunc.
func (mock *GoRedisClientMock) FunctionList(ctx context.Context, q redis.FunctionListQuery) *redis.FunctionListCmd {
	if mock.FunctionListFunc == nil {
		panic("GoRedisClientMock.FunctionListFunc: method is nil but GoRedisClient.FunctionList was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Q   redis.FunctionListQuery
	}{
		Ctx: ctx,
		Q:   q,
	}
	mock.lockFunctionList.Lock()
	mock.calls.FunctionList = append(mock.calls.FunctionList, callInfo)
	mock.lockFunctionList.Unlock()
	return mock.FunctionListFunc(ctx, q)
}

// FunctionListCalls gets all the calls that were made to FunctionList.
// Check the length with:
//
//	len(mockedGoRedisClient.FunctionListCalls())
func (mock *GoRedisClientMock) FunctionListCalls() []struct {
	Ctx context.Context
	Q   redis.FunctionListQuery
} {
	var calls []struct {
		Ctx context.Context
		Q   redis.FunctionListQuery
	}
	mock.lockFunctionList.RLock()
	calls = mock.calls.FunctionList
	mock.lockFunctionList.RUnlock()
	return calls
}

// FunctionLoad calls FunctionLoadFunc.
func (mock *GoRedisClientMock) FunctionLoad(ctx context.Context, code string) *redis.StringCmd {
	if mock.FunctionLoadFunc == nil {
		panic("GoRedisClientMock.FunctionLoadFunc: method is nil but GoRedisClient.FunctionLoad was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Code string
	}{
		Ctx:  ctx,
		Code: code,
	}
	mock.lockFunctionLoad.Lock()
	mock.calls.FunctionLoad = append(mock.calls.FunctionLoad, callInfo)
	mock.lockFunctionLoad.Unlock()
	return mock.FunctionLoadFunc(ctx, code)
}

// FunctionLoadCalls gets all the calls that were made to FunctionLoad.
// Check the length with:
//
//	len(mockedGoRedisClient.FunctionLoadCalls())
func (mock *GoRedisClientMock) FunctionLoadCalls() []struct {
	Ctx  context.Context
	Code string
} {
	var calls []struct {
		Ctx  context.Context
		Code string
	}
	mock.lockFunctionLoad.RLock()
	calls = mock.calls.FunctionLoad
	mock.lockFunctionLoad.RUnlock()
	return calls
}

// FunctionLoadReplace calls FunctionLoadReplaceFunc.
func (mock *GoRedisClientMock) FunctionLoadReplace(ctx context.Context, code string) *redis.StringCmd {
	if mock.FunctionLoadReplaceFunc == nil {
		panic("GoRedisClientMock.FunctionLoadReplaceFunc: method is nil but GoRedisClient.FunctionLoadReplace was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Code string
	}{
		Ctx:  ctx,
		Code: code,
	}
	mock.lockFunctionLoadReplace.Lock()
	mock.calls.FunctionLoadReplace = append(mock.calls.FunctionLoadReplace, callInfo)
	mock.lockFunctionLoadReplace.Unlock()
	return mock.FunctionLoadReplaceFunc(ctx, code)
}

// FunctionLoadReplaceCalls gets all the calls that were made to FunctionLoadReplace.
// Check the length with:
//
//	len(mockedGoRedisClient.FunctionLoadReplaceCalls())
func (mock *GoRedisClientMock) FunctionLoadReplaceCalls() []struct {
	Ctx  context.Context
	Code string
} {
	var calls []struct {
		Ctx  context.Context
		Code string
	}
	mock.lockFunctionLoadReplace.RLock()
	calls = mock.calls.FunctionLoadReplace
	mock.lockFunctionLoadReplace.RUnlock()
	return calls
}

// FunctionRestore calls FunctionRestoreFunc.
func (mock *GoRedisClientMock) FunctionRestore(ctx context.Context, libDump string) *redis.StringCmd {
	if mock.FunctionRestoreFunc == nil {
		panic("GoRedisClientMock.FunctionRestoreFunc: method is nil but GoRedisClient.FunctionRestore was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		LibDump string
	}{
		Ctx:     ctx,
		LibDump: libDump,
	}
	mock.lockFunctionRestore.Lock()
	mock.calls.FunctionRestore = append(mock.calls.FunctionRestore, callInfo)
	mock.lockFunctionRestore.Unlock()
	return mock.FunctionRestoreFunc(ctx, libDump)
}

// FunctionRestoreCalls gets all the calls that were made to FunctionRestore.
// Check the length with:
//
//	len(mockedGoRedisClient.FunctionRestoreCalls())
func (mock *GoRedisClientMock) FunctionRestoreCalls() []struct {
	Ctx     context.Context
	LibDump string
} {
	var calls []struct {
		Ctx     context.Context
		LibDump string
	}
	mock.lockFunctionRestore.RLock()
	calls = mock.calls.FunctionRestore
	mock.lockFunctionRestore.RUnlock()
	return calls
}

// FunctionStats calls FunctionStatsFunc.
func (mock *GoRedisClientMock) FunctionStats(ctx context.Context) *redis.FunctionStatsCmd {
	if mock.FunctionStatsFunc == nil {
		panic("GoRedisClientMock.FunctionStatsFunc: method is nil but GoRedisClient.FunctionStats was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFunctionStats.Lock()
	mock.calls.FunctionStats = append(mock.calls.FunctionStats, callInfo)
	mock.lockFunctionStats.Unlock()
	return mock.FunctionStatsFunc(ctx)
}

// FunctionStatsCalls gets all the calls that were made to FunctionStats.
// Check the length with:
//
//	len(mockedGoRedisClient.FunctionStatsCalls())
func (mock *GoRedisClientMock) FunctionStatsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFunctionStats.RLock()
	calls = mock.calls.FunctionStats
	mock.lockFunctionStats.RUnlock()
	return calls
}

// GeoAdd calls GeoAddFunc.
func (mock *GoRedisClientMock) GeoAdd(ctx context.Context, key string, geoLocation ...*redis.GeoLocation) *redis.IntCmd {
	if mock.GeoAddFunc == nil {
		panic("GoRedisClientMock.GeoAddFunc: method is nil but GoRedisClient.GeoAdd was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Key         string
		GeoLocation []*redis.GeoLocation
	}{
		Ctx:         ctx,
		Key:         key,
		GeoLocation: geoLocation,
	}
	mock.lockGeoAdd.Lock()
	mock.calls.GeoAdd = append(mock.calls.GeoAdd, callInfo)
	mock.lockGeoAdd.Unlock()
	return mock.GeoAddFunc(ctx, key, geoLocation...)
}

// GeoAddCalls gets all the calls that were made to GeoAdd.
// Check the length with:
//
//	len(mockedGoRedisClient.GeoAddCalls())
func (mock *GoRedisClientMock) GeoAddCalls() []struct {
	Ctx         context.Context
	Key         string
	GeoLocation []*redis.GeoLocation
} {
	var calls []struct {
		Ctx         context.Context
		Key         string
		GeoLocation []*redis.GeoLocation
	}
	mock.lockGeoAdd.RLock()
	calls = mock.calls.GeoAdd
	mock.lockGeoAdd.RUnlock()
	return calls
}

// GeoDist calls GeoDistFunc.
func (mock *GoRedisClientMock) GeoDist(ctx context.Context, key string, member1 string, member2 string, unit string) *redis.FloatCmd {
	if mock.GeoDistFunc == nil {
		panic("GoRedisClientMock.GeoDistFunc: method is nil but GoRedisClient.GeoDist was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Member1 string
		Member2 string
		Unit    string
	}{
		Ctx:     ctx,
		Key:     key,
		Member1: member1,
		Member2: member2,
		Unit:    unit,
	}
	mock.lockGeoDist.Lock()
	mock.calls.GeoDist = append(mock.calls.GeoDist, callInfo)
	mock.lockGeoDist.Unlock()
	return mock.GeoDistFunc(ctx, key, member1, member2, unit)
}

// GeoDistCalls gets all the calls that were made to GeoDist.
// Check the length with:
//
//	len(mockedGoRedisClient.GeoDistCalls())
func (mock *GoRedisClientMock) GeoDistCalls() []struct {
	Ctx     context.Context
	Key     string
	Member1 string
	Member2 string
	Unit    string
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Member1 string
		Member2 string
		Unit    string
	}
	mock.lockGeoDist.RLock()
	calls = mock.calls.GeoDist
	mock.lockGeoDist.RUnlock()
	return calls
}

// GeoHash calls GeoHashFunc.
func (mock *GoRedisClientMock) GeoHash(ctx context.Context, key string, members ...string) *redis.StringSliceCmd {
	if mock.GeoHashFunc == nil {
		panic("GoRedisClientMock.GeoHashFunc: method is nil but GoRedisClient.GeoHash was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []string
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockGeoHash.Lock()
	mock.calls.GeoHash = append(mock.calls.GeoHash, callInfo)
	mock.lockGeoHash.Unlock()
	return mock.GeoHashFunc(ctx, key, members...)
}

// GeoHashCalls gets all the calls that were made to GeoHash.
// Check the length with:
//
//	len(mockedGoRedisClient.GeoHashCalls())
func (mock *GoRedisClientMock) GeoHashCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []string
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []string
	}
	mock.lockGeoHash.RLock()
	calls = mock.calls.GeoHash
	mock.lockGeoHash.RUnlock()
	return calls
}

// GeoPos calls GeoPosFunc.
func (mock *GoRedisClientMock) GeoPos(ctx context.Context, key string, members ...string) *redis.GeoPosCmd {
	if mock.GeoPosFunc == nil {
		panic("GoRedisClientMock.GeoPosFunc: method is nil but GoRedisClient.GeoPos was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []string
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockGeoPos.Lock()
	mock.calls.GeoPos = append(mock.calls.GeoPos, callInfo)
	mock.lockGeoPos.Unlock()
	return mock.GeoPosFunc(ctx, key, members...)
}

// GeoPosCalls gets all the calls that were made to GeoPos.
// Check the length with:
//
//	len(mockedGoRedisClient.GeoPosCalls())
func (mock *GoRedisClientMock) GeoPosCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []string
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []string
	}
	mock.lockGeoPos.RLock()
	calls = mock.calls.GeoPos
	mock.lockGeoPos.RUnlock()
	return calls
}

// GeoRadius calls GeoRadiusFunc.
func (mock *GoRedisClientMock) GeoRadius(ctx context.Context, key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
	if mock.GeoRadiusFunc == nil {
		panic("GoRedisClientMock.GeoRadiusFunc: method is nil but GoRedisClient.GeoRadius was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		Longitude float64
		Latitude  float64
		Query     *redis.GeoRadiusQuery
	}{
		Ctx:       ctx,
		Key:       key,
		Longitude: longitude,
		Latitude:  latitude,
		Query:     query,
	}
	mock.lockGeoRadius.Lock()
	mock.calls.GeoRadius = append(mock.calls.GeoRadius, callInfo)
	mock.lockGeoRadius.Unlock()
	return mock.GeoRadiusFunc(ctx, key, longitude, latitude, query)
}

// GeoRadiusCalls gets all the calls that were made to GeoRadius.
// Check the length with:
//
//	len(mockedGoRedisClient.GeoRadiusCalls())
func (mock *GoRedisClientMock) GeoRadiusCalls() []struct {
	Ctx       context.Context
	Key       string
	Longitude float64
	Latitude  float64
	Query     *redis.GeoRadiusQuery
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		Longitude float64
		Latitude  float64
		Query     *redis.GeoRadiusQuery
	}
	mock.lockGeoRadius.RLock()
	calls = mock.calls.GeoRadius
	mock.lockGeoRadius.RUnlock()
	return calls
}

// GeoRadiusByMember calls GeoRadiusByMemberFunc.
func (mock *GoRedisClientMock) GeoRadiusByMember(ctx context.Context, key string, member string, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
	if mock.GeoRadiusByMemberFunc == nil {
		panic("GoRedisClientMock.GeoRadiusByMemberFunc: method is nil but GoRedisClient.GeoRadiusByMember was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Member string
		Query  *redis.GeoRadiusQuery
	}{
		Ctx:    ctx,
		Key:    key,
		Member: member,
		Query:  query,
	}
	mock.lockGeoRadiusByMember.Lock()
	mock.calls.GeoRadiusByMember = append(mock.calls.GeoRadiusByMember, callInfo)
	mock.lockGeoRadiusByMember.Unlock()
	return mock.GeoRadiusByMemberFunc(ctx, key, member, query)
}

// GeoRadiusByMemberCalls gets all the calls that were made to GeoRadiusByMember.
// Check the length with:
//
//	len(mockedGoRedisClient.GeoRadiusByMemberCalls())
func (mock *GoRedisClientMock) GeoRadiusByMemberCalls() []struct {
	Ctx    context.Context
	Key    string
	Member string
	Query  *redis.GeoRadiusQuery
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Member string
		Query  *redis.GeoRadiusQuery
	}
	mock.lockGeoRadiusByMember.RLock()
	calls = mock.calls.GeoRadiusByMember
	mock.lockGeoRadiusByMember.RUnlock()
	return calls
}

// GeoRadiusByMemberStore calls GeoRadiusByMemberStoreFunc.
func (mock *GoRedisClientMock) GeoRadiusByMemberStore(ctx context.Context, key string, member string, query *redis.GeoRadiusQuery) *redis.IntCmd {
	if mock.GeoRadiusByMemberStoreFunc == nil {
		panic("GoRedisClientMock.GeoRadiusByMemberStoreFunc: method is nil but GoRedisClient.GeoRadiusByMemberStore was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Member string
		Query  *redis.GeoRadiusQuery
	}{
		Ctx:    ctx,
		Key:    key,
		Member: member,
		Query:  query,
	}
	mock.lockGeoRadiusByMemberStore.Lock()
	mock.calls.GeoRadiusByMemberStore = append(mock.calls.GeoRadiusByMemberStore, callInfo)
	mock.lockGeoRadiusByMemberStore.Unlock()
	return mock.GeoRadiusByMemberStoreFunc(ctx, key, member, query)
}

// GeoRadiusByMemberStoreCalls gets all the calls that were made to GeoRadiusByMemberStore.
// Check the length with:
//
//	len(mockedGoRedisClient.GeoRadiusByMemberStoreCalls())
func (mock *GoRedisClientMock) GeoRadiusByMemberStoreCalls() []struct {
	Ctx    context.Context
	Key    string
	Member string
	Query  *redis.GeoRadiusQuery
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Member string
		Query  *redis.GeoRadiusQuery
	}
	mock.lockGeoRadiusByMemberStore.RLock()
	calls = mock.calls.GeoRadiusByMemberStore
	mock.lockGeoRadiusByMemberStore.RUnlock()
	return calls
}

// GeoRadiusStore calls GeoRadiusStoreFunc.
func (mock *GoRedisClientMock) GeoRadiusStore(ctx context.Context, key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.IntCmd {
	if mock.GeoRadiusStoreFunc == nil {
		panic("GoRedisClientMock.GeoRadiusStoreFunc: method is nil but GoRedisClient.GeoRadiusStore was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		Longitude float64
		Latitude  float64
		Query     *redis.GeoRadiusQuery
	}{
		Ctx:       ctx,
		Key:       key,
		Longitude: longitude,
		Latitude:  latitude,
		Query:     query,
	}
	mock.lockGeoRadiusStore.Lock()
	mock.calls.GeoRadiusStore = append(mock.calls.GeoRadiusStore, callInfo)
	mock.lockGeoRadiusStore.Unlock()
	return mock.GeoRadiusStoreFunc(ctx, key, longitude, latitude, query)
}

// GeoRadiusStoreCalls gets all the calls that were made to GeoRadiusStore.
// Check the length with:
//
//	len(mockedGoRedisClient.GeoRadiusStoreCalls())
func (mock *GoRedisClientMock) GeoRadiusStoreCalls() []struct {
	Ctx       context.Context
	Key       string
	Longitude float64
	Latitude  float64
	Query     *redis.GeoRadiusQuery
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		Longitude float64
		Latitude  float64
		Query     *redis.GeoRadiusQuery
	}
	mock.lockGeoRadiusStore.RLock()
	calls = mock.calls.GeoRadiusStore
	mock.lockGeoRadiusStore.RUnlock()
	return calls
}

// GeoSearch calls GeoSearchFunc.
func (mock *GoRedisClientMock) GeoSearch(ctx context.Context, key string, q *redis.GeoSearchQuery) *redis.StringSliceCmd {
	if mock.GeoSearchFunc == nil {
		panic("GoRedisClientMock.GeoSearchFunc: method is nil but GoRedisClient.GeoSearch was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Q   *redis.GeoSearchQuery
	}{
		Ctx: ctx,
		Key: key,
		Q:   q,
	}
	mock.lockGeoSearch.Lock()
	mock.calls.GeoSearch = append(mock.calls.GeoSearch, callInfo)
	mock.lockGeoSearch.Unlock()
	return mock.GeoSearchFunc(ctx, key, q)
}

// GeoSearchCalls gets all the calls that were made to GeoSearch.
// Check the length with:
//
//	len(mockedGoRedisClient.GeoSearchCalls())
func (mock *GoRedisClientMock) GeoSearchCalls() []struct {
	Ctx context.Context
	Key string
	Q   *redis.GeoSearchQuery
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Q   *redis.GeoSearchQuery
	}
	mock.lockGeoSearch.RLock()
	calls = mock.calls.GeoSearch
	mock.lockGeoSearch.RUnlock()
	return calls
}

// GeoSearchLocation calls GeoSearchLocationFunc.
func (mock *GoRedisClientMock) GeoSearchLocation(ctx context.Context, key string, q *redis.GeoSearchLocationQuery) *redis.GeoSearchLocationCmd {
	if mock.GeoSearchLocationFunc == nil {
		panic("GoRedisClientMock.GeoSearchLocationFunc: method is nil but GoRedisClient.GeoSearchLocation was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Q   *redis.GeoSearchLocationQuery
	}{
		Ctx: ctx,
		Key: key,
		Q:   q,
	}
	mock.lockGeoSearchLocation.Lock()
	mock.calls.GeoSearchLocation = append(mock.calls.GeoSearchLocation, callInfo)
	mock.lockGeoSearchLocation.Unlock()
	return mock.GeoSearchLocationFunc(ctx, key, q)
}

// GeoSearchLocationCalls gets all the calls that were made to GeoSearchLocation.
// Check the length with:
//
//	len(mockedGoRedisClient.GeoSearchLocationCalls())
func (mock *GoRedisClientMock) GeoSearchLocationCalls() []struct {
	Ctx context.Context
	Key string
	Q   *redis.GeoSearchLocationQuery
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Q   *redis.GeoSearchLocationQuery
	}
	mock.lockGeoSearchLocation.RLock()
	calls = mock.calls.GeoSearchLocation
	mock.lockGeoSearchLocation.RUnlock()
	return calls
}

// GeoSearchStore calls GeoSearchStoreFunc.
func (mock *GoRedisClientMock) GeoSearchStore(ctx context.Context, key string, store string, q *redis.GeoSearchStoreQuery) *redis.IntCmd {
	if mock.GeoSearchStoreFunc == nil {
		panic("GoRedisClientMock.GeoSearchStoreFunc: method is nil but GoRedisClient.GeoSearchStore was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Store string
		Q     *redis.GeoSearchStoreQuery
	}{
		Ctx:   ctx,
		Key:   key,
		Store: store,
		Q:     q,
	}
	mock.lockGeoSearchStore.Lock()
	mock.calls.GeoSearchStore = append(mock.calls.GeoSearchStore, callInfo)
	mock.lockGeoSearchStore.Unlock()
	return mock.GeoSearchStoreFunc(ctx, key, store, q)
}

// GeoSearchStoreCalls gets all the calls that were made to GeoSearchStore.
// Check the length with:
//
//	len(mockedGoRedisClient.GeoSearchStoreCalls())
func (mock *GoRedisClientMock) GeoSearchStoreCalls() []struct {
	Ctx   context.Context
	Key   string
	Store string
	Q     *redis.GeoSearchStoreQuery
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Store string
		Q     *redis.GeoSearchStoreQuery
	}
	mock.lockGeoSearchStore.RLock()
	calls = mock.calls.GeoSearchStore
	mock.lockGeoSearchStore.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *GoRedisClientMock) Get(ctx context.Context, key string) *redis.StringCmd {
	if mock.GetFunc == nil {
		panic("GoRedisClientMock.GetFunc: method is nil but GoRedisClient.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, key)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedGoRedisClient.GetCalls())
func (mock *GoRedisClientMock) GetCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// GetBit calls GetBitFunc.
func (mock *GoRedisClientMock) GetBit(ctx context.Context, key string, offset int64) *redis.IntCmd {
	if mock.GetBitFunc == nil {
		panic("GoRedisClientMock.GetBitFunc: method is nil but GoRedisClient.GetBit was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Offset int64
	}{
		Ctx:    ctx,
		Key:    key,
		Offset: offset,
	}
	mock.lockGetBit.Lock()
	mock.calls.GetBit = append(mock.calls.GetBit, callInfo)
	mock.lockGetBit.Unlock()
	return mock.GetBitFunc(ctx, key, offset)
}

// GetBitCalls gets all the calls that were made to GetBit.
// Check the length with:
//
//	len(mockedGoRedisClient.GetBitCalls())
func (mock *GoRedisClientMock) GetBitCalls() []struct {
	Ctx    context.Context
	Key    string
	Offset int64
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Offset int64
	}
	mock.lockGetBit.RLock()
	calls = mock.calls.GetBit
	mock.lockGetBit.RUnlock()
	return calls
}

// GetDel calls GetDelFunc.
func (mock *GoRedisClientMock) GetDel(ctx context.Context, key string) *redis.StringCmd {
	if mock.GetDelFunc == nil {
		panic("GoRedisClientMock.GetDelFunc: method is nil but GoRedisClient.GetDel was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockGetDel.Lock()
	mock.calls.GetDel = append(mock.calls.GetDel, callInfo)
	mock.lockGetDel.Unlock()
	return mock.GetDelFunc(ctx, key)
}

// GetDelCalls gets all the calls that were made to GetDel.
// Check the length with:
//
//	len(mockedGoRedisClient.GetDelCalls())
func (mock *GoRedisClientMock) GetDelCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockGetDel.RLock()
	calls = mock.calls.GetDel
	mock.lockGetDel.RUnlock()
	return calls
}

// GetEx calls GetExFunc.
func (mock *GoRedisClientMock) GetEx(ctx context.Context, key string, expiration time.Duration) *redis.StringCmd {
	if mock.GetExFunc == nil {
		panic("GoRedisClientMock.GetExFunc: method is nil but GoRedisClient.GetEx was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Expiration: expiration,
	}
	mock.lockGetEx.Lock()
	mock.calls.GetEx = append(mock.calls.GetEx, callInfo)
	mock.lockGetEx.Unlock()
	return mock.GetExFunc(ctx, key, expiration)
}

// GetExCalls gets all the calls that were made to GetEx.
// Check the length with:
//
//	len(mockedGoRedisClient.GetExCalls())
func (mock *GoRedisClientMock) GetExCalls() []struct {
	Ctx        context.Context
	Key        string
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}
	mock.lockGetEx.RLock()
	calls = mock.calls.GetEx
	mock.lockGetEx.RUnlock()
	return calls
}

// GetRange calls GetRangeFunc.
func (mock *GoRedisClientMock) GetRange(ctx context.Context, key string, start int64, end int64) *redis.StringCmd {
	if mock.GetRangeFunc == nil {
		panic("GoRedisClientMock.GetRangeFunc: method is nil but GoRedisClient.GetRange was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Start int64
		End   int64
	}{
		Ctx:   ctx,
		Key:   key,
		Start: start,
		End:   end,
	}
	mock.lockGetRange.Lock()
	mock.calls.GetRange = append(mock.calls.GetRange, callInfo)
	mock.lockGetRange.Unlock()
	return mock.GetRangeFunc(ctx, key, start, end)
}

// GetRangeCalls gets all the calls that were made to GetRange.
// Check the length with:
//
//	len(mockedGoRedisClient.GetRangeCalls())
func (mock *GoRedisClientMock) GetRangeCalls() []struct {
	Ctx   context.Context
	Key   string
	Start int64
	End   int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Start int64
		End   int64
	}
	mock.lockGetRange.RLock()
	calls = mock.calls.GetRange
	mock.lockGetRange.RUnlock()
	return calls
}

// GetSet calls GetSetFunc.
func (mock *GoRedisClientMock) GetSet(ctx context.Context, key string, value interface{}) *redis.StringCmd {
	if mock.GetSetFunc == nil {
		panic("GoRedisClientMock.GetSetFunc: method is nil but GoRedisClient.GetSet was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Value interface{}
	}{
		Ctx:   ctx,
		Key:   key,
		Value: value,
	}
	mock.lockGetSet.Lock()
	mock.calls.GetSet = append(mock.calls.GetSet, callInfo)
	mock.lockGetSet.Unlock()
	return mock.GetSetFunc(ctx, key, value)
}

// GetSetCalls gets all the calls that were made to GetSet.
// Check the length with:
//
//	len(mockedGoRedisClient.GetSetCalls())
func (mock *GoRedisClientMock) GetSetCalls() []struct {
	Ctx   context.Context
	Key   string
	Value interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Value interface{}
	}
	mock.lockGetSet.RLock()
	calls = mock.calls.GetSet
	mock.lockGetSet.RUnlock()
	return calls
}

// HDel calls HDelFunc.
func (mock *GoRedisClientMock) HDel(ctx context.Context, key string, fields ...string) *redis.IntCmd {
	if mock.HDelFunc == nil {
		panic("GoRedisClientMock.HDelFunc: method is nil but GoRedisClient.HDel was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}{
		Ctx:    ctx,
		Key:    key,
		Fields: fields,
	}
	mock.lockHDel.Lock()
	mock.calls.HDel = append(mock.calls.HDel, callInfo)
	mock.lockHDel.Unlock()
	return mock.HDelFunc(ctx, key, fields...)
}

// HDelCalls gets all the calls that were made to HDel.
// Check the length with:
//
//	len(mockedGoRedisClient.HDelCalls())
func (mock *GoRedisClientMock) HDelCalls() []struct {
	Ctx    context.Context
	Key    string
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}
	mock.lockHDel.RLock()
	calls = mock.calls.HDel
	mock.lockHDel.RUnlock()
	return calls
}

// HExists calls HExistsFunc.
func (mock *GoRedisClientMock) HExists(ctx context.Context, key string, field string) *redis.BoolCmd {
	if mock.HExistsFunc == nil {
		panic("GoRedisClientMock.HExistsFunc: method is nil but GoRedisClient.HExists was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Field string
	}{
		Ctx:   ctx,
		Key:   key,
		Field: field,
	}
	mock.lockHExists.Lock()
	mock.calls.HExists = append(mock.calls.HExists, callInfo)
	mock.lockHExists.Unlock()
	return mock.HExistsFunc(ctx, key, field)
}

// HExistsCalls gets all the calls that were made to HExists.
// Check the length with:
//
//	len(mockedGoRedisClient.HExistsCalls())
func (mock *GoRedisClientMock) HExistsCalls() []struct {
	Ctx   context.Context
	Key   string
	Field string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Field string
	}
	mock.lockHExists.RLock()
	calls = mock.calls.HExists
	mock.lockHExists.RUnlock()
	return calls
}

// HExpire calls HExpireFunc.
func (mock *GoRedisClientMock) HExpire(ctx context.Context, key string, expiration time.Duration, fields ...string) *redis.IntSliceCmd {
	if mock.HExpireFunc == nil {
		panic("GoRedisClientMock.HExpireFunc: method is nil but GoRedisClient.HExpire was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
		Fields     []string
	}{
		Ctx:        ctx,
		Key:        key,
		Expiration: expiration,
		Fields:     fields,
	}
	mock.lockHExpire.Lock()
	mock.calls.HExpire = append(mock.calls.HExpire, callInfo)
	mock.lockHExpire.Unlock()
	return mock.HExpireFunc(ctx, key, expiration, fields...)
}

// HExpireCalls gets all the calls that were made to HExpire.
// Check the length with:
//
//	len(mockedGoRedisClient.HExpireCalls())
func (mock *GoRedisClientMock) HExpireCalls() []struct {
	Ctx        context.Context
	Key        string
	Expiration time.Duration
	Fields     []string
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
		Fields     []string
	}
	mock.lockHExpire.RLock()
	calls = mock.calls.HExpire
	mock.lockHExpire.RUnlock()
	return calls
}

// HExpireAt calls HExpireAtFunc.
func (mock *GoRedisClientMock) HExpireAt(ctx context.Context, key string, tm time.Time, fields ...string) *redis.IntSliceCmd {
	if mock.HExpireAtFunc == nil {
		panic("GoRedisClientMock.HExpireAtFunc: method is nil but GoRedisClient.HExpireAt was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Tm     time.Time
		Fields []string
	}{
		Ctx:    ctx,
		Key:    key,
		Tm:     tm,
		Fields: fields,
	}
	mock.lockHExpireAt.Lock()
	mock.calls.HExpireAt = append(mock.calls.HExpireAt, callInfo)
	mock.lockHExpireAt.Unlock()
	return mock.HExpireAtFunc(ctx, key, tm, fields...)
}

// HExpireAtCalls gets all the calls that were made to HExpireAt.
// Check the length with:
//
//	len(mockedGoRedisClient.HExpireAtCalls())
func (mock *GoRedisClientMock) HExpireAtCalls() []struct {
	Ctx    context.Context
	Key    string
	Tm     time.Time
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Tm     time.Time
		Fields []string
	}
	mock.lockHExpireAt.RLock()
	calls = mock.calls.HExpireAt
	mock.lockHExpireAt.RUnlock()
	return calls
}

// HExpireAtWithArgs calls HExpireAtWithArgsFunc.
func (mock *GoRedisClientMock) HExpireAtWithArgs(ctx context.Context, key string, tm time.Time, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
	if mock.HExpireAtWithArgsFunc == nil {
		panic("GoRedisClientMock.HExpireAtWithArgsFunc: method is nil but GoRedisClient.HExpireAtWithArgs was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		Key            string
		Tm             time.Time
		ExpirationArgs redis.HExpireArgs
		Fields         []string
	}{
		Ctx:            ctx,
		Key:            key,
		Tm:             tm,
		ExpirationArgs: expirationArgs,
		Fields:         fields,
	}
	mock.lockHExpireAtWithArgs.Lock()
	mock.calls.HExpireAtWithArgs = append(mock.calls.HExpireAtWithArgs, callInfo)
	mock.lockHExpireAtWithArgs.Unlock()
	return mock.HExpireAtWithArgsFunc(ctx, key, tm, expirationArgs, fields...)
}

// HExpireAtWithArgsCalls gets all the calls that were made to HExpireAtWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.HExpireAtWithArgsCalls())
func (mock *GoRedisClientMock) HExpireAtWithArgsCalls() []struct {
	Ctx            context.Context
	Key            string
	Tm             time.Time
	ExpirationArgs redis.HExpireArgs
	Fields         []string
} {
	var calls []struct {
		Ctx            context.Context
		Key            string
		Tm             time.Time
		ExpirationArgs redis.HExpireArgs
		Fields         []string
	}
	mock.lockHExpireAtWithArgs.RLock()
	calls = mock.calls.HExpireAtWithArgs
	mock.lockHExpireAtWithArgs.RUnlock()
	return calls
}

// HExpireTime calls HExpireTimeFunc.
func (mock *GoRedisClientMock) HExpireTime(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
	if mock.HExpireTimeFunc == nil {
		panic("GoRedisClientMock.HExpireTimeFunc: method is nil but GoRedisClient.HExpireTime was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}{
		Ctx:    ctx,
		Key:    key,
		Fields: fields,
	}
	mock.lockHExpireTime.Lock()
	mock.calls.HExpireTime = append(mock.calls.HExpireTime, callInfo)
	mock.lockHExpireTime.Unlock()
	return mock.HExpireTimeFunc(ctx, key, fields...)
}

// HExpireTimeCalls gets all the calls that were made to HExpireTime.
// Check the length with:
//
//	len(mockedGoRedisClient.HExpireTimeCalls())
func (mock *GoRedisClientMock) HExpireTimeCalls() []struct {
	Ctx    context.Context
	Key    string
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}
	mock.lockHExpireTime.RLock()
	calls = mock.calls.HExpireTime
	mock.lockHExpireTime.RUnlock()
	return calls
}

// HExpireWithArgs calls HExpireWithArgsFunc.
func (mock *GoRedisClientMock) HExpireWithArgs(ctx context.Context, key string, expiration time.Duration, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
	if mock.HExpireWithArgsFunc == nil {
		panic("GoRedisClientMock.HExpireWithArgsFunc: method is nil but GoRedisClient.HExpireWithArgs was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		Key            string
		Expiration     time.Duration
		ExpirationArgs redis.HExpireArgs
		Fields         []string
	}{
		Ctx:            ctx,
		Key:            key,
		Expiration:     expiration,
		ExpirationArgs: expirationArgs,
		Fields:         fields,
	}
	mock.lockHExpireWithArgs.Lock()
	mock.calls.HExpireWithArgs = append(mock.calls.HExpireWithArgs, callInfo)
	mock.lockHExpireWithArgs.Unlock()
	return mock.HExpireWithArgsFunc(ctx, key, expiration, expirationArgs, fields...)
}

// HExpireWithArgsCalls gets all the calls that were made to HExpireWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.HExpireWithArgsCalls())
func (mock *GoRedisClientMock) HExpireWithArgsCalls() []struct {
	Ctx            context.Context
	Key            string
	Expiration     time.Duration
	ExpirationArgs redis.HExpireArgs
	Fields         []string
} {
	var calls []struct {
		Ctx            context.Context
		Key            string
		Expiration     time.Duration
		ExpirationArgs redis.HExpireArgs
		Fields         []string
	}
	mock.lockHExpireWithArgs.RLock()
	calls = mock.calls.HExpireWithArgs
	mock.lockHExpireWithArgs.RUnlock()
	return calls
}

// HGet calls HGetFunc.
func (mock *GoRedisClientMock) HGet(ctx context.Context, key string, field string) *redis.StringCmd {
	if mock.HGetFunc == nil {
		panic("GoRedisClientMock.HGetFunc: method is nil but GoRedisClient.HGet was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Field string
	}{
		Ctx:   ctx,
		Key:   key,
		Field: field,
	}
	mock.lockHGet.Lock()
	mock.calls.HGet = append(mock.calls.HGet, callInfo)
	mock.lockHGet.Unlock()
	return mock.HGetFunc(ctx, key, field)
}

// HGetCalls gets all the calls that were made to HGet.
// Check the length with:
//
//	len(mockedGoRedisClient.HGetCalls())
func (mock *GoRedisClientMock) HGetCalls() []struct {
	Ctx   context.Context
	Key   string
	Field string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Field string
	}
	mock.lockHGet.RLock()
	calls = mock.calls.HGet
	mock.lockHGet.RUnlock()
	return calls
}

// HGetAll calls HGetAllFunc.
func (mock *GoRedisClientMock) HGetAll(ctx context.Context, key string) *redis.MapStringStringCmd {
	if mock.HGetAllFunc == nil {
		panic("GoRedisClientMock.HGetAllFunc: method is nil but GoRedisClient.HGetAll was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockHGetAll.Lock()
	mock.calls.HGetAll = append(mock.calls.HGetAll, callInfo)
	mock.lockHGetAll.Unlock()
	return mock.HGetAllFunc(ctx, key)
}

// HGetAllCalls gets all the calls that were made to HGetAll.
// Check the length with:
//
//	len(mockedGoRedisClient.HGetAllCalls())
func (mock *GoRedisClientMock) HGetAllCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockHGetAll.RLock()
	calls = mock.calls.HGetAll
	mock.lockHGetAll.RUnlock()
	return calls
}

// HGetDel calls HGetDelFunc.
func (mock *GoRedisClientMock) HGetDel(ctx context.Context, key string, fields ...string) *redis.StringSliceCmd {
	if mock.HGetDelFunc == nil {
		panic("GoRedisClientMock.HGetDelFunc: method is nil but GoRedisClient.HGetDel was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}{
		Ctx:    ctx,
		Key:    key,
		Fields: fields,
	}
	mock.lockHGetDel.Lock()
	mock.calls.HGetDel = append(mock.calls.HGetDel, callInfo)
	mock.lockHGetDel.Unlock()
	return mock.HGetDelFunc(ctx, key, fields...)
}

// HGetDelCalls gets all the calls that were made to HGetDel.
// Check the length with:
//
//	len(mockedGoRedisClient.HGetDelCalls())
func (mock *GoRedisClientMock) HGetDelCalls() []struct {
	Ctx    context.Context
	Key    string
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}
	mock.lockHGetDel.RLock()
	calls = mock.calls.HGetDel
	mock.lockHGetDel.RUnlock()
	return calls
}

// HGetEX calls HGetEXFunc.
func (mock *GoRedisClientMock) HGetEX(ctx context.Context, key string, fields ...string) *redis.StringSliceCmd {
	if mock.HGetEXFunc == nil {
		panic("GoRedisClientMock.HGetEXFunc: method is nil but GoRedisClient.HGetEX was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}{
		Ctx:    ctx,
		Key:    key,
		Fields: fields,
	}
	mock.lockHGetEX.Lock()
	mock.calls.HGetEX = append(mock.calls.HGetEX, callInfo)
	mock.lockHGetEX.Unlock()
	return mock.HGetEXFunc(ctx, key, fields...)
}

// HGetEXCalls gets all the calls that were made to HGetEX.
// Check the length with:
//
//	len(mockedGoRedisClient.HGetEXCalls())
func (mock *GoRedisClientMock) HGetEXCalls() []struct {
	Ctx    context.Context
	Key    string
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}
	mock.lockHGetEX.RLock()
	calls = mock.calls.HGetEX
	mock.lockHGetEX.RUnlock()
	return calls
}

// HGetEXWithArgs calls HGetEXWithArgsFunc.
func (mock *GoRedisClientMock) HGetEXWithArgs(ctx context.Context, key string, options *redis.HGetEXOptions, fields ...string) *redis.StringSliceCmd {
	if mock.HGetEXWithArgsFunc == nil {
		panic("GoRedisClientMock.HGetEXWithArgsFunc: method is nil but GoRedisClient.HGetEXWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Options *redis.HGetEXOptions
		Fields  []string
	}{
		Ctx:     ctx,
		Key:     key,
		Options: options,
		Fields:  fields,
	}
	mock.lockHGetEXWithArgs.Lock()
	mock.calls.HGetEXWithArgs = append(mock.calls.HGetEXWithArgs, callInfo)
	mock.lockHGetEXWithArgs.Unlock()
	return mock.HGetEXWithArgsFunc(ctx, key, options, fields...)
}

// HGetEXWithArgsCalls gets all the calls that were made to HGetEXWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.HGetEXWithArgsCalls())
func (mock *GoRedisClientMock) HGetEXWithArgsCalls() []struct {
	Ctx     context.Context
	Key     string
	Options *redis.HGetEXOptions
	Fields  []string
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Options *redis.HGetEXOptions
		Fields  []string
	}
	mock.lockHGetEXWithArgs.RLock()
	calls = mock.calls.HGetEXWithArgs
	mock.lockHGetEXWithArgs.RUnlock()
	return calls
}

// HIncrBy calls HIncrByFunc.
func (mock *GoRedisClientMock) HIncrBy(ctx context.Context, key string, field string, incr int64) *redis.IntCmd {
	if mock.HIncrByFunc == nil {
		panic("GoRedisClientMock.HIncrByFunc: method is nil but GoRedisClient.HIncrBy was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Field string
		Incr  int64
	}{
		Ctx:   ctx,
		Key:   key,
		Field: field,
		Incr:  incr,
	}
	mock.lockHIncrBy.Lock()
	mock.calls.HIncrBy = append(mock.calls.HIncrBy, callInfo)
	mock.lockHIncrBy.Unlock()
	return mock.HIncrByFunc(ctx, key, field, incr)
}

// HIncrByCalls gets all the calls that were made to HIncrBy.
// Check the length with:
//
//	len(mockedGoRedisClient.HIncrByCalls())
func (mock *GoRedisClientMock) HIncrByCalls() []struct {
	Ctx   context.Context
	Key   string
	Field string
	Incr  int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Field string
		Incr  int64
	}
	mock.lockHIncrBy.RLock()
	calls = mock.calls.HIncrBy
	mock.lockHIncrBy.RUnlock()
	return calls
}

// HIncrByFloat calls HIncrByFloatFunc.
func (mock *GoRedisClientMock) HIncrByFloat(ctx context.Context, key string, field string, incr float64) *redis.FloatCmd {
	if mock.HIncrByFloatFunc == nil {
		panic("GoRedisClientMock.HIncrByFloatFunc: method is nil but GoRedisClient.HIncrByFloat was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Field string
		Incr  float64
	}{
		Ctx:   ctx,
		Key:   key,
		Field: field,
		Incr:  incr,
	}
	mock.lockHIncrByFloat.Lock()
	mock.calls.HIncrByFloat = append(mock.calls.HIncrByFloat, callInfo)
	mock.lockHIncrByFloat.Unlock()
	return mock.HIncrByFloatFunc(ctx, key, field, incr)
}

// HIncrByFloatCalls gets all the calls that were made to HIncrByFloat.
// Check the length with:
//
//	len(mockedGoRedisClient.HIncrByFloatCalls())
func (mock *GoRedisClientMock) HIncrByFloatCalls() []struct {
	Ctx   context.Context
	Key   string
	Field string
	Incr  float64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Field string
		Incr  float64
	}
	mock.lockHIncrByFloat.RLock()
	calls = mock.calls.HIncrByFloat
	mock.lockHIncrByFloat.RUnlock()
	return calls
}

// HKeys calls HKeysFunc.
func (mock *GoRedisClientMock) HKeys(ctx context.Context, key string) *redis.StringSliceCmd {
	if mock.HKeysFunc == nil {
		panic("GoRedisClientMock.HKeysFunc: method is nil but GoRedisClient.HKeys was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockHKeys.Lock()
	mock.calls.HKeys = append(mock.calls.HKeys, callInfo)
	mock.lockHKeys.Unlock()
	return mock.HKeysFunc(ctx, key)
}

// HKeysCalls gets all the calls that were made to HKeys.
// Check the length with:
//
//	len(mockedGoRedisClient.HKeysCalls())
func (mock *GoRedisClientMock) HKeysCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockHKeys.RLock()
	calls = mock.calls.HKeys
	mock.lockHKeys.RUnlock()
	return calls
}

// HLen calls HLenFunc.
func (mock *GoRedisClientMock) HLen(ctx context.Context, key string) *redis.IntCmd {
	if mock.HLenFunc == nil {
		panic("GoRedisClientMock.HLenFunc: method is nil but GoRedisClient.HLen was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockHLen.Lock()
	mock.calls.HLen = append(mock.calls.HLen, callInfo)
	mock.lockHLen.Unlock()
	return mock.HLenFunc(ctx, key)
}

// HLenCalls gets all the calls that were made to HLen.
// Check the length with:
//
//	len(mockedGoRedisClient.HLenCalls())
func (mock *GoRedisClientMock) HLenCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockHLen.RLock()
	calls = mock.calls.HLen
	mock.lockHLen.RUnlock()
	return calls
}

// HMGet calls HMGetFunc.
func (mock *GoRedisClientMock) HMGet(ctx context.Context, key string, fields ...string) *redis.SliceCmd {
	if mock.HMGetFunc == nil {
		panic("GoRedisClientMock.HMGetFunc: method is nil but GoRedisClient.HMGet was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}{
		Ctx:    ctx,
		Key:    key,
		Fields: fields,
	}
	mock.lockHMGet.Lock()
	mock.calls.HMGet = append(mock.calls.HMGet, callInfo)
	mock.lockHMGet.Unlock()
	return mock.HMGetFunc(ctx, key, fields...)
}

// HMGetCalls gets all the calls that were made to HMGet.
// Check the length with:
//
//	len(mockedGoRedisClient.HMGetCalls())
func (mock *GoRedisClientMock) HMGetCalls() []struct {
	Ctx    context.Context
	Key    string
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}
	mock.lockHMGet.RLock()
	calls = mock.calls.HMGet
	mock.lockHMGet.RUnlock()
	return calls
}

// HMSet calls HMSetFunc.
func (mock *GoRedisClientMock) HMSet(ctx context.Context, key string, values ...interface{}) *redis.BoolCmd {
	if mock.HMSetFunc == nil {
		panic("GoRedisClientMock.HMSetFunc: method is nil but GoRedisClient.HMSet was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}{
		Ctx:    ctx,
		Key:    key,
		Values: values,
	}
	mock.lockHMSet.Lock()
	mock.calls.HMSet = append(mock.calls.HMSet, callInfo)
	mock.lockHMSet.Unlock()
	return mock.HMSetFunc(ctx, key, values...)
}

// HMSetCalls gets all the calls that were made to HMSet.
// Check the length with:
//
//	len(mockedGoRedisClient.HMSetCalls())
func (mock *GoRedisClientMock) HMSetCalls() []struct {
	Ctx    context.Context
	Key    string
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}
	mock.lockHMSet.RLock()
	calls = mock.calls.HMSet
	mock.lockHMSet.RUnlock()
	return calls
}

// HPExpire calls HPExpireFunc.
func (mock *GoRedisClientMock) HPExpire(ctx context.Context, key string, expiration time.Duration, fields ...string) *redis.IntSliceCmd {
	if mock.HPExpireFunc == nil {
		panic("GoRedisClientMock.HPExpireFunc: method is nil but GoRedisClient.HPExpire was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
		Fields     []string
	}{
		Ctx:        ctx,
		Key:        key,
		Expiration: expiration,
		Fields:     fields,
	}
	mock.lockHPExpire.Lock()
	mock.calls.HPExpire = append(mock.calls.HPExpire, callInfo)
	mock.lockHPExpire.Unlock()
	return mock.HPExpireFunc(ctx, key, expiration, fields...)
}

// HPExpireCalls gets all the calls that were made to HPExpire.
// Check the length with:
//
//	len(mockedGoRedisClient.HPExpireCalls())
func (mock *GoRedisClientMock) HPExpireCalls() []struct {
	Ctx        context.Context
	Key        string
	Expiration time.Duration
	Fields     []string
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
		Fields     []string
	}
	mock.lockHPExpire.RLock()
	calls = mock.calls.HPExpire
	mock.lockHPExpire.RUnlock()
	return calls
}

// HPExpireAt calls HPExpireAtFunc.
func (mock *GoRedisClientMock) HPExpireAt(ctx context.Context, key string, tm time.Time, fields ...string) *redis.IntSliceCmd {
	if mock.HPExpireAtFunc == nil {
		panic("GoRedisClientMock.HPExpireAtFunc: method is nil but GoRedisClient.HPExpireAt was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Tm     time.Time
		Fields []string
	}{
		Ctx:    ctx,
		Key:    key,
		Tm:     tm,
		Fields: fields,
	}
	mock.lockHPExpireAt.Lock()
	mock.calls.HPExpireAt = append(mock.calls.HPExpireAt, callInfo)
	mock.lockHPExpireAt.Unlock()
	return mock.HPExpireAtFunc(ctx, key, tm, fields...)
}

// HPExpireAtCalls gets all the calls that were made to HPExpireAt.
// Check the length with:
//
//	len(mockedGoRedisClient.HPExpireAtCalls())
func (mock *GoRedisClientMock) HPExpireAtCalls() []struct {
	Ctx    context.Context
	Key    string
	Tm     time.Time
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Tm     time.Time
		Fields []string
	}
	mock.lockHPExpireAt.RLock()
	calls = mock.calls.HPExpireAt
	mock.lockHPExpireAt.RUnlock()
	return calls
}

// HPExpireAtWithArgs calls HPExpireAtWithArgsFunc.
func (mock *GoRedisClientMock) HPExpireAtWithArgs(ctx context.Context, key string, tm time.Time, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
	if mock.HPExpireAtWithArgsFunc == nil {
		panic("GoRedisClientMock.HPExpireAtWithArgsFunc: method is nil but GoRedisClient.HPExpireAtWithArgs was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		Key            string
		Tm             time.Time
		ExpirationArgs redis.HExpireArgs
		Fields         []string
	}{
		Ctx:            ctx,
		Key:            key,
		Tm:             tm,
		ExpirationArgs: expirationArgs,
		Fields:         fields,
	}
	mock.lockHPExpireAtWithArgs.Lock()
	mock.calls.HPExpireAtWithArgs = append(mock.calls.HPExpireAtWithArgs, callInfo)
	mock.lockHPExpireAtWithArgs.Unlock()
	return mock.HPExpireAtWithArgsFunc(ctx, key, tm, expirationArgs, fields...)
}

// HPExpireAtWithArgsCalls gets all the calls that were made to HPExpireAtWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.HPExpireAtWithArgsCalls())
func (mock *GoRedisClientMock) HPExpireAtWithArgsCalls() []struct {
	Ctx            context.Context
	Key            string
	Tm             time.Time
	ExpirationArgs redis.HExpireArgs
	Fields         []string
} {
	var calls []struct {
		Ctx            context.Context
		Key            string
		Tm             time.Time
		ExpirationArgs redis.HExpireArgs
		Fields         []string
	}
	mock.lockHPExpireAtWithArgs.RLock()
	calls = mock.calls.HPExpireAtWithArgs
	mock.lockHPExpireAtWithArgs.RUnlock()
	return calls
}

// HPExpireTime calls HPExpireTimeFunc.
func (mock *GoRedisClientMock) HPExpireTime(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
	if mock.HPExpireTimeFunc == nil {
		panic("GoRedisClientMock.HPExpireTimeFunc: method is nil but GoRedisClient.HPExpireTime was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}{
		Ctx:    ctx,
		Key:    key,
		Fields: fields,
	}
	mock.lockHPExpireTime.Lock()
	mock.calls.HPExpireTime = append(mock.calls.HPExpireTime, callInfo)
	mock.lockHPExpireTime.Unlock()
	return mock.HPExpireTimeFunc(ctx, key, fields...)
}

// HPExpireTimeCalls gets all the calls that were made to HPExpireTime.
// Check the length with:
//
//	len(mockedGoRedisClient.HPExpireTimeCalls())
func (mock *GoRedisClientMock) HPExpireTimeCalls() []struct {
	Ctx    context.Context
	Key    string
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}
	mock.lockHPExpireTime.RLock()
	calls = mock.calls.HPExpireTime
	mock.lockHPExpireTime.RUnlock()
	return calls
}

// HPExpireWithArgs calls HPExpireWithArgsFunc.
func (mock *GoRedisClientMock) HPExpireWithArgs(ctx context.Context, key string, expiration time.Duration, expirationArgs redis.HExpireArgs, fields ...string) *redis.IntSliceCmd {
	if mock.HPExpireWithArgsFunc == nil {
		panic("GoRedisClientMock.HPExpireWithArgsFunc: method is nil but GoRedisClient.HPExpireWithArgs was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		Key            string
		Expiration     time.Duration
		ExpirationArgs redis.HExpireArgs
		Fields         []string
	}{
		Ctx:            ctx,
		Key:            key,
		Expiration:     expiration,
		ExpirationArgs: expirationArgs,
		Fields:         fields,
	}
	mock.lockHPExpireWithArgs.Lock()
	mock.calls.HPExpireWithArgs = append(mock.calls.HPExpireWithArgs, callInfo)
	mock.lockHPExpireWithArgs.Unlock()
	return mock.HPExpireWithArgsFunc(ctx, key, expiration, expirationArgs, fields...)
}

// HPExpireWithArgsCalls gets all the calls that were made to HPExpireWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.HPExpireWithArgsCalls())
func (mock *GoRedisClientMock) HPExpireWithArgsCalls() []struct {
	Ctx            context.Context
	Key            string
	Expiration     time.Duration
	ExpirationArgs redis.HExpireArgs
	Fields         []string
} {
	var calls []struct {
		Ctx            context.Context
		Key            string
		Expiration     time.Duration
		ExpirationArgs redis.HExpireArgs
		Fields         []string
	}
	mock.lockHPExpireWithArgs.RLock()
	calls = mock.calls.HPExpireWithArgs
	mock.lockHPExpireWithArgs.RUnlock()
	return calls
}

// HPTTL calls HPTTLFunc.
func (mock *GoRedisClientMock) HPTTL(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
	if mock.HPTTLFunc == nil {
		panic("GoRedisClientMock.HPTTLFunc: method is nil but GoRedisClient.HPTTL was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}{
		Ctx:    ctx,
		Key:    key,
		Fields: fields,
	}
	mock.lockHPTTL.Lock()
	mock.calls.HPTTL = append(mock.calls.HPTTL, callInfo)
	mock.lockHPTTL.Unlock()
	return mock.HPTTLFunc(ctx, key, fields...)
}

// HPTTLCalls gets all the calls that were made to HPTTL.
// Check the length with:
//
//	len(mockedGoRedisClient.HPTTLCalls())
func (mock *GoRedisClientMock) HPTTLCalls() []struct {
	Ctx    context.Context
	Key    string
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}
	mock.lockHPTTL.RLock()
	calls = mock.calls.HPTTL
	mock.lockHPTTL.RUnlock()
	return calls
}

// HPersist calls HPersistFunc.
func (mock *GoRedisClientMock) HPersist(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
	if mock.HPersistFunc == nil {
		panic("GoRedisClientMock.HPersistFunc: method is nil but GoRedisClient.HPersist was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}{
		Ctx:    ctx,
		Key:    key,
		Fields: fields,
	}
	mock.lockHPersist.Lock()
	mock.calls.HPersist = append(mock.calls.HPersist, callInfo)
	mock.lockHPersist.Unlock()
	return mock.HPersistFunc(ctx, key, fields...)
}

// HPersistCalls gets all the calls that were made to HPersist.
// Check the length with:
//
//	len(mockedGoRedisClient.HPersistCalls())
func (mock *GoRedisClientMock) HPersistCalls() []struct {
	Ctx    context.Context
	Key    string
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}
	mock.lockHPersist.RLock()
	calls = mock.calls.HPersist
	mock.lockHPersist.RUnlock()
	return calls
}

// HRandField calls HRandFieldFunc.
func (mock *GoRedisClientMock) HRandField(ctx context.Context, key string, count int) *redis.StringSliceCmd {
	if mock.HRandFieldFunc == nil {
		panic("GoRedisClientMock.HRandFieldFunc: method is nil but GoRedisClient.HRandField was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count int
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
	}
	mock.lockHRandField.Lock()
	mock.calls.HRandField = append(mock.calls.HRandField, callInfo)
	mock.lockHRandField.Unlock()
	return mock.HRandFieldFunc(ctx, key, count)
}

// HRandFieldCalls gets all the calls that were made to HRandField.
// Check the length with:
//
//	len(mockedGoRedisClient.HRandFieldCalls())
func (mock *GoRedisClientMock) HRandFieldCalls() []struct {
	Ctx   context.Context
	Key   string
	Count int
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count int
	}
	mock.lockHRandField.RLock()
	calls = mock.calls.HRandField
	mock.lockHRandField.RUnlock()
	return calls
}

// HRandFieldWithValues calls HRandFieldWithValuesFunc.
func (mock *GoRedisClientMock) HRandFieldWithValues(ctx context.Context, key string, count int) *redis.KeyValueSliceCmd {
	if mock.HRandFieldWithValuesFunc == nil {
		panic("GoRedisClientMock.HRandFieldWithValuesFunc: method is nil but GoRedisClient.HRandFieldWithValues was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count int
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
	}
	mock.lockHRandFieldWithValues.Lock()
	mock.calls.HRandFieldWithValues = append(mock.calls.HRandFieldWithValues, callInfo)
	mock.lockHRandFieldWithValues.Unlock()
	return mock.HRandFieldWithValuesFunc(ctx, key, count)
}

// HRandFieldWithValuesCalls gets all the calls that were made to HRandFieldWithValues.
// Check the length with:
//
//	len(mockedGoRedisClient.HRandFieldWithValuesCalls())
func (mock *GoRedisClientMock) HRandFieldWithValuesCalls() []struct {
	Ctx   context.Context
	Key   string
	Count int
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count int
	}
	mock.lockHRandFieldWithValues.RLock()
	calls = mock.calls.HRandFieldWithValues
	mock.lockHRandFieldWithValues.RUnlock()
	return calls
}

// HScan calls HScanFunc.
func (mock *GoRedisClientMock) HScan(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	if mock.HScanFunc == nil {
		panic("GoRedisClientMock.HScanFunc: method is nil but GoRedisClient.HScan was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Cursor uint64
		Match  string
		Count  int64
	}{
		Ctx:    ctx,
		Key:    key,
		Cursor: cursor,
		Match:  match,
		Count:  count,
	}
	mock.lockHScan.Lock()
	mock.calls.HScan = append(mock.calls.HScan, callInfo)
	mock.lockHScan.Unlock()
	return mock.HScanFunc(ctx, key, cursor, match, count)
}

// HScanCalls gets all the calls that were made to HScan.
// Check the length with:
//
//	len(mockedGoRedisClient.HScanCalls())
func (mock *GoRedisClientMock) HScanCalls() []struct {
	Ctx    context.Context
	Key    string
	Cursor uint64
	Match  string
	Count  int64
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Cursor uint64
		Match  string
		Count  int64
	}
	mock.lockHScan.RLock()
	calls = mock.calls.HScan
	mock.lockHScan.RUnlock()
	return calls
}

// HScanNoValues calls HScanNoValuesFunc.
func (mock *GoRedisClientMock) HScanNoValues(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	if mock.HScanNoValuesFunc == nil {
		panic("GoRedisClientMock.HScanNoValuesFunc: method is nil but GoRedisClient.HScanNoValues was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Cursor uint64
		Match  string
		Count  int64
	}{
		Ctx:    ctx,
		Key:    key,
		Cursor: cursor,
		Match:  match,
		Count:  count,
	}
	mock.lockHScanNoValues.Lock()
	mock.calls.HScanNoValues = append(mock.calls.HScanNoValues, callInfo)
	mock.lockHScanNoValues.Unlock()
	return mock.HScanNoValuesFunc(ctx, key, cursor, match, count)
}

// HScanNoValuesCalls gets all the calls that were made to HScanNoValues.
// Check the length with:
//
//	len(mockedGoRedisClient.HScanNoValuesCalls())
func (mock *GoRedisClientMock) HScanNoValuesCalls() []struct {
	Ctx    context.Context
	Key    string
	Cursor uint64
	Match  string
	Count  int64
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Cursor uint64
		Match  string
		Count  int64
	}
	mock.lockHScanNoValues.RLock()
	calls = mock.calls.HScanNoValues
	mock.lockHScanNoValues.RUnlock()
	return calls
}

// HSet calls HSetFunc.
func (mock *GoRedisClientMock) HSet(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	if mock.HSetFunc == nil {
		panic("GoRedisClientMock.HSetFunc: method is nil but GoRedisClient.HSet was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}{
		Ctx:    ctx,
		Key:    key,
		Values: values,
	}
	mock.lockHSet.Lock()
	mock.calls.HSet = append(mock.calls.HSet, callInfo)
	mock.lockHSet.Unlock()
	return mock.HSetFunc(ctx, key, values...)
}

// HSetCalls gets all the calls that were made to HSet.
// Check the length with:
//
//	len(mockedGoRedisClient.HSetCalls())
func (mock *GoRedisClientMock) HSetCalls() []struct {
	Ctx    context.Context
	Key    string
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}
	mock.lockHSet.RLock()
	calls = mock.calls.HSet
	mock.lockHSet.RUnlock()
	return calls
}

// HSetEX calls HSetEXFunc.
func (mock *GoRedisClientMock) HSetEX(ctx context.Context, key string, fieldsAndValues ...string) *redis.IntCmd {
	if mock.HSetEXFunc == nil {
		panic("GoRedisClientMock.HSetEXFunc: method is nil but GoRedisClient.HSetEX was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		Key             string
		FieldsAndValues []string
	}{
		Ctx:             ctx,
		Key:             key,
		FieldsAndValues: fieldsAndValues,
	}
	mock.lockHSetEX.Lock()
	mock.calls.HSetEX = append(mock.calls.HSetEX, callInfo)
	mock.lockHSetEX.Unlock()
	return mock.HSetEXFunc(ctx, key, fieldsAndValues...)
}

// HSetEXCalls gets all the calls that were made to HSetEX.
// Check the length with:
//
//	len(mockedGoRedisClient.HSetEXCalls())
func (mock *GoRedisClientMock) HSetEXCalls() []struct {
	Ctx             context.Context
	Key             string
	FieldsAndValues []string
} {
	var calls []struct {
		Ctx             context.Context
		Key             string
		FieldsAndValues []string
	}
	mock.lockHSetEX.RLock()
	calls = mock.calls.HSetEX
	mock.lockHSetEX.RUnlock()
	return calls
}

// HSetEXWithArgs calls HSetEXWithArgsFunc.
func (mock *GoRedisClientMock) HSetEXWithArgs(ctx context.Context, key string, options *redis.HSetEXOptions, fieldsAndValues ...string) *redis.IntCmd {
	if mock.HSetEXWithArgsFunc == nil {
		panic("GoRedisClientMock.HSetEXWithArgsFunc: method is nil but GoRedisClient.HSetEXWithArgs was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		Key             string
		Options         *redis.HSetEXOptions
		FieldsAndValues []string
	}{
		Ctx:             ctx,
		Key:             key,
		Options:         options,
		FieldsAndValues: fieldsAndValues,
	}
	mock.lockHSetEXWithArgs.Lock()
	mock.calls.HSetEXWithArgs = append(mock.calls.HSetEXWithArgs, callInfo)
	mock.lockHSetEXWithArgs.Unlock()
	return mock.HSetEXWithArgsFunc(ctx, key, options, fieldsAndValues...)
}

// HSetEXWithArgsCalls gets all the calls that were made to HSetEXWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.HSetEXWithArgsCalls())
func (mock *GoRedisClientMock) HSetEXWithArgsCalls() []struct {
	Ctx             context.Context
	Key             string
	Options         *redis.HSetEXOptions
	FieldsAndValues []string
} {
	var calls []struct {
		Ctx             context.Context
		Key             string
		Options         *redis.HSetEXOptions
		FieldsAndValues []string
	}
	mock.lockHSetEXWithArgs.RLock()
	calls = mock.calls.HSetEXWithArgs
	mock.lockHSetEXWithArgs.RUnlock()
	return calls
}

// HSetNX calls HSetNXFunc.
func (mock *GoRedisClientMock) HSetNX(ctx context.Context, key string, field string, value interface{}) *redis.BoolCmd {
	if mock.HSetNXFunc == nil {
		panic("GoRedisClientMock.HSetNXFunc: method is nil but GoRedisClient.HSetNX was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Field string
		Value interface{}
	}{
		Ctx:   ctx,
		Key:   key,
		Field: field,
		Value: value,
	}
	mock.lockHSetNX.Lock()
	mock.calls.HSetNX = append(mock.calls.HSetNX, callInfo)
	mock.lockHSetNX.Unlock()
	return mock.HSetNXFunc(ctx, key, field, value)
}

// HSetNXCalls gets all the calls that were made to HSetNX.
// Check the length with:
//
//	len(mockedGoRedisClient.HSetNXCalls())
func (mock *GoRedisClientMock) HSetNXCalls() []struct {
	Ctx   context.Context
	Key   string
	Field string
	Value interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Field string
		Value interface{}
	}
	mock.lockHSetNX.RLock()
	calls = mock.calls.HSetNX
	mock.lockHSetNX.RUnlock()
	return calls
}

// HStrLen calls HStrLenFunc.
func (mock *GoRedisClientMock) HStrLen(ctx context.Context, key string, field string) *redis.IntCmd {
	if mock.HStrLenFunc == nil {
		panic("GoRedisClientMock.HStrLenFunc: method is nil but GoRedisClient.HStrLen was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Field string
	}{
		Ctx:   ctx,
		Key:   key,
		Field: field,
	}
	mock.lockHStrLen.Lock()
	mock.calls.HStrLen = append(mock.calls.HStrLen, callInfo)
	mock.lockHStrLen.Unlock()
	return mock.HStrLenFunc(ctx, key, field)
}

// HStrLenCalls gets all the calls that were made to HStrLen.
// Check the length with:
//
//	len(mockedGoRedisClient.HStrLenCalls())
func (mock *GoRedisClientMock) HStrLenCalls() []struct {
	Ctx   context.Context
	Key   string
	Field string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Field string
	}
	mock.lockHStrLen.RLock()
	calls = mock.calls.HStrLen
	mock.lockHStrLen.RUnlock()
	return calls
}

// HTTL calls HTTLFunc.
func (mock *GoRedisClientMock) HTTL(ctx context.Context, key string, fields ...string) *redis.IntSliceCmd {
	if mock.HTTLFunc == nil {
		panic("GoRedisClientMock.HTTLFunc: method is nil but GoRedisClient.HTTL was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}{
		Ctx:    ctx,
		Key:    key,
		Fields: fields,
	}
	mock.lockHTTL.Lock()
	mock.calls.HTTL = append(mock.calls.HTTL, callInfo)
	mock.lockHTTL.Unlock()
	return mock.HTTLFunc(ctx, key, fields...)
}

// HTTLCalls gets all the calls that were made to HTTL.
// Check the length with:
//
//	len(mockedGoRedisClient.HTTLCalls())
func (mock *GoRedisClientMock) HTTLCalls() []struct {
	Ctx    context.Context
	Key    string
	Fields []string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Fields []string
	}
	mock.lockHTTL.RLock()
	calls = mock.calls.HTTL
	mock.lockHTTL.RUnlock()
	return calls
}

// HVals calls HValsFunc.
func (mock *GoRedisClientMock) HVals(ctx context.Context, key string) *redis.StringSliceCmd {
	if mock.HValsFunc == nil {
		panic("GoRedisClientMock.HValsFunc: method is nil but GoRedisClient.HVals was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockHVals.Lock()
	mock.calls.HVals = append(mock.calls.HVals, callInfo)
	mock.lockHVals.Unlock()
	return mock.HValsFunc(ctx, key)
}

// HValsCalls gets all the calls that were made to HVals.
// Check the length with:
//
//	len(mockedGoRedisClient.HValsCalls())
func (mock *GoRedisClientMock) HValsCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockHVals.RLock()
	calls = mock.calls.HVals
	mock.lockHVals.RUnlock()
	return calls
}

// Incr calls IncrFunc.
func (mock *GoRedisClientMock) Incr(ctx context.Context, key string) *redis.IntCmd {
	if mock.IncrFunc == nil {
		panic("GoRedisClientMock.IncrFunc: method is nil but GoRedisClient.Incr was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockIncr.Lock()
	mock.calls.Incr = append(mock.calls.Incr, callInfo)
	mock.lockIncr.Unlock()
	return mock.IncrFunc(ctx, key)
}

// IncrCalls gets all the calls that were made to Incr.
// Check the length with:
//
//	len(mockedGoRedisClient.IncrCalls())
func (mock *GoRedisClientMock) IncrCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockIncr.RLock()
	calls = mock.calls.Incr
	mock.lockIncr.RUnlock()
	return calls
}

// IncrBy calls IncrByFunc.
func (mock *GoRedisClientMock) IncrBy(ctx context.Context, key string, value int64) *redis.IntCmd {
	if mock.IncrByFunc == nil {
		panic("GoRedisClientMock.IncrByFunc: method is nil but GoRedisClient.IncrBy was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Value int64
	}{
		Ctx:   ctx,
		Key:   key,
		Value: value,
	}
	mock.lockIncrBy.Lock()
	mock.calls.IncrBy = append(mock.calls.IncrBy, callInfo)
	mock.lockIncrBy.Unlock()
	return mock.IncrByFunc(ctx, key, value)
}

// IncrByCalls gets all the calls that were made to IncrBy.
// Check the length with:
//
//	len(mockedGoRedisClient.IncrByCalls())
func (mock *GoRedisClientMock) IncrByCalls() []struct {
	Ctx   context.Context
	Key   string
	Value int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Value int64
	}
	mock.lockIncrBy.RLock()
	calls = mock.calls.IncrBy
	mock.lockIncrBy.RUnlock()
	return calls
}

// IncrByFloat calls IncrByFloatFunc.
func (mock *GoRedisClientMock) IncrByFloat(ctx context.Context, key string, value float64) *redis.FloatCmd {
	if mock.IncrByFloatFunc == nil {
		panic("GoRedisClientMock.IncrByFloatFunc: method is nil but GoRedisClient.IncrByFloat was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Value float64
	}{
		Ctx:   ctx,
		Key:   key,
		Value: value,
	}
	mock.lockIncrByFloat.Lock()
	mock.calls.IncrByFloat = append(mock.calls.IncrByFloat, callInfo)
	mock.lockIncrByFloat.Unlock()
	return mock.IncrByFloatFunc(ctx, key, value)
}

// IncrByFloatCalls gets all the calls that were made to IncrByFloat.
// Check the length with:
//
//	len(mockedGoRedisClient.IncrByFloatCalls())
func (mock *GoRedisClientMock) IncrByFloatCalls() []struct {
	Ctx   context.Context
	Key   string
	Value float64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Value float64
	}
	mock.lockIncrByFloat.RLock()
	calls = mock.calls.IncrByFloat
	mock.lockIncrByFloat.RUnlock()
	return calls
}

// Info calls InfoFunc.
func (mock *GoRedisClientMock) Info(ctx context.Context, section ...string) *redis.StringCmd {
	if mock.InfoFunc == nil {
		panic("GoRedisClientMock.InfoFunc: method is nil but GoRedisClient.Info was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Section []string
	}{
		Ctx:     ctx,
		Section: section,
	}
	mock.lockInfo.Lock()
	mock.calls.Info = append(mock.calls.Info, callInfo)
	mock.lockInfo.Unlock()
	return mock.InfoFunc(ctx, section...)
}

// InfoCalls gets all the calls that were made to Info.
// Check the length with:
//
//	len(mockedGoRedisClient.InfoCalls())
func (mock *GoRedisClientMock) InfoCalls() []struct {
	Ctx     context.Context
	Section []string
} {
	var calls []struct {
		Ctx     context.Context
		Section []string
	}
	mock.lockInfo.RLock()
	calls = mock.calls.Info
	mock.lockInfo.RUnlock()
	return calls
}

// JSONArrAppend calls JSONArrAppendFunc.
func (mock *GoRedisClientMock) JSONArrAppend(ctx context.Context, key string, path string, values ...interface{}) *redis.IntSliceCmd {
	if mock.JSONArrAppendFunc == nil {
		panic("GoRedisClientMock.JSONArrAppendFunc: method is nil but GoRedisClient.JSONArrAppend was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Path   string
		Values []interface{}
	}{
		Ctx:    ctx,
		Key:    key,
		Path:   path,
		Values: values,
	}
	mock.lockJSONArrAppend.Lock()
	mock.calls.JSONArrAppend = append(mock.calls.JSONArrAppend, callInfo)
	mock.lockJSONArrAppend.Unlock()
	return mock.JSONArrAppendFunc(ctx, key, path, values...)
}

// JSONArrAppendCalls gets all the calls that were made to JSONArrAppend.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONArrAppendCalls())
func (mock *GoRedisClientMock) JSONArrAppendCalls() []struct {
	Ctx    context.Context
	Key    string
	Path   string
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Path   string
		Values []interface{}
	}
	mock.lockJSONArrAppend.RLock()
	calls = mock.calls.JSONArrAppend
	mock.lockJSONArrAppend.RUnlock()
	return calls
}

// JSONArrIndex calls JSONArrIndexFunc.
func (mock *GoRedisClientMock) JSONArrIndex(ctx context.Context, key string, path string, value ...interface{}) *redis.IntSliceCmd {
	if mock.JSONArrIndexFunc == nil {
		panic("GoRedisClientMock.JSONArrIndexFunc: method is nil but GoRedisClient.JSONArrIndex was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value []interface{}
	}{
		Ctx:   ctx,
		Key:   key,
		Path:  path,
		Value: value,
	}
	mock.lockJSONArrIndex.Lock()
	mock.calls.JSONArrIndex = append(mock.calls.JSONArrIndex, callInfo)
	mock.lockJSONArrIndex.Unlock()
	return mock.JSONArrIndexFunc(ctx, key, path, value...)
}

// JSONArrIndexCalls gets all the calls that were made to JSONArrIndex.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONArrIndexCalls())
func (mock *GoRedisClientMock) JSONArrIndexCalls() []struct {
	Ctx   context.Context
	Key   string
	Path  string
	Value []interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value []interface{}
	}
	mock.lockJSONArrIndex.RLock()
	calls = mock.calls.JSONArrIndex
	mock.lockJSONArrIndex.RUnlock()
	return calls
}

// JSONArrIndexWithArgs calls JSONArrIndexWithArgsFunc.
func (mock *GoRedisClientMock) JSONArrIndexWithArgs(ctx context.Context, key string, path string, options *redis.JSONArrIndexArgs, value ...interface{}) *redis.IntSliceCmd {
	if mock.JSONArrIndexWithArgsFunc == nil {
		panic("GoRedisClientMock.JSONArrIndexWithArgsFunc: method is nil but GoRedisClient.JSONArrIndexWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Path    string
		Options *redis.JSONArrIndexArgs
		Value   []interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Path:    path,
		Options: options,
		Value:   value,
	}
	mock.lockJSONArrIndexWithArgs.Lock()
	mock.calls.JSONArrIndexWithArgs = append(mock.calls.JSONArrIndexWithArgs, callInfo)
	mock.lockJSONArrIndexWithArgs.Unlock()
	return mock.JSONArrIndexWithArgsFunc(ctx, key, path, options, value...)
}

// JSONArrIndexWithArgsCalls gets all the calls that were made to JSONArrIndexWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONArrIndexWithArgsCalls())
func (mock *GoRedisClientMock) JSONArrIndexWithArgsCalls() []struct {
	Ctx     context.Context
	Key     string
	Path    string
	Options *redis.JSONArrIndexArgs
	Value   []interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Path    string
		Options *redis.JSONArrIndexArgs
		Value   []interface{}
	}
	mock.lockJSONArrIndexWithArgs.RLock()
	calls = mock.calls.JSONArrIndexWithArgs
	mock.lockJSONArrIndexWithArgs.RUnlock()
	return calls
}

// JSONArrInsert calls JSONArrInsertFunc.
func (mock *GoRedisClientMock) JSONArrInsert(ctx context.Context, key string, path string, index int64, values ...interface{}) *redis.IntSliceCmd {
	if mock.JSONArrInsertFunc == nil {
		panic("GoRedisClientMock.JSONArrInsertFunc: method is nil but GoRedisClient.JSONArrInsert was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Path   string
		Index  int64
		Values []interface{}
	}{
		Ctx:    ctx,
		Key:    key,
		Path:   path,
		Index:  index,
		Values: values,
	}
	mock.lockJSONArrInsert.Lock()
	mock.calls.JSONArrInsert = append(mock.calls.JSONArrInsert, callInfo)
	mock.lockJSONArrInsert.Unlock()
	return mock.JSONArrInsertFunc(ctx, key, path, index, values...)
}

// JSONArrInsertCalls gets all the calls that were made to JSONArrInsert.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONArrInsertCalls())
func (mock *GoRedisClientMock) JSONArrInsertCalls() []struct {
	Ctx    context.Context
	Key    string
	Path   string
	Index  int64
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Path   string
		Index  int64
		Values []interface{}
	}
	mock.lockJSONArrInsert.RLock()
	calls = mock.calls.JSONArrInsert
	mock.lockJSONArrInsert.RUnlock()
	return calls
}

// JSONArrLen calls JSONArrLenFunc.
func (mock *GoRedisClientMock) JSONArrLen(ctx context.Context, key string, path string) *redis.IntSliceCmd {
	if mock.JSONArrLenFunc == nil {
		panic("GoRedisClientMock.JSONArrLenFunc: method is nil but GoRedisClient.JSONArrLen was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Path string
	}{
		Ctx:  ctx,
		Key:  key,
		Path: path,
	}
	mock.lockJSONArrLen.Lock()
	mock.calls.JSONArrLen = append(mock.calls.JSONArrLen, callInfo)
	mock.lockJSONArrLen.Unlock()
	return mock.JSONArrLenFunc(ctx, key, path)
}

// JSONArrLenCalls gets all the calls that were made to JSONArrLen.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONArrLenCalls())
func (mock *GoRedisClientMock) JSONArrLenCalls() []struct {
	Ctx  context.Context
	Key  string
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Path string
	}
	mock.lockJSONArrLen.RLock()
	calls = mock.calls.JSONArrLen
	mock.lockJSONArrLen.RUnlock()
	return calls
}

// JSONArrPop calls JSONArrPopFunc.
func (mock *GoRedisClientMock) JSONArrPop(ctx context.Context, key string, path string, index int) *redis.StringSliceCmd {
	if mock.JSONArrPopFunc == nil {
		panic("GoRedisClientMock.JSONArrPopFunc: method is nil but GoRedisClient.JSONArrPop was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Path  string
		Index int
	}{
		Ctx:   ctx,
		Key:   key,
		Path:  path,
		Index: index,
	}
	mock.lockJSONArrPop.Lock()
	mock.calls.JSONArrPop = append(mock.calls.JSONArrPop, callInfo)
	mock.lockJSONArrPop.Unlock()
	return mock.JSONArrPopFunc(ctx, key, path, index)
}

// JSONArrPopCalls gets all the calls that were made to JSONArrPop.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONArrPopCalls())
func (mock *GoRedisClientMock) JSONArrPopCalls() []struct {
	Ctx   context.Context
	Key   string
	Path  string
	Index int
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Path  string
		Index int
	}
	mock.lockJSONArrPop.RLock()
	calls = mock.calls.JSONArrPop
	mock.lockJSONArrPop.RUnlock()
	return calls
}

// JSONArrTrim calls JSONArrTrimFunc.
func (mock *GoRedisClientMock) JSONArrTrim(ctx context.Context, key string, path string) *redis.IntSliceCmd {
	if mock.JSONArrTrimFunc == nil {
		panic("GoRedisClientMock.JSONArrTrimFunc: method is nil but GoRedisClient.JSONArrTrim was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Path string
	}{
		Ctx:  ctx,
		Key:  key,
		Path: path,
	}
	mock.lockJSONArrTrim.Lock()
	mock.calls.JSONArrTrim = append(mock.calls.JSONArrTrim, callInfo)
	mock.lockJSONArrTrim.Unlock()
	return mock.JSONArrTrimFunc(ctx, key, path)
}

// JSONArrTrimCalls gets all the calls that were made to JSONArrTrim.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONArrTrimCalls())
func (mock *GoRedisClientMock) JSONArrTrimCalls() []struct {
	Ctx  context.Context
	Key  string
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Path string
	}
	mock.lockJSONArrTrim.RLock()
	calls = mock.calls.JSONArrTrim
	mock.lockJSONArrTrim.RUnlock()
	return calls
}

// JSONArrTrimWithArgs calls JSONArrTrimWithArgsFunc.
func (mock *GoRedisClientMock) JSONArrTrimWithArgs(ctx context.Context, key string, path string, options *redis.JSONArrTrimArgs) *redis.IntSliceCmd {
	if mock.JSONArrTrimWithArgsFunc == nil {
		panic("GoRedisClientMock.JSONArrTrimWithArgsFunc: method is nil but GoRedisClient.JSONArrTrimWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Path    string
		Options *redis.JSONArrTrimArgs
	}{
		Ctx:     ctx,
		Key:     key,
		Path:    path,
		Options: options,
	}
	mock.lockJSONArrTrimWithArgs.Lock()
	mock.calls.JSONArrTrimWithArgs = append(mock.calls.JSONArrTrimWithArgs, callInfo)
	mock.lockJSONArrTrimWithArgs.Unlock()
	return mock.JSONArrTrimWithArgsFunc(ctx, key, path, options)
}

// JSONArrTrimWithArgsCalls gets all the calls that were made to JSONArrTrimWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONArrTrimWithArgsCalls())
func (mock *GoRedisClientMock) JSONArrTrimWithArgsCalls() []struct {
	Ctx     context.Context
	Key     string
	Path    string
	Options *redis.JSONArrTrimArgs
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Path    string
		Options *redis.JSONArrTrimArgs
	}
	mock.lockJSONArrTrimWithArgs.RLock()
	calls = mock.calls.JSONArrTrimWithArgs
	mock.lockJSONArrTrimWithArgs.RUnlock()
	return calls
}

// JSONClear calls JSONClearFunc.
func (mock *GoRedisClientMock) JSONClear(ctx context.Context, key string, path string) *redis.IntCmd {
	if mock.JSONClearFunc == nil {
		panic("GoRedisClientMock.JSONClearFunc: method is nil but GoRedisClient.JSONClear was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Path string
	}{
		Ctx:  ctx,
		Key:  key,
		Path: path,
	}
	mock.lockJSONClear.Lock()
	mock.calls.JSONClear = append(mock.calls.JSONClear, callInfo)
	mock.lockJSONClear.Unlock()
	return mock.JSONClearFunc(ctx, key, path)
}

// JSONClearCalls gets all the calls that were made to JSONClear.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONClearCalls())
func (mock *GoRedisClientMock) JSONClearCalls() []struct {
	Ctx  context.Context
	Key  string
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Path string
	}
	mock.lockJSONClear.RLock()
	calls = mock.calls.JSONClear
	mock.lockJSONClear.RUnlock()
	return calls
}

// JSONDebugMemory calls JSONDebugMemoryFunc.
func (mock *GoRedisClientMock) JSONDebugMemory(ctx context.Context, key string, path string) *redis.IntCmd {
	if mock.JSONDebugMemoryFunc == nil {
		panic("GoRedisClientMock.JSONDebugMemoryFunc: method is nil but GoRedisClient.JSONDebugMemory was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Path string
	}{
		Ctx:  ctx,
		Key:  key,
		Path: path,
	}
	mock.lockJSONDebugMemory.Lock()
	mock.calls.JSONDebugMemory = append(mock.calls.JSONDebugMemory, callInfo)
	mock.lockJSONDebugMemory.Unlock()
	return mock.JSONDebugMemoryFunc(ctx, key, path)
}

// JSONDebugMemoryCalls gets all the calls that were made to JSONDebugMemory.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONDebugMemoryCalls())
func (mock *GoRedisClientMock) JSONDebugMemoryCalls() []struct {
	Ctx  context.Context
	Key  string
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Path string
	}
	mock.lockJSONDebugMemory.RLock()
	calls = mock.calls.JSONDebugMemory
	mock.lockJSONDebugMemory.RUnlock()
	return calls
}

// JSONDel calls JSONDelFunc.
func (mock *GoRedisClientMock) JSONDel(ctx context.Context, key string, path string) *redis.IntCmd {
	if mock.JSONDelFunc == nil {
		panic("GoRedisClientMock.JSONDelFunc: method is nil but GoRedisClient.JSONDel was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Path string
	}{
		Ctx:  ctx,
		Key:  key,
		Path: path,
	}
	mock.lockJSONDel.Lock()
	mock.calls.JSONDel = append(mock.calls.JSONDel, callInfo)
	mock.lockJSONDel.Unlock()
	return mock.JSONDelFunc(ctx, key, path)
}

// JSONDelCalls gets all the calls that were made to JSONDel.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONDelCalls())
func (mock *GoRedisClientMock) JSONDelCalls() []struct {
	Ctx  context.Context
	Key  string
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Path string
	}
	mock.lockJSONDel.RLock()
	calls = mock.calls.JSONDel
	mock.lockJSONDel.RUnlock()
	return calls
}

// JSONForget calls JSONForgetFunc.
func (mock *GoRedisClientMock) JSONForget(ctx context.Context, key string, path string) *redis.IntCmd {
	if mock.JSONForgetFunc == nil {
		panic("GoRedisClientMock.JSONForgetFunc: method is nil but GoRedisClient.JSONForget was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Path string
	}{
		Ctx:  ctx,
		Key:  key,
		Path: path,
	}
	mock.lockJSONForget.Lock()
	mock.calls.JSONForget = append(mock.calls.JSONForget, callInfo)
	mock.lockJSONForget.Unlock()
	return mock.JSONForgetFunc(ctx, key, path)
}

// JSONForgetCalls gets all the calls that were made to JSONForget.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONForgetCalls())
func (mock *GoRedisClientMock) JSONForgetCalls() []struct {
	Ctx  context.Context
	Key  string
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Path string
	}
	mock.lockJSONForget.RLock()
	calls = mock.calls.JSONForget
	mock.lockJSONForget.RUnlock()
	return calls
}

// JSONGet calls JSONGetFunc.
func (mock *GoRedisClientMock) JSONGet(ctx context.Context, key string, paths ...string) *redis.JSONCmd {
	if mock.JSONGetFunc == nil {
		panic("GoRedisClientMock.JSONGetFunc: method is nil but GoRedisClient.JSONGet was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Paths []string
	}{
		Ctx:   ctx,
		Key:   key,
		Paths: paths,
	}
	mock.lockJSONGet.Lock()
	mock.calls.JSONGet = append(mock.calls.JSONGet, callInfo)
	mock.lockJSONGet.Unlock()
	return mock.JSONGetFunc(ctx, key, paths...)
}

// JSONGetCalls gets all the calls that were made to JSONGet.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONGetCalls())
func (mock *GoRedisClientMock) JSONGetCalls() []struct {
	Ctx   context.Context
	Key   string
	Paths []string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Paths []string
	}
	mock.lockJSONGet.RLock()
	calls = mock.calls.JSONGet
	mock.lockJSONGet.RUnlock()
	return calls
}

// JSONGetWithArgs calls JSONGetWithArgsFunc.
func (mock *GoRedisClientMock) JSONGetWithArgs(ctx context.Context, key string, options *redis.JSONGetArgs, paths ...string) *redis.JSONCmd {
	if mock.JSONGetWithArgsFunc == nil {
		panic("GoRedisClientMock.JSONGetWithArgsFunc: method is nil but GoRedisClient.JSONGetWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Options *redis.JSONGetArgs
		Paths   []string
	}{
		Ctx:     ctx,
		Key:     key,
		Options: options,
		Paths:   paths,
	}
	mock.lockJSONGetWithArgs.Lock()
	mock.calls.JSONGetWithArgs = append(mock.calls.JSONGetWithArgs, callInfo)
	mock.lockJSONGetWithArgs.Unlock()
	return mock.JSONGetWithArgsFunc(ctx, key, options, paths...)
}

// JSONGetWithArgsCalls gets all the calls that were made to JSONGetWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONGetWithArgsCalls())
func (mock *GoRedisClientMock) JSONGetWithArgsCalls() []struct {
	Ctx     context.Context
	Key     string
	Options *redis.JSONGetArgs
	Paths   []string
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Options *redis.JSONGetArgs
		Paths   []string
	}
	mock.lockJSONGetWithArgs.RLock()
	calls = mock.calls.JSONGetWithArgs
	mock.lockJSONGetWithArgs.RUnlock()
	return calls
}

// JSONMGet calls JSONMGetFunc.
func (mock *GoRedisClientMock) JSONMGet(ctx context.Context, path string, keys ...string) *redis.JSONSliceCmd {
	if mock.JSONMGetFunc == nil {
		panic("GoRedisClientMock.JSONMGetFunc: method is nil but GoRedisClient.JSONMGet was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Path string
		Keys []string
	}{
		Ctx:  ctx,
		Path: path,
		Keys: keys,
	}
	mock.lockJSONMGet.Lock()
	mock.calls.JSONMGet = append(mock.calls.JSONMGet, callInfo)
	mock.lockJSONMGet.Unlock()
	return mock.JSONMGetFunc(ctx, path, keys...)
}

// JSONMGetCalls gets all the calls that were made to JSONMGet.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONMGetCalls())
func (mock *GoRedisClientMock) JSONMGetCalls() []struct {
	Ctx  context.Context
	Path string
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Path string
		Keys []string
	}
	mock.lockJSONMGet.RLock()
	calls = mock.calls.JSONMGet
	mock.lockJSONMGet.RUnlock()
	return calls
}

// JSONMSet calls JSONMSetFunc.
func (mock *GoRedisClientMock) JSONMSet(ctx context.Context, params ...interface{}) *redis.StatusCmd {
	if mock.JSONMSetFunc == nil {
		panic("GoRedisClientMock.JSONMSetFunc: method is nil but GoRedisClient.JSONMSet was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Params []interface{}
	}{
		Ctx:    ctx,
		Params: params,
	}
	mock.lockJSONMSet.Lock()
	mock.calls.JSONMSet = append(mock.calls.JSONMSet, callInfo)
	mock.lockJSONMSet.Unlock()
	return mock.JSONMSetFunc(ctx, params...)
}

// JSONMSetCalls gets all the calls that were made to JSONMSet.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONMSetCalls())
func (mock *GoRedisClientMock) JSONMSetCalls() []struct {
	Ctx    context.Context
	Params []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Params []interface{}
	}
	mock.lockJSONMSet.RLock()
	calls = mock.calls.JSONMSet
	mock.lockJSONMSet.RUnlock()
	return calls
}

// JSONMSetArgs calls JSONMSetArgsFunc.
func (mock *GoRedisClientMock) JSONMSetArgs(ctx context.Context, docs []redis.JSONSetArgs) *redis.StatusCmd {
	if mock.JSONMSetArgsFunc == nil {
		panic("GoRedisClientMock.JSONMSetArgsFunc: method is nil but GoRedisClient.JSONMSetArgs was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Docs []redis.JSONSetArgs
	}{
		Ctx:  ctx,
		Docs: docs,
	}
	mock.lockJSONMSetArgs.Lock()
	mock.calls.JSONMSetArgs = append(mock.calls.JSONMSetArgs, callInfo)
	mock.lockJSONMSetArgs.Unlock()
	return mock.JSONMSetArgsFunc(ctx, docs)
}

// JSONMSetArgsCalls gets all the calls that were made to JSONMSetArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONMSetArgsCalls())
func (mock *GoRedisClientMock) JSONMSetArgsCalls() []struct {
	Ctx  context.Context
	Docs []redis.JSONSetArgs
} {
	var calls []struct {
		Ctx  context.Context
		Docs []redis.JSONSetArgs
	}
	mock.lockJSONMSetArgs.RLock()
	calls = mock.calls.JSONMSetArgs
	mock.lockJSONMSetArgs.RUnlock()
	return calls
}

// JSONMerge calls JSONMergeFunc.
func (mock *GoRedisClientMock) JSONMerge(ctx context.Context, key string, path string, value string) *redis.StatusCmd {
	if mock.JSONMergeFunc == nil {
		panic("GoRedisClientMock.JSONMergeFunc: method is nil but GoRedisClient.JSONMerge was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value string
	}{
		Ctx:   ctx,
		Key:   key,
		Path:  path,
		Value: value,
	}
	mock.lockJSONMerge.Lock()
	mock.calls.JSONMerge = append(mock.calls.JSONMerge, callInfo)
	mock.lockJSONMerge.Unlock()
	return mock.JSONMergeFunc(ctx, key, path, value)
}

// JSONMergeCalls gets all the calls that were made to JSONMerge.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONMergeCalls())
func (mock *GoRedisClientMock) JSONMergeCalls() []struct {
	Ctx   context.Context
	Key   string
	Path  string
	Value string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value string
	}
	mock.lockJSONMerge.RLock()
	calls = mock.calls.JSONMerge
	mock.lockJSONMerge.RUnlock()
	return calls
}

// JSONNumIncrBy calls JSONNumIncrByFunc.
func (mock *GoRedisClientMock) JSONNumIncrBy(ctx context.Context, key string, path string, value float64) *redis.JSONCmd {
	if mock.JSONNumIncrByFunc == nil {
		panic("GoRedisClientMock.JSONNumIncrByFunc: method is nil but GoRedisClient.JSONNumIncrBy was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value float64
	}{
		Ctx:   ctx,
		Key:   key,
		Path:  path,
		Value: value,
	}
	mock.lockJSONNumIncrBy.Lock()
	mock.calls.JSONNumIncrBy = append(mock.calls.JSONNumIncrBy, callInfo)
	mock.lockJSONNumIncrBy.Unlock()
	return mock.JSONNumIncrByFunc(ctx, key, path, value)
}

// JSONNumIncrByCalls gets all the calls that were made to JSONNumIncrBy.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONNumIncrByCalls())
func (mock *GoRedisClientMock) JSONNumIncrByCalls() []struct {
	Ctx   context.Context
	Key   string
	Path  string
	Value float64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value float64
	}
	mock.lockJSONNumIncrBy.RLock()
	calls = mock.calls.JSONNumIncrBy
	mock.lockJSONNumIncrBy.RUnlock()
	return calls
}

// JSONObjKeys calls JSONObjKeysFunc.
func (mock *GoRedisClientMock) JSONObjKeys(ctx context.Context, key string, path string) *redis.SliceCmd {
	if mock.JSONObjKeysFunc == nil {
		panic("GoRedisClientMock.JSONObjKeysFunc: method is nil but GoRedisClient.JSONObjKeys was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Path string
	}{
		Ctx:  ctx,
		Key:  key,
		Path: path,
	}
	mock.lockJSONObjKeys.Lock()
	mock.calls.JSONObjKeys = append(mock.calls.JSONObjKeys, callInfo)
	mock.lockJSONObjKeys.Unlock()
	return mock.JSONObjKeysFunc(ctx, key, path)
}

// JSONObjKeysCalls gets all the calls that were made to JSONObjKeys.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONObjKeysCalls())
func (mock *GoRedisClientMock) JSONObjKeysCalls() []struct {
	Ctx  context.Context
	Key  string
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Path string
	}
	mock.lockJSONObjKeys.RLock()
	calls = mock.calls.JSONObjKeys
	mock.lockJSONObjKeys.RUnlock()
	return calls
}

// JSONObjLen calls JSONObjLenFunc.
func (mock *GoRedisClientMock) JSONObjLen(ctx context.Context, key string, path string) *redis.IntPointerSliceCmd {
	if mock.JSONObjLenFunc == nil {
		panic("GoRedisClientMock.JSONObjLenFunc: method is nil but GoRedisClient.JSONObjLen was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Path string
	}{
		Ctx:  ctx,
		Key:  key,
		Path: path,
	}
	mock.lockJSONObjLen.Lock()
	mock.calls.JSONObjLen = append(mock.calls.JSONObjLen, callInfo)
	mock.lockJSONObjLen.Unlock()
	return mock.JSONObjLenFunc(ctx, key, path)
}

// JSONObjLenCalls gets all the calls that were made to JSONObjLen.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONObjLenCalls())
func (mock *GoRedisClientMock) JSONObjLenCalls() []struct {
	Ctx  context.Context
	Key  string
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Path string
	}
	mock.lockJSONObjLen.RLock()
	calls = mock.calls.JSONObjLen
	mock.lockJSONObjLen.RUnlock()
	return calls
}

// JSONSet calls JSONSetFunc.
func (mock *GoRedisClientMock) JSONSet(ctx context.Context, key string, path string, value interface{}) *redis.StatusCmd {
	if mock.JSONSetFunc == nil {
		panic("GoRedisClientMock.JSONSetFunc: method is nil but GoRedisClient.JSONSet was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value interface{}
	}{
		Ctx:   ctx,
		Key:   key,
		Path:  path,
		Value: value,
	}
	mock.lockJSONSet.Lock()
	mock.calls.JSONSet = append(mock.calls.JSONSet, callInfo)
	mock.lockJSONSet.Unlock()
	return mock.JSONSetFunc(ctx, key, path, value)
}

// JSONSetCalls gets all the calls that were made to JSONSet.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONSetCalls())
func (mock *GoRedisClientMock) JSONSetCalls() []struct {
	Ctx   context.Context
	Key   string
	Path  string
	Value interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value interface{}
	}
	mock.lockJSONSet.RLock()
	calls = mock.calls.JSONSet
	mock.lockJSONSet.RUnlock()
	return calls
}

// JSONSetMode calls JSONSetModeFunc.
func (mock *GoRedisClientMock) JSONSetMode(ctx context.Context, key string, path string, value interface{}, mode string) *redis.StatusCmd {
	if mock.JSONSetModeFunc == nil {
		panic("GoRedisClientMock.JSONSetModeFunc: method is nil but GoRedisClient.JSONSetMode was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value interface{}
		Mode  string
	}{
		Ctx:   ctx,
		Key:   key,
		Path:  path,
		Value: value,
		Mode:  mode,
	}
	mock.lockJSONSetMode.Lock()
	mock.calls.JSONSetMode = append(mock.calls.JSONSetMode, callInfo)
	mock.lockJSONSetMode.Unlock()
	return mock.JSONSetModeFunc(ctx, key, path, value, mode)
}

// JSONSetModeCalls gets all the calls that were made to JSONSetMode.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONSetModeCalls())
func (mock *GoRedisClientMock) JSONSetModeCalls() []struct {
	Ctx   context.Context
	Key   string
	Path  string
	Value interface{}
	Mode  string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value interface{}
		Mode  string
	}
	mock.lockJSONSetMode.RLock()
	calls = mock.calls.JSONSetMode
	mock.lockJSONSetMode.RUnlock()
	return calls
}

// JSONStrAppend calls JSONStrAppendFunc.
func (mock *GoRedisClientMock) JSONStrAppend(ctx context.Context, key string, path string, value string) *redis.IntPointerSliceCmd {
	if mock.JSONStrAppendFunc == nil {
		panic("GoRedisClientMock.JSONStrAppendFunc: method is nil but GoRedisClient.JSONStrAppend was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value string
	}{
		Ctx:   ctx,
		Key:   key,
		Path:  path,
		Value: value,
	}
	mock.lockJSONStrAppend.Lock()
	mock.calls.JSONStrAppend = append(mock.calls.JSONStrAppend, callInfo)
	mock.lockJSONStrAppend.Unlock()
	return mock.JSONStrAppendFunc(ctx, key, path, value)
}

// JSONStrAppendCalls gets all the calls that were made to JSONStrAppend.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONStrAppendCalls())
func (mock *GoRedisClientMock) JSONStrAppendCalls() []struct {
	Ctx   context.Context
	Key   string
	Path  string
	Value string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Path  string
		Value string
	}
	mock.lockJSONStrAppend.RLock()
	calls = mock.calls.JSONStrAppend
	mock.lockJSONStrAppend.RUnlock()
	return calls
}

// JSONStrLen calls JSONStrLenFunc.
func (mock *GoRedisClientMock) JSONStrLen(ctx context.Context, key string, path string) *redis.IntPointerSliceCmd {
	if mock.JSONStrLenFunc == nil {
		panic("GoRedisClientMock.JSONStrLenFunc: method is nil but GoRedisClient.JSONStrLen was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Path string
	}{
		Ctx:  ctx,
		Key:  key,
		Path: path,
	}
	mock.lockJSONStrLen.Lock()
	mock.calls.JSONStrLen = append(mock.calls.JSONStrLen, callInfo)
	mock.lockJSONStrLen.Unlock()
	return mock.JSONStrLenFunc(ctx, key, path)
}

// JSONStrLenCalls gets all the calls that were made to JSONStrLen.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONStrLenCalls())
func (mock *GoRedisClientMock) JSONStrLenCalls() []struct {
	Ctx  context.Context
	Key  string
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Path string
	}
	mock.lockJSONStrLen.RLock()
	calls = mock.calls.JSONStrLen
	mock.lockJSONStrLen.RUnlock()
	return calls
}

// JSONToggle calls JSONToggleFunc.
func (mock *GoRedisClientMock) JSONToggle(ctx context.Context, key string, path string) *redis.IntPointerSliceCmd {
	if mock.JSONToggleFunc == nil {
		panic("GoRedisClientMock.JSONToggleFunc: method is nil but GoRedisClient.JSONToggle was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Path string
	}{
		Ctx:  ctx,
		Key:  key,
		Path: path,
	}
	mock.lockJSONToggle.Lock()
	mock.calls.JSONToggle = append(mock.calls.JSONToggle, callInfo)
	mock.lockJSONToggle.Unlock()
	return mock.JSONToggleFunc(ctx, key, path)
}

// JSONToggleCalls gets all the calls that were made to JSONToggle.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONToggleCalls())
func (mock *GoRedisClientMock) JSONToggleCalls() []struct {
	Ctx  context.Context
	Key  string
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Path string
	}
	mock.lockJSONToggle.RLock()
	calls = mock.calls.JSONToggle
	mock.lockJSONToggle.RUnlock()
	return calls
}

// JSONType calls JSONTypeFunc.
func (mock *GoRedisClientMock) JSONType(ctx context.Context, key string, path string) *redis.JSONSliceCmd {
	if mock.JSONTypeFunc == nil {
		panic("GoRedisClientMock.JSONTypeFunc: method is nil but GoRedisClient.JSONType was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Path string
	}{
		Ctx:  ctx,
		Key:  key,
		Path: path,
	}
	mock.lockJSONType.Lock()
	mock.calls.JSONType = append(mock.calls.JSONType, callInfo)
	mock.lockJSONType.Unlock()
	return mock.JSONTypeFunc(ctx, key, path)
}

// JSONTypeCalls gets all the calls that were made to JSONType.
// Check the length with:
//
//	len(mockedGoRedisClient.JSONTypeCalls())
func (mock *GoRedisClientMock) JSONTypeCalls() []struct {
	Ctx  context.Context
	Key  string
	Path string
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Path string
	}
	mock.lockJSONType.RLock()
	calls = mock.calls.JSONType
	mock.lockJSONType.RUnlock()
	return calls
}

// Keys calls KeysFunc.
func (mock *GoRedisClientMock) Keys(ctx context.Context, pattern string) *redis.StringSliceCmd {
	if mock.KeysFunc == nil {
		panic("GoRedisClientMock.KeysFunc: method is nil but GoRedisClient.Keys was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Pattern string
	}{
		Ctx:     ctx,
		Pattern: pattern,
	}
	mock.lockKeys.Lock()
	mock.calls.Keys = append(mock.calls.Keys, callInfo)
	mock.lockKeys.Unlock()
	return mock.KeysFunc(ctx, pattern)
}

// KeysCalls gets all the calls that were made to Keys.
// Check the length with:
//
//	len(mockedGoRedisClient.KeysCalls())
func (mock *GoRedisClientMock) KeysCalls() []struct {
	Ctx     context.Context
	Pattern string
} {
	var calls []struct {
		Ctx     context.Context
		Pattern string
	}
	mock.lockKeys.RLock()
	calls = mock.calls.Keys
	mock.lockKeys.RUnlock()
	return calls
}

// LCS calls LCSFunc.
func (mock *GoRedisClientMock) LCS(ctx context.Context, q *redis.LCSQuery) *redis.LCSCmd {
	if mock.LCSFunc == nil {
		panic("GoRedisClientMock.LCSFunc: method is nil but GoRedisClient.LCS was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Q   *redis.LCSQuery
	}{
		Ctx: ctx,
		Q:   q,
	}
	mock.lockLCS.Lock()
	mock.calls.LCS = append(mock.calls.LCS, callInfo)
	mock.lockLCS.Unlock()
	return mock.LCSFunc(ctx, q)
}

// LCSCalls gets all the calls that were made to LCS.
// Check the length with:
//
//	len(mockedGoRedisClient.LCSCalls())
func (mock *GoRedisClientMock) LCSCalls() []struct {
	Ctx context.Context
	Q   *redis.LCSQuery
} {
	var calls []struct {
		Ctx context.Context
		Q   *redis.LCSQuery
	}
	mock.lockLCS.RLock()
	calls = mock.calls.LCS
	mock.lockLCS.RUnlock()
	return calls
}

// LIndex calls LIndexFunc.
func (mock *GoRedisClientMock) LIndex(ctx context.Context, key string, index int64) *redis.StringCmd {
	if mock.LIndexFunc == nil {
		panic("GoRedisClientMock.LIndexFunc: method is nil but GoRedisClient.LIndex was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Index int64
	}{
		Ctx:   ctx,
		Key:   key,
		Index: index,
	}
	mock.lockLIndex.Lock()
	mock.calls.LIndex = append(mock.calls.LIndex, callInfo)
	mock.lockLIndex.Unlock()
	return mock.LIndexFunc(ctx, key, index)
}

// LIndexCalls gets all the calls that were made to LIndex.
// Check the length with:
//
//	len(mockedGoRedisClient.LIndexCalls())
func (mock *GoRedisClientMock) LIndexCalls() []struct {
	Ctx   context.Context
	Key   string
	Index int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Index int64
	}
	mock.lockLIndex.RLock()
	calls = mock.calls.LIndex
	mock.lockLIndex.RUnlock()
	return calls
}

// LInsert calls LInsertFunc.
func (mock *GoRedisClientMock) LInsert(ctx context.Context, key string, op string, pivot interface{}, value interface{}) *redis.IntCmd {
	if mock.LInsertFunc == nil {
		panic("GoRedisClientMock.LInsertFunc: method is nil but GoRedisClient.LInsert was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Op    string
		Pivot interface{}
		Value interface{}
	}{
		Ctx:   ctx,
		Key:   key,
		Op:    op,
		Pivot: pivot,
		Value: value,
	}
	mock.lockLInsert.Lock()
	mock.calls.LInsert = append(mock.calls.LInsert, callInfo)
	mock.lockLInsert.Unlock()
	return mock.LInsertFunc(ctx, key, op, pivot, value)
}

// LInsertCalls gets all the calls that were made to LInsert.
// Check the length with:
//
//	len(mockedGoRedisClient.LInsertCalls())
func (mock *GoRedisClientMock) LInsertCalls() []struct {
	Ctx   context.Context
	Key   string
	Op    string
	Pivot interface{}
	Value interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Op    string
		Pivot interface{}
		Value interface{}
	}
	mock.lockLInsert.RLock()
	calls = mock.calls.LInsert
	mock.lockLInsert.RUnlock()
	return calls
}

// LInsertAfter calls LInsertAfterFunc.
func (mock *GoRedisClientMock) LInsertAfter(ctx context.Context, key string, pivot interface{}, value interface{}) *redis.IntCmd {
	if mock.LInsertAfterFunc == nil {
		panic("GoRedisClientMock.LInsertAfterFunc: method is nil but GoRedisClient.LInsertAfter was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Pivot interface{}
		Value interface{}
	}{
		Ctx:   ctx,
		Key:   key,
		Pivot: pivot,
		Value: value,
	}
	mock.lockLInsertAfter.Lock()
	mock.calls.LInsertAfter = append(mock.calls.LInsertAfter, callInfo)
	mock.lockLInsertAfter.Unlock()
	return mock.LInsertAfterFunc(ctx, key, pivot, value)
}

// LInsertAfterCalls gets all the calls that were made to LInsertAfter.
// Check the length with:
//
//	len(mockedGoRedisClient.LInsertAfterCalls())
func (mock *GoRedisClientMock) LInsertAfterCalls() []struct {
	Ctx   context.Context
	Key   string
	Pivot interface{}
	Value interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Pivot interface{}
		Value interface{}
	}
	mock.lockLInsertAfter.RLock()
	calls = mock.calls.LInsertAfter
	mock.lockLInsertAfter.RUnlock()
	return calls
}

// LInsertBefore calls LInsertBeforeFunc.
func (mock *GoRedisClientMock) LInsertBefore(ctx context.Context, key string, pivot interface{}, value interface{}) *redis.IntCmd {
	if mock.LInsertBeforeFunc == nil {
		panic("GoRedisClientMock.LInsertBeforeFunc: method is nil but GoRedisClient.LInsertBefore was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Pivot interface{}
		Value interface{}
	}{
		Ctx:   ctx,
		Key:   key,
		Pivot: pivot,
		Value: value,
	}
	mock.lockLInsertBefore.Lock()
	mock.calls.LInsertBefore = append(mock.calls.LInsertBefore, callInfo)
	mock.lockLInsertBefore.Unlock()
	return mock.LInsertBeforeFunc(ctx, key, pivot, value)
}

// LInsertBeforeCalls gets all the calls that were made to LInsertBefore.
// Check the length with:
//
//	len(mockedGoRedisClient.LInsertBeforeCalls())
func (mock *GoRedisClientMock) LInsertBeforeCalls() []struct {
	Ctx   context.Context
	Key   string
	Pivot interface{}
	Value interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Pivot interface{}
		Value interface{}
	}
	mock.lockLInsertBefore.RLock()
	calls = mock.calls.LInsertBefore
	mock.lockLInsertBefore.RUnlock()
	return calls
}

// LLen calls LLenFunc.
func (mock *GoRedisClientMock) LLen(ctx context.Context, key string) *redis.IntCmd {
	if mock.LLenFunc == nil {
		panic("GoRedisClientMock.LLenFunc: method is nil but GoRedisClient.LLen was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockLLen.Lock()
	mock.calls.LLen = append(mock.calls.LLen, callInfo)
	mock.lockLLen.Unlock()
	return mock.LLenFunc(ctx, key)
}

// LLenCalls gets all the calls that were made to LLen.
// Check the length with:
//
//	len(mockedGoRedisClient.LLenCalls())
func (mock *GoRedisClientMock) LLenCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockLLen.RLock()
	calls = mock.calls.LLen
	mock.lockLLen.RUnlock()
	return calls
}

// LMPop calls LMPopFunc.
func (mock *GoRedisClientMock) LMPop(ctx context.Context, direction string, count int64, keys ...string) *redis.KeyValuesCmd {
	if mock.LMPopFunc == nil {
		panic("GoRedisClientMock.LMPopFunc: method is nil but GoRedisClient.LMPop was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Direction string
		Count     int64
		Keys      []string
	}{
		Ctx:       ctx,
		Direction: direction,
		Count:     count,
		Keys:      keys,
	}
	mock.lockLMPop.Lock()
	mock.calls.LMPop = append(mock.calls.LMPop, callInfo)
	mock.lockLMPop.Unlock()
	return mock.LMPopFunc(ctx, direction, count, keys...)
}

// LMPopCalls gets all the calls that were made to LMPop.
// Check the length with:
//
//	len(mockedGoRedisClient.LMPopCalls())
func (mock *GoRedisClientMock) LMPopCalls() []struct {
	Ctx       context.Context
	Direction string
	Count     int64
	Keys      []string
} {
	var calls []struct {
		Ctx       context.Context
		Direction string
		Count     int64
		Keys      []string
	}
	mock.lockLMPop.RLock()
	calls = mock.calls.LMPop
	mock.lockLMPop.RUnlock()
	return calls
}

// LMove calls LMoveFunc.
func (mock *GoRedisClientMock) LMove(ctx context.Context, source string, destination string, srcpos string, destpos string) *redis.StringCmd {
	if mock.LMoveFunc == nil {
		panic("GoRedisClientMock.LMoveFunc: method is nil but GoRedisClient.LMove was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Source      string
		Destination string
		Srcpos      string
		Destpos     string
	}{
		Ctx:         ctx,
		Source:      source,
		Destination: destination,
		Srcpos:      srcpos,
		Destpos:     destpos,
	}
	mock.lockLMove.Lock()
	mock.calls.LMove = append(mock.calls.LMove, callInfo)
	mock.lockLMove.Unlock()
	return mock.LMoveFunc(ctx, source, destination, srcpos, destpos)
}

// LMoveCalls gets all the calls that were made to LMove.
// Check the length with:
//
//	len(mockedGoRedisClient.LMoveCalls())
func (mock *GoRedisClientMock) LMoveCalls() []struct {
	Ctx         context.Context
	Source      string
	Destination string
	Srcpos      string
	Destpos     string
} {
	var calls []struct {
		Ctx         context.Context
		Source      string
		Destination string
		Srcpos      string
		Destpos     string
	}
	mock.lockLMove.RLock()
	calls = mock.calls.LMove
	mock.lockLMove.RUnlock()
	return calls
}

// LPop calls LPopFunc.
func (mock *GoRedisClientMock) LPop(ctx context.Context, key string) *redis.StringCmd {
	if mock.LPopFunc == nil {
		panic("GoRedisClientMock.LPopFunc: method is nil but GoRedisClient.LPop was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockLPop.Lock()
	mock.calls.LPop = append(mock.calls.LPop, callInfo)
	mock.lockLPop.Unlock()
	return mock.LPopFunc(ctx, key)
}

// LPopCalls gets all the calls that were made to LPop.
// Check the length with:
//
//	len(mockedGoRedisClient.LPopCalls())
func (mock *GoRedisClientMock) LPopCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockLPop.RLock()
	calls = mock.calls.LPop
	mock.lockLPop.RUnlock()
	return calls
}

// LPopCount calls LPopCountFunc.
func (mock *GoRedisClientMock) LPopCount(ctx context.Context, key string, count int) *redis.StringSliceCmd {
	if mock.LPopCountFunc == nil {
		panic("GoRedisClientMock.LPopCountFunc: method is nil but GoRedisClient.LPopCount was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count int
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
	}
	mock.lockLPopCount.Lock()
	mock.calls.LPopCount = append(mock.calls.LPopCount, callInfo)
	mock.lockLPopCount.Unlock()
	return mock.LPopCountFunc(ctx, key, count)
}

// LPopCountCalls gets all the calls that were made to LPopCount.
// Check the length with:
//
//	len(mockedGoRedisClient.LPopCountCalls())
func (mock *GoRedisClientMock) LPopCountCalls() []struct {
	Ctx   context.Context
	Key   string
	Count int
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count int
	}
	mock.lockLPopCount.RLock()
	calls = mock.calls.LPopCount
	mock.lockLPopCount.RUnlock()
	return calls
}

// LPos calls LPosFunc.
func (mock *GoRedisClientMock) LPos(ctx context.Context, key string, value string, args redis.LPosArgs) *redis.IntCmd {
	if mock.LPosFunc == nil {
		panic("GoRedisClientMock.LPosFunc: method is nil but GoRedisClient.LPos was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Value string
		Args  redis.LPosArgs
	}{
		Ctx:   ctx,
		Key:   key,
		Value: value,
		Args:  args,
	}
	mock.lockLPos.Lock()
	mock.calls.LPos = append(mock.calls.LPos, callInfo)
	mock.lockLPos.Unlock()
	return mock.LPosFunc(ctx, key, value, args)
}

// LPosCalls gets all the calls that were made to LPos.
// Check the length with:
//
//	len(mockedGoRedisClient.LPosCalls())
func (mock *GoRedisClientMock) LPosCalls() []struct {
	Ctx   context.Context
	Key   string
	Value string
	Args  redis.LPosArgs
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Value string
		Args  redis.LPosArgs
	}
	mock.lockLPos.RLock()
	calls = mock.calls.LPos
	mock.lockLPos.RUnlock()
	return calls
}

// LPosCount calls LPosCountFunc.
func (mock *GoRedisClientMock) LPosCount(ctx context.Context, key string, value string, count int64, args redis.LPosArgs) *redis.IntSliceCmd {
	if mock.LPosCountFunc == nil {
		panic("GoRedisClientMock.LPosCountFunc: method is nil but GoRedisClient.LPosCount was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Value string
		Count int64
		Args  redis.LPosArgs
	}{
		Ctx:   ctx,
		Key:   key,
		Value: value,
		Count: count,
		Args:  args,
	}
	mock.lockLPosCount.Lock()
	mock.calls.LPosCount = append(mock.calls.LPosCount, callInfo)
	mock.lockLPosCount.Unlock()
	return mock.LPosCountFunc(ctx, key, value, count, args)
}

// LPosCountCalls gets all the calls that were made to LPosCount.
// Check the length with:
//
//	len(mockedGoRedisClient.LPosCountCalls())
func (mock *GoRedisClientMock) LPosCountCalls() []struct {
	Ctx   context.Context
	Key   string
	Value string
	Count int64
	Args  redis.LPosArgs
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Value string
		Count int64
		Args  redis.LPosArgs
	}
	mock.lockLPosCount.RLock()
	calls = mock.calls.LPosCount
	mock.lockLPosCount.RUnlock()
	return calls
}

// LPush calls LPushFunc.
func (mock *GoRedisClientMock) LPush(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	if mock.LPushFunc == nil {
		panic("GoRedisClientMock.LPushFunc: method is nil but GoRedisClient.LPush was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}{
		Ctx:    ctx,
		Key:    key,
		Values: values,
	}
	mock.lockLPush.Lock()
	mock.calls.LPush = append(mock.calls.LPush, callInfo)
	mock.lockLPush.Unlock()
	return mock.LPushFunc(ctx, key, values...)
}

// LPushCalls gets all the calls that were made to LPush.
// Check the length with:
//
//	len(mockedGoRedisClient.LPushCalls())
func (mock *GoRedisClientMock) LPushCalls() []struct {
	Ctx    context.Context
	Key    string
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}
	mock.lockLPush.RLock()
	calls = mock.calls.LPush
	mock.lockLPush.RUnlock()
	return calls
}

// LPushX calls LPushXFunc.
func (mock *GoRedisClientMock) LPushX(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	if mock.LPushXFunc == nil {
		panic("GoRedisClientMock.LPushXFunc: method is nil but GoRedisClient.LPushX was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}{
		Ctx:    ctx,
		Key:    key,
		Values: values,
	}
	mock.lockLPushX.Lock()
	mock.calls.LPushX = append(mock.calls.LPushX, callInfo)
	mock.lockLPushX.Unlock()
	return mock.LPushXFunc(ctx, key, values...)
}

// LPushXCalls gets all the calls that were made to LPushX.
// Check the length with:
//
//	len(mockedGoRedisClient.LPushXCalls())
func (mock *GoRedisClientMock) LPushXCalls() []struct {
	Ctx    context.Context
	Key    string
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}
	mock.lockLPushX.RLock()
	calls = mock.calls.LPushX
	mock.lockLPushX.RUnlock()
	return calls
}

// LRange calls LRangeFunc.
func (mock *GoRedisClientMock) LRange(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd {
	if mock.LRangeFunc == nil {
		panic("GoRedisClientMock.LRangeFunc: method is nil but GoRedisClient.LRange was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}{
		Ctx:   ctx,
		Key:   key,
		Start: start,
		Stop:  stop,
	}
	mock.lockLRange.Lock()
	mock.calls.LRange = append(mock.calls.LRange, callInfo)
	mock.lockLRange.Unlock()
	return mock.LRangeFunc(ctx, key, start, stop)
}

// LRangeCalls gets all the calls that were made to LRange.
// Check the length with:
//
//	len(mockedGoRedisClient.LRangeCalls())
func (mock *GoRedisClientMock) LRangeCalls() []struct {
	Ctx   context.Context
	Key   string
	Start int64
	Stop  int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}
	mock.lockLRange.RLock()
	calls = mock.calls.LRange
	mock.lockLRange.RUnlock()
	return calls
}

// LRem calls LRemFunc.
func (mock *GoRedisClientMock) LRem(ctx context.Context, key string, count int64, value interface{}) *redis.IntCmd {
	if mock.LRemFunc == nil {
		panic("GoRedisClientMock.LRemFunc: method is nil but GoRedisClient.LRem was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count int64
		Value interface{}
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
		Value: value,
	}
	mock.lockLRem.Lock()
	mock.calls.LRem = append(mock.calls.LRem, callInfo)
	mock.lockLRem.Unlock()
	return mock.LRemFunc(ctx, key, count, value)
}

// LRemCalls gets all the calls that were made to LRem.
// Check the length with:
//
//	len(mockedGoRedisClient.LRemCalls())
func (mock *GoRedisClientMock) LRemCalls() []struct {
	Ctx   context.Context
	Key   string
	Count int64
	Value interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count int64
		Value interface{}
	}
	mock.lockLRem.RLock()
	calls = mock.calls.LRem
	mock.lockLRem.RUnlock()
	return calls
}

// LSet calls LSetFunc.
func (mock *GoRedisClientMock) LSet(ctx context.Context, key string, index int64, value interface{}) *redis.StatusCmd {
	if mock.LSetFunc == nil {
		panic("GoRedisClientMock.LSetFunc: method is nil but GoRedisClient.LSet was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Index int64
		Value interface{}
	}{
		Ctx:   ctx,
		Key:   key,
		Index: index,
		Value: value,
	}
	mock.lockLSet.Lock()
	mock.calls.LSet = append(mock.calls.LSet, callInfo)
	mock.lockLSet.Unlock()
	return mock.LSetFunc(ctx, key, index, value)
}

// LSetCalls gets all the calls that were made to LSet.
// Check the length with:
//
//	len(mockedGoRedisClient.LSetCalls())
func (mock *GoRedisClientMock) LSetCalls() []struct {
	Ctx   context.Context
	Key   string
	Index int64
	Value interface{}
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Index int64
		Value interface{}
	}
	mock.lockLSet.RLock()
	calls = mock.calls.LSet
	mock.lockLSet.RUnlock()
	return calls
}

// LTrim calls LTrimFunc.
func (mock *GoRedisClientMock) LTrim(ctx context.Context, key string, start int64, stop int64) *redis.StatusCmd {
	if mock.LTrimFunc == nil {
		panic("GoRedisClientMock.LTrimFunc: method is nil but GoRedisClient.LTrim was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}{
		Ctx:   ctx,
		Key:   key,
		Start: start,
		Stop:  stop,
	}
	mock.lockLTrim.Lock()
	mock.calls.LTrim = append(mock.calls.LTrim, callInfo)
	mock.lockLTrim.Unlock()
	return mock.LTrimFunc(ctx, key, start, stop)
}

// LTrimCalls gets all the calls that were made to LTrim.
// Check the length with:
//
//	len(mockedGoRedisClient.LTrimCalls())
func (mock *GoRedisClientMock) LTrimCalls() []struct {
	Ctx   context.Context
	Key   string
	Start int64
	Stop  int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}
	mock.lockLTrim.RLock()
	calls = mock.calls.LTrim
	mock.lockLTrim.RUnlock()
	return calls
}

// LastSave calls LastSaveFunc.
func (mock *GoRedisClientMock) LastSave(ctx context.Context) *redis.IntCmd {
	if mock.LastSaveFunc == nil {
		panic("GoRedisClientMock.LastSaveFunc: method is nil but GoRedisClient.LastSave was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockLastSave.Lock()
	mock.calls.LastSave = append(mock.calls.LastSave, callInfo)
	mock.lockLastSave.Unlock()
	return mock.LastSaveFunc(ctx)
}

// LastSaveCalls gets all the calls that were made to LastSave.
// Check the length with:
//
//	len(mockedGoRedisClient.LastSaveCalls())
func (mock *GoRedisClientMock) LastSaveCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockLastSave.RLock()
	calls = mock.calls.LastSave
	mock.lockLastSave.RUnlock()
	return calls
}

// MGet calls MGetFunc.
func (mock *GoRedisClientMock) MGet(ctx context.Context, keys ...string) *redis.SliceCmd {
	if mock.MGetFunc == nil {
		panic("GoRedisClientMock.MGetFunc: method is nil but GoRedisClient.MGet was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockMGet.Lock()
	mock.calls.MGet = append(mock.calls.MGet, callInfo)
	mock.lockMGet.Unlock()
	return mock.MGetFunc(ctx, keys...)
}

// MGetCalls gets all the calls that were made to MGet.
// Check the length with:
//
//	len(mockedGoRedisClient.MGetCalls())
func (mock *GoRedisClientMock) MGetCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockMGet.RLock()
	calls = mock.calls.MGet
	mock.lockMGet.RUnlock()
	return calls
}

// MSet calls MSetFunc.
func (mock *GoRedisClientMock) MSet(ctx context.Context, values ...interface{}) *redis.StatusCmd {
	if mock.MSetFunc == nil {
		panic("GoRedisClientMock.MSetFunc: method is nil but GoRedisClient.MSet was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Values []interface{}
	}{
		Ctx:    ctx,
		Values: values,
	}
	mock.lockMSet.Lock()
	mock.calls.MSet = append(mock.calls.MSet, callInfo)
	mock.lockMSet.Unlock()
	return mock.MSetFunc(ctx, values...)
}

// MSetCalls gets all the calls that were made to MSet.
// Check the length with:
//
//	len(mockedGoRedisClient.MSetCalls())
func (mock *GoRedisClientMock) MSetCalls() []struct {
	Ctx    context.Context
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Values []interface{}
	}
	mock.lockMSet.RLock()
	calls = mock.calls.MSet
	mock.lockMSet.RUnlock()
	return calls
}

// MSetNX calls MSetNXFunc.
func (mock *GoRedisClientMock) MSetNX(ctx context.Context, values ...interface{}) *redis.BoolCmd {
	if mock.MSetNXFunc == nil {
		panic("GoRedisClientMock.MSetNXFunc: method is nil but GoRedisClient.MSetNX was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Values []interface{}
	}{
		Ctx:    ctx,
		Values: values,
	}
	mock.lockMSetNX.Lock()
	mock.calls.MSetNX = append(mock.calls.MSetNX, callInfo)
	mock.lockMSetNX.Unlock()
	return mock.MSetNXFunc(ctx, values...)
}

// MSetNXCalls gets all the calls that were made to MSetNX.
// Check the length with:
//
//	len(mockedGoRedisClient.MSetNXCalls())
func (mock *GoRedisClientMock) MSetNXCalls() []struct {
	Ctx    context.Context
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Values []interface{}
	}
	mock.lockMSetNX.RLock()
	calls = mock.calls.MSetNX
	mock.lockMSetNX.RUnlock()
	return calls
}

// MemoryUsage calls MemoryUsageFunc.
func (mock *GoRedisClientMock) MemoryUsage(ctx context.Context, key string, samples ...int) *redis.IntCmd {
	if mock.MemoryUsageFunc == nil {
		panic("GoRedisClientMock.MemoryUsageFunc: method is nil but GoRedisClient.MemoryUsage was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Samples []int
	}{
		Ctx:     ctx,
		Key:     key,
		Samples: samples,
	}
	mock.lockMemoryUsage.Lock()
	mock.calls.MemoryUsage = append(mock.calls.MemoryUsage, callInfo)
	mock.lockMemoryUsage.Unlock()
	return mock.MemoryUsageFunc(ctx, key, samples...)
}

// MemoryUsageCalls gets all the calls that were made to MemoryUsage.
// Check the length with:
//
//	len(mockedGoRedisClient.MemoryUsageCalls())
func (mock *GoRedisClientMock) MemoryUsageCalls() []struct {
	Ctx     context.Context
	Key     string
	Samples []int
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Samples []int
	}
	mock.lockMemoryUsage.RLock()
	calls = mock.calls.MemoryUsage
	mock.lockMemoryUsage.RUnlock()
	return calls
}

// Migrate calls MigrateFunc.
func (mock *GoRedisClientMock) Migrate(ctx context.Context, host string, port string, key string, db int, timeout time.Duration) *redis.StatusCmd {
	if mock.MigrateFunc == nil {
		panic("GoRedisClientMock.MigrateFunc: method is nil but GoRedisClient.Migrate was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Host    string
		Port    string
		Key     string
		Db      int
		Timeout time.Duration
	}{
		Ctx:     ctx,
		Host:    host,
		Port:    port,
		Key:     key,
		Db:      db,
		Timeout: timeout,
	}
	mock.lockMigrate.Lock()
	mock.calls.Migrate = append(mock.calls.Migrate, callInfo)
	mock.lockMigrate.Unlock()
	return mock.MigrateFunc(ctx, host, port, key, db, timeout)
}

// MigrateCalls gets all the calls that were made to Migrate.
// Check the length with:
//
//	len(mockedGoRedisClient.MigrateCalls())
func (mock *GoRedisClientMock) MigrateCalls() []struct {
	Ctx     context.Context
	Host    string
	Port    string
	Key     string
	Db      int
	Timeout time.Duration
} {
	var calls []struct {
		Ctx     context.Context
		Host    string
		Port    string
		Key     string
		Db      int
		Timeout time.Duration
	}
	mock.lockMigrate.RLock()
	calls = mock.calls.Migrate
	mock.lockMigrate.RUnlock()
	return calls
}

// ModuleLoadex calls ModuleLoadexFunc.
func (mock *GoRedisClientMock) ModuleLoadex(ctx context.Context, conf *redis.ModuleLoadexConfig) *redis.StringCmd {
	if mock.ModuleLoadexFunc == nil {
		panic("GoRedisClientMock.ModuleLoadexFunc: method is nil but GoRedisClient.ModuleLoadex was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Conf *redis.ModuleLoadexConfig
	}{
		Ctx:  ctx,
		Conf: conf,
	}
	mock.lockModuleLoadex.Lock()
	mock.calls.ModuleLoadex = append(mock.calls.ModuleLoadex, callInfo)
	mock.lockModuleLoadex.Unlock()
	return mock.ModuleLoadexFunc(ctx, conf)
}

// ModuleLoadexCalls gets all the calls that were made to ModuleLoadex.
// Check the length with:
//
//	len(mockedGoRedisClient.ModuleLoadexCalls())
func (mock *GoRedisClientMock) ModuleLoadexCalls() []struct {
	Ctx  context.Context
	Conf *redis.ModuleLoadexConfig
} {
	var calls []struct {
		Ctx  context.Context
		Conf *redis.ModuleLoadexConfig
	}
	mock.lockModuleLoadex.RLock()
	calls = mock.calls.ModuleLoadex
	mock.lockModuleLoadex.RUnlock()
	return calls
}

// Move calls MoveFunc.
func (mock *GoRedisClientMock) Move(ctx context.Context, key string, db int) *redis.BoolCmd {
	if mock.MoveFunc == nil {
		panic("GoRedisClientMock.MoveFunc: method is nil but GoRedisClient.Move was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Db  int
	}{
		Ctx: ctx,
		Key: key,
		Db:  db,
	}
	mock.lockMove.Lock()
	mock.calls.Move = append(mock.calls.Move, callInfo)
	mock.lockMove.Unlock()
	return mock.MoveFunc(ctx, key, db)
}

// MoveCalls gets all the calls that were made to Move.
// Check the length with:
//
//	len(mockedGoRedisClient.MoveCalls())
func (mock *GoRedisClientMock) MoveCalls() []struct {
	Ctx context.Context
	Key string
	Db  int
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Db  int
	}
	mock.lockMove.RLock()
	calls = mock.calls.Move
	mock.lockMove.RUnlock()
	return calls
}

// ObjectEncoding calls ObjectEncodingFunc.
func (mock *GoRedisClientMock) ObjectEncoding(ctx context.Context, key string) *redis.StringCmd {
	if mock.ObjectEncodingFunc == nil {
		panic("GoRedisClientMock.ObjectEncodingFunc: method is nil but GoRedisClient.ObjectEncoding was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockObjectEncoding.Lock()
	mock.calls.ObjectEncoding = append(mock.calls.ObjectEncoding, callInfo)
	mock.lockObjectEncoding.Unlock()
	return mock.ObjectEncodingFunc(ctx, key)
}

// ObjectEncodingCalls gets all the calls that were made to ObjectEncoding.
// Check the length with:
//
//	len(mockedGoRedisClient.ObjectEncodingCalls())
func (mock *GoRedisClientMock) ObjectEncodingCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockObjectEncoding.RLock()
	calls = mock.calls.ObjectEncoding
	mock.lockObjectEncoding.RUnlock()
	return calls
}

// ObjectFreq calls ObjectFreqFunc.
func (mock *GoRedisClientMock) ObjectFreq(ctx context.Context, key string) *redis.IntCmd {
	if mock.ObjectFreqFunc == nil {
		panic("GoRedisClientMock.ObjectFreqFunc: method is nil but GoRedisClient.ObjectFreq was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockObjectFreq.Lock()
	mock.calls.ObjectFreq = append(mock.calls.ObjectFreq, callInfo)
	mock.lockObjectFreq.Unlock()
	return mock.ObjectFreqFunc(ctx, key)
}

// ObjectFreqCalls gets all the calls that were made to ObjectFreq.
// Check the length with:
//
//	len(mockedGoRedisClient.ObjectFreqCalls())
func (mock *GoRedisClientMock) ObjectFreqCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockObjectFreq.RLock()
	calls = mock.calls.ObjectFreq
	mock.lockObjectFreq.RUnlock()
	return calls
}

// ObjectIdleTime calls ObjectIdleTimeFunc.
func (mock *GoRedisClientMock) ObjectIdleTime(ctx context.Context, key string) *redis.DurationCmd {
	if mock.ObjectIdleTimeFunc == nil {
		panic("GoRedisClientMock.ObjectIdleTimeFunc: method is nil but GoRedisClient.ObjectIdleTime was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockObjectIdleTime.Lock()
	mock.calls.ObjectIdleTime = append(mock.calls.ObjectIdleTime, callInfo)
	mock.lockObjectIdleTime.Unlock()
	return mock.ObjectIdleTimeFunc(ctx, key)
}

// ObjectIdleTimeCalls gets all the calls that were made to ObjectIdleTime.
// Check the length with:
//
//	len(mockedGoRedisClient.ObjectIdleTimeCalls())
func (mock *GoRedisClientMock) ObjectIdleTimeCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockObjectIdleTime.RLock()
	calls = mock.calls.ObjectIdleTime
	mock.lockObjectIdleTime.RUnlock()
	return calls
}

// ObjectRefCount calls ObjectRefCountFunc.
func (mock *GoRedisClientMock) ObjectRefCount(ctx context.Context, key string) *redis.IntCmd {
	if mock.ObjectRefCountFunc == nil {
		panic("GoRedisClientMock.ObjectRefCountFunc: method is nil but GoRedisClient.ObjectRefCount was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockObjectRefCount.Lock()
	mock.calls.ObjectRefCount = append(mock.calls.ObjectRefCount, callInfo)
	mock.lockObjectRefCount.Unlock()
	return mock.ObjectRefCountFunc(ctx, key)
}

// ObjectRefCountCalls gets all the calls that were made to ObjectRefCount.
// Check the length with:
//
//	len(mockedGoRedisClient.ObjectRefCountCalls())
func (mock *GoRedisClientMock) ObjectRefCountCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockObjectRefCount.RLock()
	calls = mock.calls.ObjectRefCount
	mock.lockObjectRefCount.RUnlock()
	return calls
}

// PExpire calls PExpireFunc.
func (mock *GoRedisClientMock) PExpire(ctx context.Context, key string, expiration time.Duration) *redis.BoolCmd {
	if mock.PExpireFunc == nil {
		panic("GoRedisClientMock.PExpireFunc: method is nil but GoRedisClient.PExpire was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Expiration: expiration,
	}
	mock.lockPExpire.Lock()
	mock.calls.PExpire = append(mock.calls.PExpire, callInfo)
	mock.lockPExpire.Unlock()
	return mock.PExpireFunc(ctx, key, expiration)
}

// PExpireCalls gets all the calls that were made to PExpire.
// Check the length with:
//
//	len(mockedGoRedisClient.PExpireCalls())
func (mock *GoRedisClientMock) PExpireCalls() []struct {
	Ctx        context.Context
	Key        string
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Expiration time.Duration
	}
	mock.lockPExpire.RLock()
	calls = mock.calls.PExpire
	mock.lockPExpire.RUnlock()
	return calls
}

// PExpireAt calls PExpireAtFunc.
func (mock *GoRedisClientMock) PExpireAt(ctx context.Context, key string, tm time.Time) *redis.BoolCmd {
	if mock.PExpireAtFunc == nil {
		panic("GoRedisClientMock.PExpireAtFunc: method is nil but GoRedisClient.PExpireAt was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Tm  time.Time
	}{
		Ctx: ctx,
		Key: key,
		Tm:  tm,
	}
	mock.lockPExpireAt.Lock()
	mock.calls.PExpireAt = append(mock.calls.PExpireAt, callInfo)
	mock.lockPExpireAt.Unlock()
	return mock.PExpireAtFunc(ctx, key, tm)
}

// PExpireAtCalls gets all the calls that were made to PExpireAt.
// Check the length with:
//
//	len(mockedGoRedisClient.PExpireAtCalls())
func (mock *GoRedisClientMock) PExpireAtCalls() []struct {
	Ctx context.Context
	Key string
	Tm  time.Time
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Tm  time.Time
	}
	mock.lockPExpireAt.RLock()
	calls = mock.calls.PExpireAt
	mock.lockPExpireAt.RUnlock()
	return calls
}

// PExpireTime calls PExpireTimeFunc.
func (mock *GoRedisClientMock) PExpireTime(ctx context.Context, key string) *redis.DurationCmd {
	if mock.PExpireTimeFunc == nil {
		panic("GoRedisClientMock.PExpireTimeFunc: method is nil but GoRedisClient.PExpireTime was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockPExpireTime.Lock()
	mock.calls.PExpireTime = append(mock.calls.PExpireTime, callInfo)
	mock.lockPExpireTime.Unlock()
	return mock.PExpireTimeFunc(ctx, key)
}

// PExpireTimeCalls gets all the calls that were made to PExpireTime.
// Check the length with:
//
//	len(mockedGoRedisClient.PExpireTimeCalls())
func (mock *GoRedisClientMock) PExpireTimeCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockPExpireTime.RLock()
	calls = mock.calls.PExpireTime
	mock.lockPExpireTime.RUnlock()
	return calls
}

// PFAdd calls PFAddFunc.
func (mock *GoRedisClientMock) PFAdd(ctx context.Context, key string, els ...interface{}) *redis.IntCmd {
	if mock.PFAddFunc == nil {
		panic("GoRedisClientMock.PFAddFunc: method is nil but GoRedisClient.PFAdd was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Els []interface{}
	}{
		Ctx: ctx,
		Key: key,
		Els: els,
	}
	mock.lockPFAdd.Lock()
	mock.calls.PFAdd = append(mock.calls.PFAdd, callInfo)
	mock.lockPFAdd.Unlock()
	return mock.PFAddFunc(ctx, key, els...)
}

// PFAddCalls gets all the calls that were made to PFAdd.
// Check the length with:
//
//	len(mockedGoRedisClient.PFAddCalls())
func (mock *GoRedisClientMock) PFAddCalls() []struct {
	Ctx context.Context
	Key string
	Els []interface{}
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Els []interface{}
	}
	mock.lockPFAdd.RLock()
	calls = mock.calls.PFAdd
	mock.lockPFAdd.RUnlock()
	return calls
}

// PFCount calls PFCountFunc.
func (mock *GoRedisClientMock) PFCount(ctx context.Context, keys ...string) *redis.IntCmd {
	if mock.PFCountFunc == nil {
		panic("GoRedisClientMock.PFCountFunc: method is nil but GoRedisClient.PFCount was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockPFCount.Lock()
	mock.calls.PFCount = append(mock.calls.PFCount, callInfo)
	mock.lockPFCount.Unlock()
	return mock.PFCountFunc(ctx, keys...)
}

// PFCountCalls gets all the calls that were made to PFCount.
// Check the length with:
//
//	len(mockedGoRedisClient.PFCountCalls())
func (mock *GoRedisClientMock) PFCountCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockPFCount.RLock()
	calls = mock.calls.PFCount
	mock.lockPFCount.RUnlock()
	return calls
}

// PFMerge calls PFMergeFunc.
func (mock *GoRedisClientMock) PFMerge(ctx context.Context, dest string, keys ...string) *redis.StatusCmd {
	if mock.PFMergeFunc == nil {
		panic("GoRedisClientMock.PFMergeFunc: method is nil but GoRedisClient.PFMerge was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Dest string
		Keys []string
	}{
		Ctx:  ctx,
		Dest: dest,
		Keys: keys,
	}
	mock.lockPFMerge.Lock()
	mock.calls.PFMerge = append(mock.calls.PFMerge, callInfo)
	mock.lockPFMerge.Unlock()
	return mock.PFMergeFunc(ctx, dest, keys...)
}

// PFMergeCalls gets all the calls that were made to PFMerge.
// Check the length with:
//
//	len(mockedGoRedisClient.PFMergeCalls())
func (mock *GoRedisClientMock) PFMergeCalls() []struct {
	Ctx  context.Context
	Dest string
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Dest string
		Keys []string
	}
	mock.lockPFMerge.RLock()
	calls = mock.calls.PFMerge
	mock.lockPFMerge.RUnlock()
	return calls
}

// PSubscribe calls PSubscribeFunc.
func (mock *GoRedisClientMock) PSubscribe(ctx context.Context, channels ...string) *redis.PubSub {
	if mock.PSubscribeFunc == nil {
		panic("GoRedisClientMock.PSubscribeFunc: method is nil but GoRedisClient.PSubscribe was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Channels []string
	}{
		Ctx:      ctx,
		Channels: channels,
	}
	mock.lockPSubscribe.Lock()
	mock.calls.PSubscribe = append(mock.calls.PSubscribe, callInfo)
	mock.lockPSubscribe.Unlock()
	return mock.PSubscribeFunc(ctx, channels...)
}

// PSubscribeCalls gets all the calls that were made to PSubscribe.
// Check the length with:
//
//	len(mockedGoRedisClient.PSubscribeCalls())
func (mock *GoRedisClientMock) PSubscribeCalls() []struct {
	Ctx      context.Context
	Channels []string
} {
	var calls []struct {
		Ctx      context.Context
		Channels []string
	}
	mock.lockPSubscribe.RLock()
	calls = mock.calls.PSubscribe
	mock.lockPSubscribe.RUnlock()
	return calls
}

// PTTL calls PTTLFunc.
func (mock *GoRedisClientMock) PTTL(ctx context.Context, key string) *redis.DurationCmd {
	if mock.PTTLFunc == nil {
		panic("GoRedisClientMock.PTTLFunc: method is nil but GoRedisClient.PTTL was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockPTTL.Lock()
	mock.calls.PTTL = append(mock.calls.PTTL, callInfo)
	mock.lockPTTL.Unlock()
	return mock.PTTLFunc(ctx, key)
}

// PTTLCalls gets all the calls that were made to PTTL.
// Check the length with:
//
//	len(mockedGoRedisClient.PTTLCalls())
func (mock *GoRedisClientMock) PTTLCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockPTTL.RLock()
	calls = mock.calls.PTTL
	mock.lockPTTL.RUnlock()
	return calls
}

// Persist calls PersistFunc.
func (mock *GoRedisClientMock) Persist(ctx context.Context, key string) *redis.BoolCmd {
	if mock.PersistFunc == nil {
		panic("GoRedisClientMock.PersistFunc: method is nil but GoRedisClient.Persist was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockPersist.Lock()
	mock.calls.Persist = append(mock.calls.Persist, callInfo)
	mock.lockPersist.Unlock()
	return mock.PersistFunc(ctx, key)
}

// PersistCalls gets all the calls that were made to Persist.
// Check the length with:
//
//	len(mockedGoRedisClient.PersistCalls())
func (mock *GoRedisClientMock) PersistCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockPersist.RLock()
	calls = mock.calls.Persist
	mock.lockPersist.RUnlock()
	return calls
}

// Ping calls PingFunc.
func (mock *GoRedisClientMock) Ping(ctx context.Context) *redis.StatusCmd {
	if mock.PingFunc == nil {
		panic("GoRedisClientMock.PingFunc: method is nil but GoRedisClient.Ping was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockPing.Lock()
	mock.calls.Ping = append(mock.calls.Ping, callInfo)
	mock.lockPing.Unlock()
	return mock.PingFunc(ctx)
}

// PingCalls gets all the calls that were made to Ping.
// Check the length with:
//
//	len(mockedGoRedisClient.PingCalls())
func (mock *GoRedisClientMock) PingCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockPing.RLock()
	calls = mock.calls.Ping
	mock.lockPing.RUnlock()
	return calls
}

// Pipeline calls PipelineFunc.
func (mock *GoRedisClientMock) Pipeline() redis.Pipeliner {
	if mock.PipelineFunc == nil {
		panic("GoRedisClientMock.PipelineFunc: method is nil but GoRedisClient.Pipeline was just called")
	}
	callInfo := struct {
	}{}
	mock.lockPipeline.Lock()
	mock.calls.Pipeline = append(mock.calls.Pipeline, callInfo)
	mock.lockPipeline.Unlock()
	return mock.PipelineFunc()
}

// PipelineCalls gets all the calls that were made to Pipeline.
// Check the length with:
//
//	len(mockedGoRedisClient.PipelineCalls())
func (mock *GoRedisClientMock) PipelineCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockPipeline.RLock()
	calls = mock.calls.Pipeline
	mock.lockPipeline.RUnlock()
	return calls
}

// Pipelined calls PipelinedFunc.
func (mock *GoRedisClientMock) Pipelined(ctx context.Context, fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
	if mock.PipelinedFunc == nil {
		panic("GoRedisClientMock.PipelinedFunc: method is nil but GoRedisClient.Pipelined was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Fn  func(redis.Pipeliner) error
	}{
		Ctx: ctx,
		Fn:  fn,
	}
	mock.lockPipelined.Lock()
	mock.calls.Pipelined = append(mock.calls.Pipelined, callInfo)
	mock.lockPipelined.Unlock()
	return mock.PipelinedFunc(ctx, fn)
}

// PipelinedCalls gets all the calls that were made to Pipelined.
// Check the length with:
//
//	len(mockedGoRedisClient.PipelinedCalls())
func (mock *GoRedisClientMock) PipelinedCalls() []struct {
	Ctx context.Context
	Fn  func(redis.Pipeliner) error
} {
	var calls []struct {
		Ctx context.Context
		Fn  func(redis.Pipeliner) error
	}
	mock.lockPipelined.RLock()
	calls = mock.calls.Pipelined
	mock.lockPipelined.RUnlock()
	return calls
}

// PoolStats calls PoolStatsFunc.
func (mock *GoRedisClientMock) PoolStats() *redis.PoolStats {
	if mock.PoolStatsFunc == nil {
		panic("GoRedisClientMock.PoolStatsFunc: method is nil but GoRedisClient.PoolStats was just called")
	}
	callInfo := struct {
	}{}
	mock.lockPoolStats.Lock()
	mock.calls.PoolStats = append(mock.calls.PoolStats, callInfo)
	mock.lockPoolStats.Unlock()
	return mock.PoolStatsFunc()
}

// PoolStatsCalls gets all the calls that were made to PoolStats.
// Check the length with:
//
//	len(mockedGoRedisClient.PoolStatsCalls())
func (mock *GoRedisClientMock) PoolStatsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockPoolStats.RLock()
	calls = mock.calls.PoolStats
	mock.lockPoolStats.RUnlock()
	return calls
}

// Process calls ProcessFunc.
func (mock *GoRedisClientMock) Process(ctx context.Context, cmd redis.Cmder) error {
	if mock.ProcessFunc == nil {
		panic("GoRedisClientMock.ProcessFunc: method is nil but GoRedisClient.Process was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Cmd redis.Cmder
	}{
		Ctx: ctx,
		Cmd: cmd,
	}
	mock.lockProcess.Lock()
	mock.calls.Process = append(mock.calls.Process, callInfo)
	mock.lockProcess.Unlock()
	return mock.ProcessFunc(ctx, cmd)
}

// ProcessCalls gets all the calls that were made to Process.
// Check the length with:
//
//	len(mockedGoRedisClient.ProcessCalls())
func (mock *GoRedisClientMock) ProcessCalls() []struct {
	Ctx context.Context
	Cmd redis.Cmder
} {
	var calls []struct {
		Ctx context.Context
		Cmd redis.Cmder
	}
	mock.lockProcess.RLock()
	calls = mock.calls.Process
	mock.lockProcess.RUnlock()
	return calls
}

// PubSubChannels calls PubSubChannelsFunc.
func (mock *GoRedisClientMock) PubSubChannels(ctx context.Context, pattern string) *redis.StringSliceCmd {
	if mock.PubSubChannelsFunc == nil {
		panic("GoRedisClientMock.PubSubChannelsFunc: method is nil but GoRedisClient.PubSubChannels was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Pattern string
	}{
		Ctx:     ctx,
		Pattern: pattern,
	}
	mock.lockPubSubChannels.Lock()
	mock.calls.PubSubChannels = append(mock.calls.PubSubChannels, callInfo)
	mock.lockPubSubChannels.Unlock()
	return mock.PubSubChannelsFunc(ctx, pattern)
}

// PubSubChannelsCalls gets all the calls that were made to PubSubChannels.
// Check the length with:
//
//	len(mockedGoRedisClient.PubSubChannelsCalls())
func (mock *GoRedisClientMock) PubSubChannelsCalls() []struct {
	Ctx     context.Context
	Pattern string
} {
	var calls []struct {
		Ctx     context.Context
		Pattern string
	}
	mock.lockPubSubChannels.RLock()
	calls = mock.calls.PubSubChannels
	mock.lockPubSubChannels.RUnlock()
	return calls
}

// PubSubNumPat calls PubSubNumPatFunc.
func (mock *GoRedisClientMock) PubSubNumPat(ctx context.Context) *redis.IntCmd {
	if mock.PubSubNumPatFunc == nil {
		panic("GoRedisClientMock.PubSubNumPatFunc: method is nil but GoRedisClient.PubSubNumPat was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockPubSubNumPat.Lock()
	mock.calls.PubSubNumPat = append(mock.calls.PubSubNumPat, callInfo)
	mock.lockPubSubNumPat.Unlock()
	return mock.PubSubNumPatFunc(ctx)
}

// PubSubNumPatCalls gets all the calls that were made to PubSubNumPat.
// Check the length with:
//
//	len(mockedGoRedisClient.PubSubNumPatCalls())
func (mock *GoRedisClientMock) PubSubNumPatCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockPubSubNumPat.RLock()
	calls = mock.calls.PubSubNumPat
	mock.lockPubSubNumPat.RUnlock()
	return calls
}

// PubSubNumSub calls PubSubNumSubFunc.
func (mock *GoRedisClientMock) PubSubNumSub(ctx context.Context, channels ...string) *redis.MapStringIntCmd {
	if mock.PubSubNumSubFunc == nil {
		panic("GoRedisClientMock.PubSubNumSubFunc: method is nil but GoRedisClient.PubSubNumSub was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Channels []string
	}{
		Ctx:      ctx,
		Channels: channels,
	}
	mock.lockPubSubNumSub.Lock()
	mock.calls.PubSubNumSub = append(mock.calls.PubSubNumSub, callInfo)
	mock.lockPubSubNumSub.Unlock()
	return mock.PubSubNumSubFunc(ctx, channels...)
}

// PubSubNumSubCalls gets all the calls that were made to PubSubNumSub.
// Check the length with:
//
//	len(mockedGoRedisClient.PubSubNumSubCalls())
func (mock *GoRedisClientMock) PubSubNumSubCalls() []struct {
	Ctx      context.Context
	Channels []string
} {
	var calls []struct {
		Ctx      context.Context
		Channels []string
	}
	mock.lockPubSubNumSub.RLock()
	calls = mock.calls.PubSubNumSub
	mock.lockPubSubNumSub.RUnlock()
	return calls
}

// PubSubShardChannels calls PubSubShardChannelsFunc.
func (mock *GoRedisClientMock) PubSubShardChannels(ctx context.Context, pattern string) *redis.StringSliceCmd {
	if mock.PubSubShardChannelsFunc == nil {
		panic("GoRedisClientMock.PubSubShardChannelsFunc: method is nil but GoRedisClient.PubSubShardChannels was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Pattern string
	}{
		Ctx:     ctx,
		Pattern: pattern,
	}
	mock.lockPubSubShardChannels.Lock()
	mock.calls.PubSubShardChannels = append(mock.calls.PubSubShardChannels, callInfo)
	mock.lockPubSubShardChannels.Unlock()
	return mock.PubSubShardChannelsFunc(ctx, pattern)
}

// PubSubShardChannelsCalls gets all the calls that were made to PubSubShardChannels.
// Check the length with:
//
//	len(mockedGoRedisClient.PubSubShardChannelsCalls())
func (mock *GoRedisClientMock) PubSubShardChannelsCalls() []struct {
	Ctx     context.Context
	Pattern string
} {
	var calls []struct {
		Ctx     context.Context
		Pattern string
	}
	mock.lockPubSubShardChannels.RLock()
	calls = mock.calls.PubSubShardChannels
	mock.lockPubSubShardChannels.RUnlock()
	return calls
}

// PubSubShardNumSub calls PubSubShardNumSubFunc.
func (mock *GoRedisClientMock) PubSubShardNumSub(ctx context.Context, channels ...string) *redis.MapStringIntCmd {
	if mock.PubSubShardNumSubFunc == nil {
		panic("GoRedisClientMock.PubSubShardNumSubFunc: method is nil but GoRedisClient.PubSubShardNumSub was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Channels []string
	}{
		Ctx:      ctx,
		Channels: channels,
	}
	mock.lockPubSubShardNumSub.Lock()
	mock.calls.PubSubShardNumSub = append(mock.calls.PubSubShardNumSub, callInfo)
	mock.lockPubSubShardNumSub.Unlock()
	return mock.PubSubShardNumSubFunc(ctx, channels...)
}

// PubSubShardNumSubCalls gets all the calls that were made to PubSubShardNumSub.
// Check the length with:
//
//	len(mockedGoRedisClient.PubSubShardNumSubCalls())
func (mock *GoRedisClientMock) PubSubShardNumSubCalls() []struct {
	Ctx      context.Context
	Channels []string
} {
	var calls []struct {
		Ctx      context.Context
		Channels []string
	}
	mock.lockPubSubShardNumSub.RLock()
	calls = mock.calls.PubSubShardNumSub
	mock.lockPubSubShardNumSub.RUnlock()
	return calls
}

// Publish calls PublishFunc.
func (mock *GoRedisClientMock) Publish(ctx context.Context, channel string, message interface{}) *redis.IntCmd {
	if mock.PublishFunc == nil {
		panic("GoRedisClientMock.PublishFunc: method is nil but GoRedisClient.Publish was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Channel string
		Message interface{}
	}{
		Ctx:     ctx,
		Channel: channel,
		Message: message,
	}
	mock.lockPublish.Lock()
	mock.calls.Publish = append(mock.calls.Publish, callInfo)
	mock.lockPublish.Unlock()
	return mock.PublishFunc(ctx, channel, message)
}

// PublishCalls gets all the calls that were made to Publish.
// Check the length with:
//
//	len(mockedGoRedisClient.PublishCalls())
func (mock *GoRedisClientMock) PublishCalls() []struct {
	Ctx     context.Context
	Channel string
	Message interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Channel string
		Message interface{}
	}
	mock.lockPublish.RLock()
	calls = mock.calls.Publish
	mock.lockPublish.RUnlock()
	return calls
}

// Quit calls QuitFunc.
func (mock *GoRedisClientMock) Quit(ctx context.Context) *redis.StatusCmd {
	if mock.QuitFunc == nil {
		panic("GoRedisClientMock.QuitFunc: method is nil but GoRedisClient.Quit was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockQuit.Lock()
	mock.calls.Quit = append(mock.calls.Quit, callInfo)
	mock.lockQuit.Unlock()
	return mock.QuitFunc(ctx)
}

// QuitCalls gets all the calls that were made to Quit.
// Check the length with:
//
//	len(mockedGoRedisClient.QuitCalls())
func (mock *GoRedisClientMock) QuitCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockQuit.RLock()
	calls = mock.calls.Quit
	mock.lockQuit.RUnlock()
	return calls
}

// RPop calls RPopFunc.
func (mock *GoRedisClientMock) RPop(ctx context.Context, key string) *redis.StringCmd {
	if mock.RPopFunc == nil {
		panic("GoRedisClientMock.RPopFunc: method is nil but GoRedisClient.RPop was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockRPop.Lock()
	mock.calls.RPop = append(mock.calls.RPop, callInfo)
	mock.lockRPop.Unlock()
	return mock.RPopFunc(ctx, key)
}

// RPopCalls gets all the calls that were made to RPop.
// Check the length with:
//
//	len(mockedGoRedisClient.RPopCalls())
func (mock *GoRedisClientMock) RPopCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockRPop.RLock()
	calls = mock.calls.RPop
	mock.lockRPop.RUnlock()
	return calls
}

// RPopCount calls RPopCountFunc.
func (mock *GoRedisClientMock) RPopCount(ctx context.Context, key string, count int) *redis.StringSliceCmd {
	if mock.RPopCountFunc == nil {
		panic("GoRedisClientMock.RPopCountFunc: method is nil but GoRedisClient.RPopCount was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count int
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
	}
	mock.lockRPopCount.Lock()
	mock.calls.RPopCount = append(mock.calls.RPopCount, callInfo)
	mock.lockRPopCount.Unlock()
	return mock.RPopCountFunc(ctx, key, count)
}

// RPopCountCalls gets all the calls that were made to RPopCount.
// Check the length with:
//
//	len(mockedGoRedisClient.RPopCountCalls())
func (mock *GoRedisClientMock) RPopCountCalls() []struct {
	Ctx   context.Context
	Key   string
	Count int
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count int
	}
	mock.lockRPopCount.RLock()
	calls = mock.calls.RPopCount
	mock.lockRPopCount.RUnlock()
	return calls
}

// RPopLPush calls RPopLPushFunc.
func (mock *GoRedisClientMock) RPopLPush(ctx context.Context, source string, destination string) *redis.StringCmd {
	if mock.RPopLPushFunc == nil {
		panic("GoRedisClientMock.RPopLPushFunc: method is nil but GoRedisClient.RPopLPush was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Source      string
		Destination string
	}{
		Ctx:         ctx,
		Source:      source,
		Destination: destination,
	}
	mock.lockRPopLPush.Lock()
	mock.calls.RPopLPush = append(mock.calls.RPopLPush, callInfo)
	mock.lockRPopLPush.Unlock()
	return mock.RPopLPushFunc(ctx, source, destination)
}

// RPopLPushCalls gets all the calls that were made to RPopLPush.
// Check the length with:
//
//	len(mockedGoRedisClient.RPopLPushCalls())
func (mock *GoRedisClientMock) RPopLPushCalls() []struct {
	Ctx         context.Context
	Source      string
	Destination string
} {
	var calls []struct {
		Ctx         context.Context
		Source      string
		Destination string
	}
	mock.lockRPopLPush.RLock()
	calls = mock.calls.RPopLPush
	mock.lockRPopLPush.RUnlock()
	return calls
}

// RPush calls RPushFunc.
func (mock *GoRedisClientMock) RPush(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	if mock.RPushFunc == nil {
		panic("GoRedisClientMock.RPushFunc: method is nil but GoRedisClient.RPush was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}{
		Ctx:    ctx,
		Key:    key,
		Values: values,
	}
	mock.lockRPush.Lock()
	mock.calls.RPush = append(mock.calls.RPush, callInfo)
	mock.lockRPush.Unlock()
	return mock.RPushFunc(ctx, key, values...)
}

// RPushCalls gets all the calls that were made to RPush.
// Check the length with:
//
//	len(mockedGoRedisClient.RPushCalls())
func (mock *GoRedisClientMock) RPushCalls() []struct {
	Ctx    context.Context
	Key    string
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}
	mock.lockRPush.RLock()
	calls = mock.calls.RPush
	mock.lockRPush.RUnlock()
	return calls
}

// RPushX calls RPushXFunc.
func (mock *GoRedisClientMock) RPushX(ctx context.Context, key string, values ...interface{}) *redis.IntCmd {
	if mock.RPushXFunc == nil {
		panic("GoRedisClientMock.RPushXFunc: method is nil but GoRedisClient.RPushX was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}{
		Ctx:    ctx,
		Key:    key,
		Values: values,
	}
	mock.lockRPushX.Lock()
	mock.calls.RPushX = append(mock.calls.RPushX, callInfo)
	mock.lockRPushX.Unlock()
	return mock.RPushXFunc(ctx, key, values...)
}

// RPushXCalls gets all the calls that were made to RPushX.
// Check the length with:
//
//	len(mockedGoRedisClient.RPushXCalls())
func (mock *GoRedisClientMock) RPushXCalls() []struct {
	Ctx    context.Context
	Key    string
	Values []interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Values []interface{}
	}
	mock.lockRPushX.RLock()
	calls = mock.calls.RPushX
	mock.lockRPushX.RUnlock()
	return calls
}

// RandomKey calls RandomKeyFunc.
func (mock *GoRedisClientMock) RandomKey(ctx context.Context) *redis.StringCmd {
	if mock.RandomKeyFunc == nil {
		panic("GoRedisClientMock.RandomKeyFunc: method is nil but GoRedisClient.RandomKey was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockRandomKey.Lock()
	mock.calls.RandomKey = append(mock.calls.RandomKey, callInfo)
	mock.lockRandomKey.Unlock()
	return mock.RandomKeyFunc(ctx)
}

// RandomKeyCalls gets all the calls that were made to RandomKey.
// Check the length with:
//
//	len(mockedGoRedisClient.RandomKeyCalls())
func (mock *GoRedisClientMock) RandomKeyCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockRandomKey.RLock()
	calls = mock.calls.RandomKey
	mock.lockRandomKey.RUnlock()
	return calls
}

// ReadOnly calls ReadOnlyFunc.
func (mock *GoRedisClientMock) ReadOnly(ctx context.Context) *redis.StatusCmd {
	if mock.ReadOnlyFunc == nil {
		panic("GoRedisClientMock.ReadOnlyFunc: method is nil but GoRedisClient.ReadOnly was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockReadOnly.Lock()
	mock.calls.ReadOnly = append(mock.calls.ReadOnly, callInfo)
	mock.lockReadOnly.Unlock()
	return mock.ReadOnlyFunc(ctx)
}

// ReadOnlyCalls gets all the calls that were made to ReadOnly.
// Check the length with:
//
//	len(mockedGoRedisClient.ReadOnlyCalls())
func (mock *GoRedisClientMock) ReadOnlyCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockReadOnly.RLock()
	calls = mock.calls.ReadOnly
	mock.lockReadOnly.RUnlock()
	return calls
}

// ReadWrite calls ReadWriteFunc.
func (mock *GoRedisClientMock) ReadWrite(ctx context.Context) *redis.StatusCmd {
	if mock.ReadWriteFunc == nil {
		panic("GoRedisClientMock.ReadWriteFunc: method is nil but GoRedisClient.ReadWrite was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockReadWrite.Lock()
	mock.calls.ReadWrite = append(mock.calls.ReadWrite, callInfo)
	mock.lockReadWrite.Unlock()
	return mock.ReadWriteFunc(ctx)
}

// ReadWriteCalls gets all the calls that were made to ReadWrite.
// Check the length with:
//
//	len(mockedGoRedisClient.ReadWriteCalls())
func (mock *GoRedisClientMock) ReadWriteCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockReadWrite.RLock()
	calls = mock.calls.ReadWrite
	mock.lockReadWrite.RUnlock()
	return calls
}

// Rename calls RenameFunc.
func (mock *GoRedisClientMock) Rename(ctx context.Context, key string, newkey string) *redis.StatusCmd {
	if mock.RenameFunc == nil {
		panic("GoRedisClientMock.RenameFunc: method is nil but GoRedisClient.Rename was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Newkey string
	}{
		Ctx:    ctx,
		Key:    key,
		Newkey: newkey,
	}
	mock.lockRename.Lock()
	mock.calls.Rename = append(mock.calls.Rename, callInfo)
	mock.lockRename.Unlock()
	return mock.RenameFunc(ctx, key, newkey)
}

// RenameCalls gets all the calls that were made to Rename.
// Check the length with:
//
//	len(mockedGoRedisClient.RenameCalls())
func (mock *GoRedisClientMock) RenameCalls() []struct {
	Ctx    context.Context
	Key    string
	Newkey string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Newkey string
	}
	mock.lockRename.RLock()
	calls = mock.calls.Rename
	mock.lockRename.RUnlock()
	return calls
}

// RenameNX calls RenameNXFunc.
func (mock *GoRedisClientMock) RenameNX(ctx context.Context, key string, newkey string) *redis.BoolCmd {
	if mock.RenameNXFunc == nil {
		panic("GoRedisClientMock.RenameNXFunc: method is nil but GoRedisClient.RenameNX was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Newkey string
	}{
		Ctx:    ctx,
		Key:    key,
		Newkey: newkey,
	}
	mock.lockRenameNX.Lock()
	mock.calls.RenameNX = append(mock.calls.RenameNX, callInfo)
	mock.lockRenameNX.Unlock()
	return mock.RenameNXFunc(ctx, key, newkey)
}

// RenameNXCalls gets all the calls that were made to RenameNX.
// Check the length with:
//
//	len(mockedGoRedisClient.RenameNXCalls())
func (mock *GoRedisClientMock) RenameNXCalls() []struct {
	Ctx    context.Context
	Key    string
	Newkey string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Newkey string
	}
	mock.lockRenameNX.RLock()
	calls = mock.calls.RenameNX
	mock.lockRenameNX.RUnlock()
	return calls
}

// Restore calls RestoreFunc.
func (mock *GoRedisClientMock) Restore(ctx context.Context, key string, ttl time.Duration, value string) *redis.StatusCmd {
	if mock.RestoreFunc == nil {
		panic("GoRedisClientMock.RestoreFunc: method is nil but GoRedisClient.Restore was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		TTL   time.Duration
		Value string
	}{
		Ctx:   ctx,
		Key:   key,
		TTL:   ttl,
		Value: value,
	}
	mock.lockRestore.Lock()
	mock.calls.Restore = append(mock.calls.Restore, callInfo)
	mock.lockRestore.Unlock()
	return mock.RestoreFunc(ctx, key, ttl, value)
}

// RestoreCalls gets all the calls that were made to Restore.
// Check the length with:
//
//	len(mockedGoRedisClient.RestoreCalls())
func (mock *GoRedisClientMock) RestoreCalls() []struct {
	Ctx   context.Context
	Key   string
	TTL   time.Duration
	Value string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		TTL   time.Duration
		Value string
	}
	mock.lockRestore.RLock()
	calls = mock.calls.Restore
	mock.lockRestore.RUnlock()
	return calls
}

// RestoreReplace calls RestoreReplaceFunc.
func (mock *GoRedisClientMock) RestoreReplace(ctx context.Context, key string, ttl time.Duration, value string) *redis.StatusCmd {
	if mock.RestoreReplaceFunc == nil {
		panic("GoRedisClientMock.RestoreReplaceFunc: method is nil but GoRedisClient.RestoreReplace was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		TTL   time.Duration
		Value string
	}{
		Ctx:   ctx,
		Key:   key,
		TTL:   ttl,
		Value: value,
	}
	mock.lockRestoreReplace.Lock()
	mock.calls.RestoreReplace = append(mock.calls.RestoreReplace, callInfo)
	mock.lockRestoreReplace.Unlock()
	return mock.RestoreReplaceFunc(ctx, key, ttl, value)
}

// RestoreReplaceCalls gets all the calls that were made to RestoreReplace.
// Check the length with:
//
//	len(mockedGoRedisClient.RestoreReplaceCalls())
func (mock *GoRedisClientMock) RestoreReplaceCalls() []struct {
	Ctx   context.Context
	Key   string
	TTL   time.Duration
	Value string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		TTL   time.Duration
		Value string
	}
	mock.lockRestoreReplace.RLock()
	calls = mock.calls.RestoreReplace
	mock.lockRestoreReplace.RUnlock()
	return calls
}

// SAdd calls SAddFunc.
func (mock *GoRedisClientMock) SAdd(ctx context.Context, key string, members ...interface{}) *redis.IntCmd {
	if mock.SAddFunc == nil {
		panic("GoRedisClientMock.SAddFunc: method is nil but GoRedisClient.SAdd was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockSAdd.Lock()
	mock.calls.SAdd = append(mock.calls.SAdd, callInfo)
	mock.lockSAdd.Unlock()
	return mock.SAddFunc(ctx, key, members...)
}

// SAddCalls gets all the calls that were made to SAdd.
// Check the length with:
//
//	len(mockedGoRedisClient.SAddCalls())
func (mock *GoRedisClientMock) SAddCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []interface{}
	}
	mock.lockSAdd.RLock()
	calls = mock.calls.SAdd
	mock.lockSAdd.RUnlock()
	return calls
}

// SCard calls SCardFunc.
func (mock *GoRedisClientMock) SCard(ctx context.Context, key string) *redis.IntCmd {
	if mock.SCardFunc == nil {
		panic("GoRedisClientMock.SCardFunc: method is nil but GoRedisClient.SCard was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockSCard.Lock()
	mock.calls.SCard = append(mock.calls.SCard, callInfo)
	mock.lockSCard.Unlock()
	return mock.SCardFunc(ctx, key)
}

// SCardCalls gets all the calls that were made to SCard.
// Check the length with:
//
//	len(mockedGoRedisClient.SCardCalls())
func (mock *GoRedisClientMock) SCardCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockSCard.RLock()
	calls = mock.calls.SCard
	mock.lockSCard.RUnlock()
	return calls
}

// SDiff calls SDiffFunc.
func (mock *GoRedisClientMock) SDiff(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	if mock.SDiffFunc == nil {
		panic("GoRedisClientMock.SDiffFunc: method is nil but GoRedisClient.SDiff was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockSDiff.Lock()
	mock.calls.SDiff = append(mock.calls.SDiff, callInfo)
	mock.lockSDiff.Unlock()
	return mock.SDiffFunc(ctx, keys...)
}

// SDiffCalls gets all the calls that were made to SDiff.
// Check the length with:
//
//	len(mockedGoRedisClient.SDiffCalls())
func (mock *GoRedisClientMock) SDiffCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockSDiff.RLock()
	calls = mock.calls.SDiff
	mock.lockSDiff.RUnlock()
	return calls
}

// SDiffStore calls SDiffStoreFunc.
func (mock *GoRedisClientMock) SDiffStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	if mock.SDiffStoreFunc == nil {
		panic("GoRedisClientMock.SDiffStoreFunc: method is nil but GoRedisClient.SDiffStore was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Destination string
		Keys        []string
	}{
		Ctx:         ctx,
		Destination: destination,
		Keys:        keys,
	}
	mock.lockSDiffStore.Lock()
	mock.calls.SDiffStore = append(mock.calls.SDiffStore, callInfo)
	mock.lockSDiffStore.Unlock()
	return mock.SDiffStoreFunc(ctx, destination, keys...)
}

// SDiffStoreCalls gets all the calls that were made to SDiffStore.
// Check the length with:
//
//	len(mockedGoRedisClient.SDiffStoreCalls())
func (mock *GoRedisClientMock) SDiffStoreCalls() []struct {
	Ctx         context.Context
	Destination string
	Keys        []string
} {
	var calls []struct {
		Ctx         context.Context
		Destination string
		Keys        []string
	}
	mock.lockSDiffStore.RLock()
	calls = mock.calls.SDiffStore
	mock.lockSDiffStore.RUnlock()
	return calls
}

// SInter calls SInterFunc.
func (mock *GoRedisClientMock) SInter(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	if mock.SInterFunc == nil {
		panic("GoRedisClientMock.SInterFunc: method is nil but GoRedisClient.SInter was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockSInter.Lock()
	mock.calls.SInter = append(mock.calls.SInter, callInfo)
	mock.lockSInter.Unlock()
	return mock.SInterFunc(ctx, keys...)
}

// SInterCalls gets all the calls that were made to SInter.
// Check the length with:
//
//	len(mockedGoRedisClient.SInterCalls())
func (mock *GoRedisClientMock) SInterCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockSInter.RLock()
	calls = mock.calls.SInter
	mock.lockSInter.RUnlock()
	return calls
}

// SInterCard calls SInterCardFunc.
func (mock *GoRedisClientMock) SInterCard(ctx context.Context, limit int64, keys ...string) *redis.IntCmd {
	if mock.SInterCardFunc == nil {
		panic("GoRedisClientMock.SInterCardFunc: method is nil but GoRedisClient.SInterCard was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Limit int64
		Keys  []string
	}{
		Ctx:   ctx,
		Limit: limit,
		Keys:  keys,
	}
	mock.lockSInterCard.Lock()
	mock.calls.SInterCard = append(mock.calls.SInterCard, callInfo)
	mock.lockSInterCard.Unlock()
	return mock.SInterCardFunc(ctx, limit, keys...)
}

// SInterCardCalls gets all the calls that were made to SInterCard.
// Check the length with:
//
//	len(mockedGoRedisClient.SInterCardCalls())
func (mock *GoRedisClientMock) SInterCardCalls() []struct {
	Ctx   context.Context
	Limit int64
	Keys  []string
} {
	var calls []struct {
		Ctx   context.Context
		Limit int64
		Keys  []string
	}
	mock.lockSInterCard.RLock()
	calls = mock.calls.SInterCard
	mock.lockSInterCard.RUnlock()
	return calls
}

// SInterStore calls SInterStoreFunc.
func (mock *GoRedisClientMock) SInterStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	if mock.SInterStoreFunc == nil {
		panic("GoRedisClientMock.SInterStoreFunc: method is nil but GoRedisClient.SInterStore was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Destination string
		Keys        []string
	}{
		Ctx:         ctx,
		Destination: destination,
		Keys:        keys,
	}
	mock.lockSInterStore.Lock()
	mock.calls.SInterStore = append(mock.calls.SInterStore, callInfo)
	mock.lockSInterStore.Unlock()
	return mock.SInterStoreFunc(ctx, destination, keys...)
}

// SInterStoreCalls gets all the calls that were made to SInterStore.
// Check the length with:
//
//	len(mockedGoRedisClient.SInterStoreCalls())
func (mock *GoRedisClientMock) SInterStoreCalls() []struct {
	Ctx         context.Context
	Destination string
	Keys        []string
} {
	var calls []struct {
		Ctx         context.Context
		Destination string
		Keys        []string
	}
	mock.lockSInterStore.RLock()
	calls = mock.calls.SInterStore
	mock.lockSInterStore.RUnlock()
	return calls
}

// SIsMember calls SIsMemberFunc.
func (mock *GoRedisClientMock) SIsMember(ctx context.Context, key string, member interface{}) *redis.BoolCmd {
	if mock.SIsMemberFunc == nil {
		panic("GoRedisClientMock.SIsMemberFunc: method is nil but GoRedisClient.SIsMember was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Member interface{}
	}{
		Ctx:    ctx,
		Key:    key,
		Member: member,
	}
	mock.lockSIsMember.Lock()
	mock.calls.SIsMember = append(mock.calls.SIsMember, callInfo)
	mock.lockSIsMember.Unlock()
	return mock.SIsMemberFunc(ctx, key, member)
}

// SIsMemberCalls gets all the calls that were made to SIsMember.
// Check the length with:
//
//	len(mockedGoRedisClient.SIsMemberCalls())
func (mock *GoRedisClientMock) SIsMemberCalls() []struct {
	Ctx    context.Context
	Key    string
	Member interface{}
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Member interface{}
	}
	mock.lockSIsMember.RLock()
	calls = mock.calls.SIsMember
	mock.lockSIsMember.RUnlock()
	return calls
}

// SMIsMember calls SMIsMemberFunc.
func (mock *GoRedisClientMock) SMIsMember(ctx context.Context, key string, members ...interface{}) *redis.BoolSliceCmd {
	if mock.SMIsMemberFunc == nil {
		panic("GoRedisClientMock.SMIsMemberFunc: method is nil but GoRedisClient.SMIsMember was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockSMIsMember.Lock()
	mock.calls.SMIsMember = append(mock.calls.SMIsMember, callInfo)
	mock.lockSMIsMember.Unlock()
	return mock.SMIsMemberFunc(ctx, key, members...)
}

// SMIsMemberCalls gets all the calls that were made to SMIsMember.
// Check the length with:
//
//	len(mockedGoRedisClient.SMIsMemberCalls())
func (mock *GoRedisClientMock) SMIsMemberCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []interface{}
	}
	mock.lockSMIsMember.RLock()
	calls = mock.calls.SMIsMember
	mock.lockSMIsMember.RUnlock()
	return calls
}

// SMembers calls SMembersFunc.
func (mock *GoRedisClientMock) SMembers(ctx context.Context, key string) *redis.StringSliceCmd {
	if mock.SMembersFunc == nil {
		panic("GoRedisClientMock.SMembersFunc: method is nil but GoRedisClient.SMembers was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockSMembers.Lock()
	mock.calls.SMembers = append(mock.calls.SMembers, callInfo)
	mock.lockSMembers.Unlock()
	return mock.SMembersFunc(ctx, key)
}

// SMembersCalls gets all the calls that were made to SMembers.
// Check the length with:
//
//	len(mockedGoRedisClient.SMembersCalls())
func (mock *GoRedisClientMock) SMembersCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockSMembers.RLock()
	calls = mock.calls.SMembers
	mock.lockSMembers.RUnlock()
	return calls
}

// SMembersMap calls SMembersMapFunc.
func (mock *GoRedisClientMock) SMembersMap(ctx context.Context, key string) *redis.StringStructMapCmd {
	if mock.SMembersMapFunc == nil {
		panic("GoRedisClientMock.SMembersMapFunc: method is nil but GoRedisClient.SMembersMap was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockSMembersMap.Lock()
	mock.calls.SMembersMap = append(mock.calls.SMembersMap, callInfo)
	mock.lockSMembersMap.Unlock()
	return mock.SMembersMapFunc(ctx, key)
}

// SMembersMapCalls gets all the calls that were made to SMembersMap.
// Check the length with:
//
//	len(mockedGoRedisClient.SMembersMapCalls())
func (mock *GoRedisClientMock) SMembersMapCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockSMembersMap.RLock()
	calls = mock.calls.SMembersMap
	mock.lockSMembersMap.RUnlock()
	return calls
}

// SMove calls SMoveFunc.
func (mock *GoRedisClientMock) SMove(ctx context.Context, source string, destination string, member interface{}) *redis.BoolCmd {
	if mock.SMoveFunc == nil {
		panic("GoRedisClientMock.SMoveFunc: method is nil but GoRedisClient.SMove was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Source      string
		Destination string
		Member      interface{}
	}{
		Ctx:         ctx,
		Source:      source,
		Destination: destination,
		Member:      member,
	}
	mock.lockSMove.Lock()
	mock.calls.SMove = append(mock.calls.SMove, callInfo)
	mock.lockSMove.Unlock()
	return mock.SMoveFunc(ctx, source, destination, member)
}

// SMoveCalls gets all the calls that were made to SMove.
// Check the length with:
//
//	len(mockedGoRedisClient.SMoveCalls())
func (mock *GoRedisClientMock) SMoveCalls() []struct {
	Ctx         context.Context
	Source      string
	Destination string
	Member      interface{}
} {
	var calls []struct {
		Ctx         context.Context
		Source      string
		Destination string
		Member      interface{}
	}
	mock.lockSMove.RLock()
	calls = mock.calls.SMove
	mock.lockSMove.RUnlock()
	return calls
}

// SPop calls SPopFunc.
func (mock *GoRedisClientMock) SPop(ctx context.Context, key string) *redis.StringCmd {
	if mock.SPopFunc == nil {
		panic("GoRedisClientMock.SPopFunc: method is nil but GoRedisClient.SPop was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockSPop.Lock()
	mock.calls.SPop = append(mock.calls.SPop, callInfo)
	mock.lockSPop.Unlock()
	return mock.SPopFunc(ctx, key)
}

// SPopCalls gets all the calls that were made to SPop.
// Check the length with:
//
//	len(mockedGoRedisClient.SPopCalls())
func (mock *GoRedisClientMock) SPopCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockSPop.RLock()
	calls = mock.calls.SPop
	mock.lockSPop.RUnlock()
	return calls
}

// SPopN calls SPopNFunc.
func (mock *GoRedisClientMock) SPopN(ctx context.Context, key string, count int64) *redis.StringSliceCmd {
	if mock.SPopNFunc == nil {
		panic("GoRedisClientMock.SPopNFunc: method is nil but GoRedisClient.SPopN was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count int64
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
	}
	mock.lockSPopN.Lock()
	mock.calls.SPopN = append(mock.calls.SPopN, callInfo)
	mock.lockSPopN.Unlock()
	return mock.SPopNFunc(ctx, key, count)
}

// SPopNCalls gets all the calls that were made to SPopN.
// Check the length with:
//
//	len(mockedGoRedisClient.SPopNCalls())
func (mock *GoRedisClientMock) SPopNCalls() []struct {
	Ctx   context.Context
	Key   string
	Count int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count int64
	}
	mock.lockSPopN.RLock()
	calls = mock.calls.SPopN
	mock.lockSPopN.RUnlock()
	return calls
}

// SPublish calls SPublishFunc.
func (mock *GoRedisClientMock) SPublish(ctx context.Context, channel string, message interface{}) *redis.IntCmd {
	if mock.SPublishFunc == nil {
		panic("GoRedisClientMock.SPublishFunc: method is nil but GoRedisClient.SPublish was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Channel string
		Message interface{}
	}{
		Ctx:     ctx,
		Channel: channel,
		Message: message,
	}
	mock.lockSPublish.Lock()
	mock.calls.SPublish = append(mock.calls.SPublish, callInfo)
	mock.lockSPublish.Unlock()
	return mock.SPublishFunc(ctx, channel, message)
}

// SPublishCalls gets all the calls that were made to SPublish.
// Check the length with:
//
//	len(mockedGoRedisClient.SPublishCalls())
func (mock *GoRedisClientMock) SPublishCalls() []struct {
	Ctx     context.Context
	Channel string
	Message interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Channel string
		Message interface{}
	}
	mock.lockSPublish.RLock()
	calls = mock.calls.SPublish
	mock.lockSPublish.RUnlock()
	return calls
}

// SRandMember calls SRandMemberFunc.
func (mock *GoRedisClientMock) SRandMember(ctx context.Context, key string) *redis.StringCmd {
	if mock.SRandMemberFunc == nil {
		panic("GoRedisClientMock.SRandMemberFunc: method is nil but GoRedisClient.SRandMember was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockSRandMember.Lock()
	mock.calls.SRandMember = append(mock.calls.SRandMember, callInfo)
	mock.lockSRandMember.Unlock()
	return mock.SRandMemberFunc(ctx, key)
}

// SRandMemberCalls gets all the calls that were made to SRandMember.
// Check the length with:
//
//	len(mockedGoRedisClient.SRandMemberCalls())
func (mock *GoRedisClientMock) SRandMemberCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockSRandMember.RLock()
	calls = mock.calls.SRandMember
	mock.lockSRandMember.RUnlock()
	return calls
}

// SRandMemberN calls SRandMemberNFunc.
func (mock *GoRedisClientMock) SRandMemberN(ctx context.Context, key string, count int64) *redis.StringSliceCmd {
	if mock.SRandMemberNFunc == nil {
		panic("GoRedisClientMock.SRandMemberNFunc: method is nil but GoRedisClient.SRandMemberN was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count int64
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
	}
	mock.lockSRandMemberN.Lock()
	mock.calls.SRandMemberN = append(mock.calls.SRandMemberN, callInfo)
	mock.lockSRandMemberN.Unlock()
	return mock.SRandMemberNFunc(ctx, key, count)
}

// SRandMemberNCalls gets all the calls that were made to SRandMemberN.
// Check the length with:
//
//	len(mockedGoRedisClient.SRandMemberNCalls())
func (mock *GoRedisClientMock) SRandMemberNCalls() []struct {
	Ctx   context.Context
	Key   string
	Count int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count int64
	}
	mock.lockSRandMemberN.RLock()
	calls = mock.calls.SRandMemberN
	mock.lockSRandMemberN.RUnlock()
	return calls
}

// SRem calls SRemFunc.
func (mock *GoRedisClientMock) SRem(ctx context.Context, key string, members ...interface{}) *redis.IntCmd {
	if mock.SRemFunc == nil {
		panic("GoRedisClientMock.SRemFunc: method is nil but GoRedisClient.SRem was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockSRem.Lock()
	mock.calls.SRem = append(mock.calls.SRem, callInfo)
	mock.lockSRem.Unlock()
	return mock.SRemFunc(ctx, key, members...)
}

// SRemCalls gets all the calls that were made to SRem.
// Check the length with:
//
//	len(mockedGoRedisClient.SRemCalls())
func (mock *GoRedisClientMock) SRemCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []interface{}
	}
	mock.lockSRem.RLock()
	calls = mock.calls.SRem
	mock.lockSRem.RUnlock()
	return calls
}

// SScan calls SScanFunc.
func (mock *GoRedisClientMock) SScan(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	if mock.SScanFunc == nil {
		panic("GoRedisClientMock.SScanFunc: method is nil but GoRedisClient.SScan was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Cursor uint64
		Match  string
		Count  int64
	}{
		Ctx:    ctx,
		Key:    key,
		Cursor: cursor,
		Match:  match,
		Count:  count,
	}
	mock.lockSScan.Lock()
	mock.calls.SScan = append(mock.calls.SScan, callInfo)
	mock.lockSScan.Unlock()
	return mock.SScanFunc(ctx, key, cursor, match, count)
}

// SScanCalls gets all the calls that were made to SScan.
// Check the length with:
//
//	len(mockedGoRedisClient.SScanCalls())
func (mock *GoRedisClientMock) SScanCalls() []struct {
	Ctx    context.Context
	Key    string
	Cursor uint64
	Match  string
	Count  int64
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Cursor uint64
		Match  string
		Count  int64
	}
	mock.lockSScan.RLock()
	calls = mock.calls.SScan
	mock.lockSScan.RUnlock()
	return calls
}

// SSubscribe calls SSubscribeFunc.
func (mock *GoRedisClientMock) SSubscribe(ctx context.Context, channels ...string) *redis.PubSub {
	if mock.SSubscribeFunc == nil {
		panic("GoRedisClientMock.SSubscribeFunc: method is nil but GoRedisClient.SSubscribe was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Channels []string
	}{
		Ctx:      ctx,
		Channels: channels,
	}
	mock.lockSSubscribe.Lock()
	mock.calls.SSubscribe = append(mock.calls.SSubscribe, callInfo)
	mock.lockSSubscribe.Unlock()
	return mock.SSubscribeFunc(ctx, channels...)
}

// SSubscribeCalls gets all the calls that were made to SSubscribe.
// Check the length with:
//
//	len(mockedGoRedisClient.SSubscribeCalls())
func (mock *GoRedisClientMock) SSubscribeCalls() []struct {
	Ctx      context.Context
	Channels []string
} {
	var calls []struct {
		Ctx      context.Context
		Channels []string
	}
	mock.lockSSubscribe.RLock()
	calls = mock.calls.SSubscribe
	mock.lockSSubscribe.RUnlock()
	return calls
}

// SUnion calls SUnionFunc.
func (mock *GoRedisClientMock) SUnion(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	if mock.SUnionFunc == nil {
		panic("GoRedisClientMock.SUnionFunc: method is nil but GoRedisClient.SUnion was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockSUnion.Lock()
	mock.calls.SUnion = append(mock.calls.SUnion, callInfo)
	mock.lockSUnion.Unlock()
	return mock.SUnionFunc(ctx, keys...)
}

// SUnionCalls gets all the calls that were made to SUnion.
// Check the length with:
//
//	len(mockedGoRedisClient.SUnionCalls())
func (mock *GoRedisClientMock) SUnionCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockSUnion.RLock()
	calls = mock.calls.SUnion
	mock.lockSUnion.RUnlock()
	return calls
}

// SUnionStore calls SUnionStoreFunc.
func (mock *GoRedisClientMock) SUnionStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	if mock.SUnionStoreFunc == nil {
		panic("GoRedisClientMock.SUnionStoreFunc: method is nil but GoRedisClient.SUnionStore was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Destination string
		Keys        []string
	}{
		Ctx:         ctx,
		Destination: destination,
		Keys:        keys,
	}
	mock.lockSUnionStore.Lock()
	mock.calls.SUnionStore = append(mock.calls.SUnionStore, callInfo)
	mock.lockSUnionStore.Unlock()
	return mock.SUnionStoreFunc(ctx, destination, keys...)
}

// SUnionStoreCalls gets all the calls that were made to SUnionStore.
// Check the length with:
//
//	len(mockedGoRedisClient.SUnionStoreCalls())
func (mock *GoRedisClientMock) SUnionStoreCalls() []struct {
	Ctx         context.Context
	Destination string
	Keys        []string
} {
	var calls []struct {
		Ctx         context.Context
		Destination string
		Keys        []string
	}
	mock.lockSUnionStore.RLock()
	calls = mock.calls.SUnionStore
	mock.lockSUnionStore.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *GoRedisClientMock) Save(ctx context.Context) *redis.StatusCmd {
	if mock.SaveFunc == nil {
		panic("GoRedisClientMock.SaveFunc: method is nil but GoRedisClient.Save was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedGoRedisClient.SaveCalls())
func (mock *GoRedisClientMock) SaveCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// Scan calls ScanFunc.
func (mock *GoRedisClientMock) Scan(ctx context.Context, cursor uint64, match string, count int64) *redis.ScanCmd {
	if mock.ScanFunc == nil {
		panic("GoRedisClientMock.ScanFunc: method is nil but GoRedisClient.Scan was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Cursor uint64
		Match  string
		Count  int64
	}{
		Ctx:    ctx,
		Cursor: cursor,
		Match:  match,
		Count:  count,
	}
	mock.lockScan.Lock()
	mock.calls.Scan = append(mock.calls.Scan, callInfo)
	mock.lockScan.Unlock()
	return mock.ScanFunc(ctx, cursor, match, count)
}

// ScanCalls gets all the calls that were made to Scan.
// Check the length with:
//
//	len(mockedGoRedisClient.ScanCalls())
func (mock *GoRedisClientMock) ScanCalls() []struct {
	Ctx    context.Context
	Cursor uint64
	Match  string
	Count  int64
} {
	var calls []struct {
		Ctx    context.Context
		Cursor uint64
		Match  string
		Count  int64
	}
	mock.lockScan.RLock()
	calls = mock.calls.Scan
	mock.lockScan.RUnlock()
	return calls
}

// ScanType calls ScanTypeFunc.
func (mock *GoRedisClientMock) ScanType(ctx context.Context, cursor uint64, match string, count int64, keyType string) *redis.ScanCmd {
	if mock.ScanTypeFunc == nil {
		panic("GoRedisClientMock.ScanTypeFunc: method is nil but GoRedisClient.ScanType was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Cursor  uint64
		Match   string
		Count   int64
		KeyType string
	}{
		Ctx:     ctx,
		Cursor:  cursor,
		Match:   match,
		Count:   count,
		KeyType: keyType,
	}
	mock.lockScanType.Lock()
	mock.calls.ScanType = append(mock.calls.ScanType, callInfo)
	mock.lockScanType.Unlock()
	return mock.ScanTypeFunc(ctx, cursor, match, count, keyType)
}

// ScanTypeCalls gets all the calls that were made to ScanType.
// Check the length with:
//
//	len(mockedGoRedisClient.ScanTypeCalls())
func (mock *GoRedisClientMock) ScanTypeCalls() []struct {
	Ctx     context.Context
	Cursor  uint64
	Match   string
	Count   int64
	KeyType string
} {
	var calls []struct {
		Ctx     context.Context
		Cursor  uint64
		Match   string
		Count   int64
		KeyType string
	}
	mock.lockScanType.RLock()
	calls = mock.calls.ScanType
	mock.lockScanType.RUnlock()
	return calls
}

// ScriptExists calls ScriptExistsFunc.
func (mock *GoRedisClientMock) ScriptExists(ctx context.Context, hashes ...string) *redis.BoolSliceCmd {
	if mock.ScriptExistsFunc == nil {
		panic("GoRedisClientMock.ScriptExistsFunc: method is nil but GoRedisClient.ScriptExists was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Hashes []string
	}{
		Ctx:    ctx,
		Hashes: hashes,
	}
	mock.lockScriptExists.Lock()
	mock.calls.ScriptExists = append(mock.calls.ScriptExists, callInfo)
	mock.lockScriptExists.Unlock()
	return mock.ScriptExistsFunc(ctx, hashes...)
}

// ScriptExistsCalls gets all the calls that were made to ScriptExists.
// Check the length with:
//
//	len(mockedGoRedisClient.ScriptExistsCalls())
func (mock *GoRedisClientMock) ScriptExistsCalls() []struct {
	Ctx    context.Context
	Hashes []string
} {
	var calls []struct {
		Ctx    context.Context
		Hashes []string
	}
	mock.lockScriptExists.RLock()
	calls = mock.calls.ScriptExists
	mock.lockScriptExists.RUnlock()
	return calls
}

// ScriptFlush calls ScriptFlushFunc.
func (mock *GoRedisClientMock) ScriptFlush(ctx context.Context) *redis.StatusCmd {
	if mock.ScriptFlushFunc == nil {
		panic("GoRedisClientMock.ScriptFlushFunc: method is nil but GoRedisClient.ScriptFlush was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockScriptFlush.Lock()
	mock.calls.ScriptFlush = append(mock.calls.ScriptFlush, callInfo)
	mock.lockScriptFlush.Unlock()
	return mock.ScriptFlushFunc(ctx)
}

// ScriptFlushCalls gets all the calls that were made to ScriptFlush.
// Check the length with:
//
//	len(mockedGoRedisClient.ScriptFlushCalls())
func (mock *GoRedisClientMock) ScriptFlushCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockScriptFlush.RLock()
	calls = mock.calls.ScriptFlush
	mock.lockScriptFlush.RUnlock()
	return calls
}

// ScriptKill calls ScriptKillFunc.
func (mock *GoRedisClientMock) ScriptKill(ctx context.Context) *redis.StatusCmd {
	if mock.ScriptKillFunc == nil {
		panic("GoRedisClientMock.ScriptKillFunc: method is nil but GoRedisClient.ScriptKill was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockScriptKill.Lock()
	mock.calls.ScriptKill = append(mock.calls.ScriptKill, callInfo)
	mock.lockScriptKill.Unlock()
	return mock.ScriptKillFunc(ctx)
}

// ScriptKillCalls gets all the calls that were made to ScriptKill.
// Check the length with:
//
//	len(mockedGoRedisClient.ScriptKillCalls())
func (mock *GoRedisClientMock) ScriptKillCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockScriptKill.RLock()
	calls = mock.calls.ScriptKill
	mock.lockScriptKill.RUnlock()
	return calls
}

// ScriptLoad calls ScriptLoadFunc.
func (mock *GoRedisClientMock) ScriptLoad(ctx context.Context, script string) *redis.StringCmd {
	if mock.ScriptLoadFunc == nil {
		panic("GoRedisClientMock.ScriptLoadFunc: method is nil but GoRedisClient.ScriptLoad was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Script string
	}{
		Ctx:    ctx,
		Script: script,
	}
	mock.lockScriptLoad.Lock()
	mock.calls.ScriptLoad = append(mock.calls.ScriptLoad, callInfo)
	mock.lockScriptLoad.Unlock()
	return mock.ScriptLoadFunc(ctx, script)
}

// ScriptLoadCalls gets all the calls that were made to ScriptLoad.
// Check the length with:
//
//	len(mockedGoRedisClient.ScriptLoadCalls())
func (mock *GoRedisClientMock) ScriptLoadCalls() []struct {
	Ctx    context.Context
	Script string
} {
	var calls []struct {
		Ctx    context.Context
		Script string
	}
	mock.lockScriptLoad.RLock()
	calls = mock.calls.ScriptLoad
	mock.lockScriptLoad.RUnlock()
	return calls
}

// Set calls SetFunc.
func (mock *GoRedisClientMock) Set(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.StatusCmd {
	if mock.SetFunc == nil {
		panic("GoRedisClientMock.SetFunc: method is nil but GoRedisClient.Set was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Value:      value,
		Expiration: expiration,
	}
	mock.lockSet.Lock()
	mock.calls.Set = append(mock.calls.Set, callInfo)
	mock.lockSet.Unlock()
	return mock.SetFunc(ctx, key, value, expiration)
}

// SetCalls gets all the calls that were made to Set.
// Check the length with:
//
//	len(mockedGoRedisClient.SetCalls())
func (mock *GoRedisClientMock) SetCalls() []struct {
	Ctx        context.Context
	Key        string
	Value      interface{}
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		Expiration time.Duration
	}
	mock.lockSet.RLock()
	calls = mock.calls.Set
	mock.lockSet.RUnlock()
	return calls
}

// SetArgs calls SetArgsFunc.
func (mock *GoRedisClientMock) SetArgs(ctx context.Context, key string, value interface{}, a redis.SetArgs) *redis.StatusCmd {
	if mock.SetArgsFunc == nil {
		panic("GoRedisClientMock.SetArgsFunc: method is nil but GoRedisClient.SetArgs was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Value interface{}
		A     redis.SetArgs
	}{
		Ctx:   ctx,
		Key:   key,
		Value: value,
		A:     a,
	}
	mock.lockSetArgs.Lock()
	mock.calls.SetArgs = append(mock.calls.SetArgs, callInfo)
	mock.lockSetArgs.Unlock()
	return mock.SetArgsFunc(ctx, key, value, a)
}

// SetArgsCalls gets all the calls that were made to SetArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.SetArgsCalls())
func (mock *GoRedisClientMock) SetArgsCalls() []struct {
	Ctx   context.Context
	Key   string
	Value interface{}
	A     redis.SetArgs
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Value interface{}
		A     redis.SetArgs
	}
	mock.lockSetArgs.RLock()
	calls = mock.calls.SetArgs
	mock.lockSetArgs.RUnlock()
	return calls
}

// SetBit calls SetBitFunc.
func (mock *GoRedisClientMock) SetBit(ctx context.Context, key string, offset int64, value int) *redis.IntCmd {
	if mock.SetBitFunc == nil {
		panic("GoRedisClientMock.SetBitFunc: method is nil but GoRedisClient.SetBit was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Offset int64
		Value  int
	}{
		Ctx:    ctx,
		Key:    key,
		Offset: offset,
		Value:  value,
	}
	mock.lockSetBit.Lock()
	mock.calls.SetBit = append(mock.calls.SetBit, callInfo)
	mock.lockSetBit.Unlock()
	return mock.SetBitFunc(ctx, key, offset, value)
}

// SetBitCalls gets all the calls that were made to SetBit.
// Check the length with:
//
//	len(mockedGoRedisClient.SetBitCalls())
func (mock *GoRedisClientMock) SetBitCalls() []struct {
	Ctx    context.Context
	Key    string
	Offset int64
	Value  int
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Offset int64
		Value  int
	}
	mock.lockSetBit.RLock()
	calls = mock.calls.SetBit
	mock.lockSetBit.RUnlock()
	return calls
}

// SetEx calls SetExFunc.
func (mock *GoRedisClientMock) SetEx(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.StatusCmd {
	if mock.SetExFunc == nil {
		panic("GoRedisClientMock.SetExFunc: method is nil but GoRedisClient.SetEx was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Value:      value,
		Expiration: expiration,
	}
	mock.lockSetEx.Lock()
	mock.calls.SetEx = append(mock.calls.SetEx, callInfo)
	mock.lockSetEx.Unlock()
	return mock.SetExFunc(ctx, key, value, expiration)
}

// SetExCalls gets all the calls that were made to SetEx.
// Check the length with:
//
//	len(mockedGoRedisClient.SetExCalls())
func (mock *GoRedisClientMock) SetExCalls() []struct {
	Ctx        context.Context
	Key        string
	Value      interface{}
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		Expiration time.Duration
	}
	mock.lockSetEx.RLock()
	calls = mock.calls.SetEx
	mock.lockSetEx.RUnlock()
	return calls
}

// SetNX calls SetNXFunc.
func (mock *GoRedisClientMock) SetNX(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.BoolCmd {
	if mock.SetNXFunc == nil {
		panic("GoRedisClientMock.SetNXFunc: method is nil but GoRedisClient.SetNX was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Value:      value,
		Expiration: expiration,
	}
	mock.lockSetNX.Lock()
	mock.calls.SetNX = append(mock.calls.SetNX, callInfo)
	mock.lockSetNX.Unlock()
	return mock.SetNXFunc(ctx, key, value, expiration)
}

// SetNXCalls gets all the calls that were made to SetNX.
// Check the length with:
//
//	len(mockedGoRedisClient.SetNXCalls())
func (mock *GoRedisClientMock) SetNXCalls() []struct {
	Ctx        context.Context
	Key        string
	Value      interface{}
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		Expiration time.Duration
	}
	mock.lockSetNX.RLock()
	calls = mock.calls.SetNX
	mock.lockSetNX.RUnlock()
	return calls
}

// SetRange calls SetRangeFunc.
func (mock *GoRedisClientMock) SetRange(ctx context.Context, key string, offset int64, value string) *redis.IntCmd {
	if mock.SetRangeFunc == nil {
		panic("GoRedisClientMock.SetRangeFunc: method is nil but GoRedisClient.SetRange was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Offset int64
		Value  string
	}{
		Ctx:    ctx,
		Key:    key,
		Offset: offset,
		Value:  value,
	}
	mock.lockSetRange.Lock()
	mock.calls.SetRange = append(mock.calls.SetRange, callInfo)
	mock.lockSetRange.Unlock()
	return mock.SetRangeFunc(ctx, key, offset, value)
}

// SetRangeCalls gets all the calls that were made to SetRange.
// Check the length with:
//
//	len(mockedGoRedisClient.SetRangeCalls())
func (mock *GoRedisClientMock) SetRangeCalls() []struct {
	Ctx    context.Context
	Key    string
	Offset int64
	Value  string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Offset int64
		Value  string
	}
	mock.lockSetRange.RLock()
	calls = mock.calls.SetRange
	mock.lockSetRange.RUnlock()
	return calls
}

// SetXX calls SetXXFunc.
func (mock *GoRedisClientMock) SetXX(ctx context.Context, key string, value interface{}, expiration time.Duration) *redis.BoolCmd {
	if mock.SetXXFunc == nil {
		panic("GoRedisClientMock.SetXXFunc: method is nil but GoRedisClient.SetXX was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		Expiration time.Duration
	}{
		Ctx:        ctx,
		Key:        key,
		Value:      value,
		Expiration: expiration,
	}
	mock.lockSetXX.Lock()
	mock.calls.SetXX = append(mock.calls.SetXX, callInfo)
	mock.lockSetXX.Unlock()
	return mock.SetXXFunc(ctx, key, value, expiration)
}

// SetXXCalls gets all the calls that were made to SetXX.
// Check the length with:
//
//	len(mockedGoRedisClient.SetXXCalls())
func (mock *GoRedisClientMock) SetXXCalls() []struct {
	Ctx        context.Context
	Key        string
	Value      interface{}
	Expiration time.Duration
} {
	var calls []struct {
		Ctx        context.Context
		Key        string
		Value      interface{}
		Expiration time.Duration
	}
	mock.lockSetXX.RLock()
	calls = mock.calls.SetXX
	mock.lockSetXX.RUnlock()
	return calls
}

// Shutdown calls ShutdownFunc.
func (mock *GoRedisClientMock) Shutdown(ctx context.Context) *redis.StatusCmd {
	if mock.ShutdownFunc == nil {
		panic("GoRedisClientMock.ShutdownFunc: method is nil but GoRedisClient.Shutdown was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockShutdown.Lock()
	mock.calls.Shutdown = append(mock.calls.Shutdown, callInfo)
	mock.lockShutdown.Unlock()
	return mock.ShutdownFunc(ctx)
}

// ShutdownCalls gets all the calls that were made to Shutdown.
// Check the length with:
//
//	len(mockedGoRedisClient.ShutdownCalls())
func (mock *GoRedisClientMock) ShutdownCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockShutdown.RLock()
	calls = mock.calls.Shutdown
	mock.lockShutdown.RUnlock()
	return calls
}

// ShutdownNoSave calls ShutdownNoSaveFunc.
func (mock *GoRedisClientMock) ShutdownNoSave(ctx context.Context) *redis.StatusCmd {
	if mock.ShutdownNoSaveFunc == nil {
		panic("GoRedisClientMock.ShutdownNoSaveFunc: method is nil but GoRedisClient.ShutdownNoSave was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockShutdownNoSave.Lock()
	mock.calls.ShutdownNoSave = append(mock.calls.ShutdownNoSave, callInfo)
	mock.lockShutdownNoSave.Unlock()
	return mock.ShutdownNoSaveFunc(ctx)
}

// ShutdownNoSaveCalls gets all the calls that were made to ShutdownNoSave.
// Check the length with:
//
//	len(mockedGoRedisClient.ShutdownNoSaveCalls())
func (mock *GoRedisClientMock) ShutdownNoSaveCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockShutdownNoSave.RLock()
	calls = mock.calls.ShutdownNoSave
	mock.lockShutdownNoSave.RUnlock()
	return calls
}

// ShutdownSave calls ShutdownSaveFunc.
func (mock *GoRedisClientMock) ShutdownSave(ctx context.Context) *redis.StatusCmd {
	if mock.ShutdownSaveFunc == nil {
		panic("GoRedisClientMock.ShutdownSaveFunc: method is nil but GoRedisClient.ShutdownSave was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockShutdownSave.Lock()
	mock.calls.ShutdownSave = append(mock.calls.ShutdownSave, callInfo)
	mock.lockShutdownSave.Unlock()
	return mock.ShutdownSaveFunc(ctx)
}

// ShutdownSaveCalls gets all the calls that were made to ShutdownSave.
// Check the length with:
//
//	len(mockedGoRedisClient.ShutdownSaveCalls())
func (mock *GoRedisClientMock) ShutdownSaveCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockShutdownSave.RLock()
	calls = mock.calls.ShutdownSave
	mock.lockShutdownSave.RUnlock()
	return calls
}

// SlaveOf calls SlaveOfFunc.
func (mock *GoRedisClientMock) SlaveOf(ctx context.Context, host string, port string) *redis.StatusCmd {
	if mock.SlaveOfFunc == nil {
		panic("GoRedisClientMock.SlaveOfFunc: method is nil but GoRedisClient.SlaveOf was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Host string
		Port string
	}{
		Ctx:  ctx,
		Host: host,
		Port: port,
	}
	mock.lockSlaveOf.Lock()
	mock.calls.SlaveOf = append(mock.calls.SlaveOf, callInfo)
	mock.lockSlaveOf.Unlock()
	return mock.SlaveOfFunc(ctx, host, port)
}

// SlaveOfCalls gets all the calls that were made to SlaveOf.
// Check the length with:
//
//	len(mockedGoRedisClient.SlaveOfCalls())
func (mock *GoRedisClientMock) SlaveOfCalls() []struct {
	Ctx  context.Context
	Host string
	Port string
} {
	var calls []struct {
		Ctx  context.Context
		Host string
		Port string
	}
	mock.lockSlaveOf.RLock()
	calls = mock.calls.SlaveOf
	mock.lockSlaveOf.RUnlock()
	return calls
}

// SlowLogGet calls SlowLogGetFunc.
func (mock *GoRedisClientMock) SlowLogGet(ctx context.Context, num int64) *redis.SlowLogCmd {
	if mock.SlowLogGetFunc == nil {
		panic("GoRedisClientMock.SlowLogGetFunc: method is nil but GoRedisClient.SlowLogGet was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Num int64
	}{
		Ctx: ctx,
		Num: num,
	}
	mock.lockSlowLogGet.Lock()
	mock.calls.SlowLogGet = append(mock.calls.SlowLogGet, callInfo)
	mock.lockSlowLogGet.Unlock()
	return mock.SlowLogGetFunc(ctx, num)
}

// SlowLogGetCalls gets all the calls that were made to SlowLogGet.
// Check the length with:
//
//	len(mockedGoRedisClient.SlowLogGetCalls())
func (mock *GoRedisClientMock) SlowLogGetCalls() []struct {
	Ctx context.Context
	Num int64
} {
	var calls []struct {
		Ctx context.Context
		Num int64
	}
	mock.lockSlowLogGet.RLock()
	calls = mock.calls.SlowLogGet
	mock.lockSlowLogGet.RUnlock()
	return calls
}

// Sort calls SortFunc.
func (mock *GoRedisClientMock) Sort(ctx context.Context, key string, sort *redis.Sort) *redis.StringSliceCmd {
	if mock.SortFunc == nil {
		panic("GoRedisClientMock.SortFunc: method is nil but GoRedisClient.Sort was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Sort *redis.Sort
	}{
		Ctx:  ctx,
		Key:  key,
		Sort: sort,
	}
	mock.lockSort.Lock()
	mock.calls.Sort = append(mock.calls.Sort, callInfo)
	mock.lockSort.Unlock()
	return mock.SortFunc(ctx, key, sort)
}

// SortCalls gets all the calls that were made to Sort.
// Check the length with:
//
//	len(mockedGoRedisClient.SortCalls())
func (mock *GoRedisClientMock) SortCalls() []struct {
	Ctx  context.Context
	Key  string
	Sort *redis.Sort
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Sort *redis.Sort
	}
	mock.lockSort.RLock()
	calls = mock.calls.Sort
	mock.lockSort.RUnlock()
	return calls
}

// SortInterfaces calls SortInterfacesFunc.
func (mock *GoRedisClientMock) SortInterfaces(ctx context.Context, key string, sort *redis.Sort) *redis.SliceCmd {
	if mock.SortInterfacesFunc == nil {
		panic("GoRedisClientMock.SortInterfacesFunc: method is nil but GoRedisClient.SortInterfaces was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Sort *redis.Sort
	}{
		Ctx:  ctx,
		Key:  key,
		Sort: sort,
	}
	mock.lockSortInterfaces.Lock()
	mock.calls.SortInterfaces = append(mock.calls.SortInterfaces, callInfo)
	mock.lockSortInterfaces.Unlock()
	return mock.SortInterfacesFunc(ctx, key, sort)
}

// SortInterfacesCalls gets all the calls that were made to SortInterfaces.
// Check the length with:
//
//	len(mockedGoRedisClient.SortInterfacesCalls())
func (mock *GoRedisClientMock) SortInterfacesCalls() []struct {
	Ctx  context.Context
	Key  string
	Sort *redis.Sort
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Sort *redis.Sort
	}
	mock.lockSortInterfaces.RLock()
	calls = mock.calls.SortInterfaces
	mock.lockSortInterfaces.RUnlock()
	return calls
}

// SortRO calls SortROFunc.
func (mock *GoRedisClientMock) SortRO(ctx context.Context, key string, sort *redis.Sort) *redis.StringSliceCmd {
	if mock.SortROFunc == nil {
		panic("GoRedisClientMock.SortROFunc: method is nil but GoRedisClient.SortRO was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Sort *redis.Sort
	}{
		Ctx:  ctx,
		Key:  key,
		Sort: sort,
	}
	mock.lockSortRO.Lock()
	mock.calls.SortRO = append(mock.calls.SortRO, callInfo)
	mock.lockSortRO.Unlock()
	return mock.SortROFunc(ctx, key, sort)
}

// SortROCalls gets all the calls that were made to SortRO.
// Check the length with:
//
//	len(mockedGoRedisClient.SortROCalls())
func (mock *GoRedisClientMock) SortROCalls() []struct {
	Ctx  context.Context
	Key  string
	Sort *redis.Sort
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Sort *redis.Sort
	}
	mock.lockSortRO.RLock()
	calls = mock.calls.SortRO
	mock.lockSortRO.RUnlock()
	return calls
}

// SortStore calls SortStoreFunc.
func (mock *GoRedisClientMock) SortStore(ctx context.Context, key string, store string, sort *redis.Sort) *redis.IntCmd {
	if mock.SortStoreFunc == nil {
		panic("GoRedisClientMock.SortStoreFunc: method is nil but GoRedisClient.SortStore was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Store string
		Sort  *redis.Sort
	}{
		Ctx:   ctx,
		Key:   key,
		Store: store,
		Sort:  sort,
	}
	mock.lockSortStore.Lock()
	mock.calls.SortStore = append(mock.calls.SortStore, callInfo)
	mock.lockSortStore.Unlock()
	return mock.SortStoreFunc(ctx, key, store, sort)
}

// SortStoreCalls gets all the calls that were made to SortStore.
// Check the length with:
//
//	len(mockedGoRedisClient.SortStoreCalls())
func (mock *GoRedisClientMock) SortStoreCalls() []struct {
	Ctx   context.Context
	Key   string
	Store string
	Sort  *redis.Sort
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Store string
		Sort  *redis.Sort
	}
	mock.lockSortStore.RLock()
	calls = mock.calls.SortStore
	mock.lockSortStore.RUnlock()
	return calls
}

// StrLen calls StrLenFunc.
func (mock *GoRedisClientMock) StrLen(ctx context.Context, key string) *redis.IntCmd {
	if mock.StrLenFunc == nil {
		panic("GoRedisClientMock.StrLenFunc: method is nil but GoRedisClient.StrLen was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockStrLen.Lock()
	mock.calls.StrLen = append(mock.calls.StrLen, callInfo)
	mock.lockStrLen.Unlock()
	return mock.StrLenFunc(ctx, key)
}

// StrLenCalls gets all the calls that were made to StrLen.
// Check the length with:
//
//	len(mockedGoRedisClient.StrLenCalls())
func (mock *GoRedisClientMock) StrLenCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockStrLen.RLock()
	calls = mock.calls.StrLen
	mock.lockStrLen.RUnlock()
	return calls
}

// Subscribe calls SubscribeFunc.
func (mock *GoRedisClientMock) Subscribe(ctx context.Context, channels ...string) *redis.PubSub {
	if mock.SubscribeFunc == nil {
		panic("GoRedisClientMock.SubscribeFunc: method is nil but GoRedisClient.Subscribe was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Channels []string
	}{
		Ctx:      ctx,
		Channels: channels,
	}
	mock.lockSubscribe.Lock()
	mock.calls.Subscribe = append(mock.calls.Subscribe, callInfo)
	mock.lockSubscribe.Unlock()
	return mock.SubscribeFunc(ctx, channels...)
}

// SubscribeCalls gets all the calls that were made to Subscribe.
// Check the length with:
//
//	len(mockedGoRedisClient.SubscribeCalls())
func (mock *GoRedisClientMock) SubscribeCalls() []struct {
	Ctx      context.Context
	Channels []string
} {
	var calls []struct {
		Ctx      context.Context
		Channels []string
	}
	mock.lockSubscribe.RLock()
	calls = mock.calls.Subscribe
	mock.lockSubscribe.RUnlock()
	return calls
}

// TDigestAdd calls TDigestAddFunc.
func (mock *GoRedisClientMock) TDigestAdd(ctx context.Context, key string, elements ...float64) *redis.StatusCmd {
	if mock.TDigestAddFunc == nil {
		panic("GoRedisClientMock.TDigestAddFunc: method is nil but GoRedisClient.TDigestAdd was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []float64
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockTDigestAdd.Lock()
	mock.calls.TDigestAdd = append(mock.calls.TDigestAdd, callInfo)
	mock.lockTDigestAdd.Unlock()
	return mock.TDigestAddFunc(ctx, key, elements...)
}

// TDigestAddCalls gets all the calls that were made to TDigestAdd.
// Check the length with:
//
//	len(mockedGoRedisClient.TDigestAddCalls())
func (mock *GoRedisClientMock) TDigestAddCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []float64
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []float64
	}
	mock.lockTDigestAdd.RLock()
	calls = mock.calls.TDigestAdd
	mock.lockTDigestAdd.RUnlock()
	return calls
}

// TDigestByRank calls TDigestByRankFunc.
func (mock *GoRedisClientMock) TDigestByRank(ctx context.Context, key string, rank ...uint64) *redis.FloatSliceCmd {
	if mock.TDigestByRankFunc == nil {
		panic("GoRedisClientMock.TDigestByRankFunc: method is nil but GoRedisClient.TDigestByRank was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Rank []uint64
	}{
		Ctx:  ctx,
		Key:  key,
		Rank: rank,
	}
	mock.lockTDigestByRank.Lock()
	mock.calls.TDigestByRank = append(mock.calls.TDigestByRank, callInfo)
	mock.lockTDigestByRank.Unlock()
	return mock.TDigestByRankFunc(ctx, key, rank...)
}

// TDigestByRankCalls gets all the calls that were made to TDigestByRank.
// Check the length with:
//
//	len(mockedGoRedisClient.TDigestByRankCalls())
func (mock *GoRedisClientMock) TDigestByRankCalls() []struct {
	Ctx  context.Context
	Key  string
	Rank []uint64
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Rank []uint64
	}
	mock.lockTDigestByRank.RLock()
	calls = mock.calls.TDigestByRank
	mock.lockTDigestByRank.RUnlock()
	return calls
}

// TDigestByRevRank calls TDigestByRevRankFunc.
func (mock *GoRedisClientMock) TDigestByRevRank(ctx context.Context, key string, rank ...uint64) *redis.FloatSliceCmd {
	if mock.TDigestByRevRankFunc == nil {
		panic("GoRedisClientMock.TDigestByRevRankFunc: method is nil but GoRedisClient.TDigestByRevRank was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Rank []uint64
	}{
		Ctx:  ctx,
		Key:  key,
		Rank: rank,
	}
	mock.lockTDigestByRevRank.Lock()
	mock.calls.TDigestByRevRank = append(mock.calls.TDigestByRevRank, callInfo)
	mock.lockTDigestByRevRank.Unlock()
	return mock.TDigestByRevRankFunc(ctx, key, rank...)
}

// TDigestByRevRankCalls gets all the calls that were made to TDigestByRevRank.
// Check the length with:
//
//	len(mockedGoRedisClient.TDigestByRevRankCalls())
func (mock *GoRedisClientMock) TDigestByRevRankCalls() []struct {
	Ctx  context.Context
	Key  string
	Rank []uint64
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Rank []uint64
	}
	mock.lockTDigestByRevRank.RLock()
	calls = mock.calls.TDigestByRevRank
	mock.lockTDigestByRevRank.RUnlock()
	return calls
}

// TDigestCDF calls TDigestCDFFunc.
func (mock *GoRedisClientMock) TDigestCDF(ctx context.Context, key string, elements ...float64) *redis.FloatSliceCmd {
	if mock.TDigestCDFFunc == nil {
		panic("GoRedisClientMock.TDigestCDFFunc: method is nil but GoRedisClient.TDigestCDF was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []float64
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockTDigestCDF.Lock()
	mock.calls.TDigestCDF = append(mock.calls.TDigestCDF, callInfo)
	mock.lockTDigestCDF.Unlock()
	return mock.TDigestCDFFunc(ctx, key, elements...)
}

// TDigestCDFCalls gets all the calls that were made to TDigestCDF.
// Check the length with:
//
//	len(mockedGoRedisClient.TDigestCDFCalls())
func (mock *GoRedisClientMock) TDigestCDFCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []float64
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []float64
	}
	mock.lockTDigestCDF.RLock()
	calls = mock.calls.TDigestCDF
	mock.lockTDigestCDF.RUnlock()
	return calls
}

// TDigestCreate calls TDigestCreateFunc.
func (mock *GoRedisClientMock) TDigestCreate(ctx context.Context, key string) *redis.StatusCmd {
	if mock.TDigestCreateFunc == nil {
		panic("GoRedisClientMock.TDigestCreateFunc: method is nil but GoRedisClient.TDigestCreate was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTDigestCreate.Lock()
	mock.calls.TDigestCreate = append(mock.calls.TDigestCreate, callInfo)
	mock.lockTDigestCreate.Unlock()
	return mock.TDigestCreateFunc(ctx, key)
}

// TDigestCreateCalls gets all the calls that were made to TDigestCreate.
// Check the length with:
//
//	len(mockedGoRedisClient.TDigestCreateCalls())
func (mock *GoRedisClientMock) TDigestCreateCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTDigestCreate.RLock()
	calls = mock.calls.TDigestCreate
	mock.lockTDigestCreate.RUnlock()
	return calls
}

// TDigestCreateWithCompression calls TDigestCreateWithCompressionFunc.
func (mock *GoRedisClientMock) TDigestCreateWithCompression(ctx context.Context, key string, compression int64) *redis.StatusCmd {
	if mock.TDigestCreateWithCompressionFunc == nil {
		panic("GoRedisClientMock.TDigestCreateWithCompressionFunc: method is nil but GoRedisClient.TDigestCreateWithCompression was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Key         string
		Compression int64
	}{
		Ctx:         ctx,
		Key:         key,
		Compression: compression,
	}
	mock.lockTDigestCreateWithCompression.Lock()
	mock.calls.TDigestCreateWithCompression = append(mock.calls.TDigestCreateWithCompression, callInfo)
	mock.lockTDigestCreateWithCompression.Unlock()
	return mock.TDigestCreateWithCompressionFunc(ctx, key, compression)
}

// TDigestCreateWithCompressionCalls gets all the calls that were made to TDigestCreateWithCompression.
// Check the length with:
//
//	len(mockedGoRedisClient.TDigestCreateWithCompressionCalls())
func (mock *GoRedisClientMock) TDigestCreateWithCompressionCalls() []struct {
	Ctx         context.Context
	Key         string
	Compression int64
} {
	var calls []struct {
		Ctx         context.Context
		Key         string
		Compression int64
	}
	mock.lockTDigestCreateWithCompression.RLock()
	calls = mock.calls.TDigestCreateWithCompression
	mock.lockTDigestCreateWithCompression.RUnlock()
	return calls
}

// TDigestInfo calls TDigestInfoFunc.
func (mock *GoRedisClientMock) TDigestInfo(ctx context.Context, key string) *redis.TDigestInfoCmd {
	if mock.TDigestInfoFunc == nil {
		panic("GoRedisClientMock.TDigestInfoFunc: method is nil but GoRedisClient.TDigestInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTDigestInfo.Lock()
	mock.calls.TDigestInfo = append(mock.calls.TDigestInfo, callInfo)
	mock.lockTDigestInfo.Unlock()
	return mock.TDigestInfoFunc(ctx, key)
}

// TDigestInfoCalls gets all the calls that were made to TDigestInfo.
// Check the length with:
//
//	len(mockedGoRedisClient.TDigestInfoCalls())
func (mock *GoRedisClientMock) TDigestInfoCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTDigestInfo.RLock()
	calls = mock.calls.TDigestInfo
	mock.lockTDigestInfo.RUnlock()
	return calls
}

// TDigestMax calls TDigestMaxFunc.
func (mock *GoRedisClientMock) TDigestMax(ctx context.Context, key string) *redis.FloatCmd {
	if mock.TDigestMaxFunc == nil {
		panic("GoRedisClientMock.TDigestMaxFunc: method is nil but GoRedisClient.TDigestMax was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTDigestMax.Lock()
	mock.calls.TDigestMax = append(mock.calls.TDigestMax, callInfo)
	mock.lockTDigestMax.Unlock()
	return mock.TDigestMaxFunc(ctx, key)
}

// TDigestMaxCalls gets all the calls that were made to TDigestMax.
// Check the length with:
//
//	len(mockedGoRedisClient.TDigestMaxCalls())
func (mock *GoRedisClientMock) TDigestMaxCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTDigestMax.RLock()
	calls = mock.calls.TDigestMax
	mock.lockTDigestMax.RUnlock()
	return calls
}

// TDigestMerge calls TDigestMergeFunc.
func (mock *GoRedisClientMock) TDigestMerge(ctx context.Context, destKey string, options *redis.TDigestMergeOptions, sourceKeys ...string) *redis.StatusCmd {
	if mock.TDigestMergeFunc == nil {
		panic("GoRedisClientMock.TDigestMergeFunc: method is nil but GoRedisClient.TDigestMerge was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		DestKey    string
		Options    *redis.TDigestMergeOptions
		SourceKeys []string
	}{
		Ctx:        ctx,
		DestKey:    destKey,
		Options:    options,
		SourceKeys: sourceKeys,
	}
	mock.lockTDigestMerge.Lock()
	mock.calls.TDigestMerge = append(mock.calls.TDigestMerge, callInfo)
	mock.lockTDigestMerge.Unlock()
	return mock.TDigestMergeFunc(ctx, destKey, options, sourceKeys...)
}

// TDigestMergeCalls gets all the calls that were made to TDigestMerge.
// Check the length with:
//
//	len(mockedGoRedisClient.TDigestMergeCalls())
func (mock *GoRedisClientMock) TDigestMergeCalls() []struct {
	Ctx        context.Context
	DestKey    string
	Options    *redis.TDigestMergeOptions
	SourceKeys []string
} {
	var calls []struct {
		Ctx        context.Context
		DestKey    string
		Options    *redis.TDigestMergeOptions
		SourceKeys []string
	}
	mock.lockTDigestMerge.RLock()
	calls = mock.calls.TDigestMerge
	mock.lockTDigestMerge.RUnlock()
	return calls
}

// TDigestMin calls TDigestMinFunc.
func (mock *GoRedisClientMock) TDigestMin(ctx context.Context, key string) *redis.FloatCmd {
	if mock.TDigestMinFunc == nil {
		panic("GoRedisClientMock.TDigestMinFunc: method is nil but GoRedisClient.TDigestMin was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTDigestMin.Lock()
	mock.calls.TDigestMin = append(mock.calls.TDigestMin, callInfo)
	mock.lockTDigestMin.Unlock()
	return mock.TDigestMinFunc(ctx, key)
}

// TDigestMinCalls gets all the calls that were made to TDigestMin.
// Check the length with:
//
//	len(mockedGoRedisClient.TDigestMinCalls())
func (mock *GoRedisClientMock) TDigestMinCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTDigestMin.RLock()
	calls = mock.calls.TDigestMin
	mock.lockTDigestMin.RUnlock()
	return calls
}

// TDigestQuantile calls TDigestQuantileFunc.
func (mock *GoRedisClientMock) TDigestQuantile(ctx context.Context, key string, elements ...float64) *redis.FloatSliceCmd {
	if mock.TDigestQuantileFunc == nil {
		panic("GoRedisClientMock.TDigestQuantileFunc: method is nil but GoRedisClient.TDigestQuantile was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []float64
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockTDigestQuantile.Lock()
	mock.calls.TDigestQuantile = append(mock.calls.TDigestQuantile, callInfo)
	mock.lockTDigestQuantile.Unlock()
	return mock.TDigestQuantileFunc(ctx, key, elements...)
}

// TDigestQuantileCalls gets all the calls that were made to TDigestQuantile.
// Check the length with:
//
//	len(mockedGoRedisClient.TDigestQuantileCalls())
func (mock *GoRedisClientMock) TDigestQuantileCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []float64
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []float64
	}
	mock.lockTDigestQuantile.RLock()
	calls = mock.calls.TDigestQuantile
	mock.lockTDigestQuantile.RUnlock()
	return calls
}

// TDigestRank calls TDigestRankFunc.
func (mock *GoRedisClientMock) TDigestRank(ctx context.Context, key string, values ...float64) *redis.IntSliceCmd {
	if mock.TDigestRankFunc == nil {
		panic("GoRedisClientMock.TDigestRankFunc: method is nil but GoRedisClient.TDigestRank was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Values []float64
	}{
		Ctx:    ctx,
		Key:    key,
		Values: values,
	}
	mock.lockTDigestRank.Lock()
	mock.calls.TDigestRank = append(mock.calls.TDigestRank, callInfo)
	mock.lockTDigestRank.Unlock()
	return mock.TDigestRankFunc(ctx, key, values...)
}

// TDigestRankCalls gets all the calls that were made to TDigestRank.
// Check the length with:
//
//	len(mockedGoRedisClient.TDigestRankCalls())
func (mock *GoRedisClientMock) TDigestRankCalls() []struct {
	Ctx    context.Context
	Key    string
	Values []float64
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Values []float64
	}
	mock.lockTDigestRank.RLock()
	calls = mock.calls.TDigestRank
	mock.lockTDigestRank.RUnlock()
	return calls
}

// TDigestReset calls TDigestResetFunc.
func (mock *GoRedisClientMock) TDigestReset(ctx context.Context, key string) *redis.StatusCmd {
	if mock.TDigestResetFunc == nil {
		panic("GoRedisClientMock.TDigestResetFunc: method is nil but GoRedisClient.TDigestReset was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTDigestReset.Lock()
	mock.calls.TDigestReset = append(mock.calls.TDigestReset, callInfo)
	mock.lockTDigestReset.Unlock()
	return mock.TDigestResetFunc(ctx, key)
}

// TDigestResetCalls gets all the calls that were made to TDigestReset.
// Check the length with:
//
//	len(mockedGoRedisClient.TDigestResetCalls())
func (mock *GoRedisClientMock) TDigestResetCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTDigestReset.RLock()
	calls = mock.calls.TDigestReset
	mock.lockTDigestReset.RUnlock()
	return calls
}

// TDigestRevRank calls TDigestRevRankFunc.
func (mock *GoRedisClientMock) TDigestRevRank(ctx context.Context, key string, values ...float64) *redis.IntSliceCmd {
	if mock.TDigestRevRankFunc == nil {
		panic("GoRedisClientMock.TDigestRevRankFunc: method is nil but GoRedisClient.TDigestRevRank was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Values []float64
	}{
		Ctx:    ctx,
		Key:    key,
		Values: values,
	}
	mock.lockTDigestRevRank.Lock()
	mock.calls.TDigestRevRank = append(mock.calls.TDigestRevRank, callInfo)
	mock.lockTDigestRevRank.Unlock()
	return mock.TDigestRevRankFunc(ctx, key, values...)
}

// TDigestRevRankCalls gets all the calls that were made to TDigestRevRank.
// Check the length with:
//
//	len(mockedGoRedisClient.TDigestRevRankCalls())
func (mock *GoRedisClientMock) TDigestRevRankCalls() []struct {
	Ctx    context.Context
	Key    string
	Values []float64
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Values []float64
	}
	mock.lockTDigestRevRank.RLock()
	calls = mock.calls.TDigestRevRank
	mock.lockTDigestRevRank.RUnlock()
	return calls
}

// TDigestTrimmedMean calls TDigestTrimmedMeanFunc.
func (mock *GoRedisClientMock) TDigestTrimmedMean(ctx context.Context, key string, lowCutQuantile float64, highCutQuantile float64) *redis.FloatCmd {
	if mock.TDigestTrimmedMeanFunc == nil {
		panic("GoRedisClientMock.TDigestTrimmedMeanFunc: method is nil but GoRedisClient.TDigestTrimmedMean was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		Key             string
		LowCutQuantile  float64
		HighCutQuantile float64
	}{
		Ctx:             ctx,
		Key:             key,
		LowCutQuantile:  lowCutQuantile,
		HighCutQuantile: highCutQuantile,
	}
	mock.lockTDigestTrimmedMean.Lock()
	mock.calls.TDigestTrimmedMean = append(mock.calls.TDigestTrimmedMean, callInfo)
	mock.lockTDigestTrimmedMean.Unlock()
	return mock.TDigestTrimmedMeanFunc(ctx, key, lowCutQuantile, highCutQuantile)
}

// TDigestTrimmedMeanCalls gets all the calls that were made to TDigestTrimmedMean.
// Check the length with:
//
//	len(mockedGoRedisClient.TDigestTrimmedMeanCalls())
func (mock *GoRedisClientMock) TDigestTrimmedMeanCalls() []struct {
	Ctx             context.Context
	Key             string
	LowCutQuantile  float64
	HighCutQuantile float64
} {
	var calls []struct {
		Ctx             context.Context
		Key             string
		LowCutQuantile  float64
		HighCutQuantile float64
	}
	mock.lockTDigestTrimmedMean.RLock()
	calls = mock.calls.TDigestTrimmedMean
	mock.lockTDigestTrimmedMean.RUnlock()
	return calls
}

// TSAdd calls TSAddFunc.
func (mock *GoRedisClientMock) TSAdd(ctx context.Context, key string, timestamp interface{}, value float64) *redis.IntCmd {
	if mock.TSAddFunc == nil {
		panic("GoRedisClientMock.TSAddFunc: method is nil but GoRedisClient.TSAdd was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		Timestamp interface{}
		Value     float64
	}{
		Ctx:       ctx,
		Key:       key,
		Timestamp: timestamp,
		Value:     value,
	}
	mock.lockTSAdd.Lock()
	mock.calls.TSAdd = append(mock.calls.TSAdd, callInfo)
	mock.lockTSAdd.Unlock()
	return mock.TSAddFunc(ctx, key, timestamp, value)
}

// TSAddCalls gets all the calls that were made to TSAdd.
// Check the length with:
//
//	len(mockedGoRedisClient.TSAddCalls())
func (mock *GoRedisClientMock) TSAddCalls() []struct {
	Ctx       context.Context
	Key       string
	Timestamp interface{}
	Value     float64
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		Timestamp interface{}
		Value     float64
	}
	mock.lockTSAdd.RLock()
	calls = mock.calls.TSAdd
	mock.lockTSAdd.RUnlock()
	return calls
}

// TSAddWithArgs calls TSAddWithArgsFunc.
func (mock *GoRedisClientMock) TSAddWithArgs(ctx context.Context, key string, timestamp interface{}, value float64, options *redis.TSOptions) *redis.IntCmd {
	if mock.TSAddWithArgsFunc == nil {
		panic("GoRedisClientMock.TSAddWithArgsFunc: method is nil but GoRedisClient.TSAddWithArgs was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		Timestamp interface{}
		Value     float64
		Options   *redis.TSOptions
	}{
		Ctx:       ctx,
		Key:       key,
		Timestamp: timestamp,
		Value:     value,
		Options:   options,
	}
	mock.lockTSAddWithArgs.Lock()
	mock.calls.TSAddWithArgs = append(mock.calls.TSAddWithArgs, callInfo)
	mock.lockTSAddWithArgs.Unlock()
	return mock.TSAddWithArgsFunc(ctx, key, timestamp, value, options)
}

// TSAddWithArgsCalls gets all the calls that were made to TSAddWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.TSAddWithArgsCalls())
func (mock *GoRedisClientMock) TSAddWithArgsCalls() []struct {
	Ctx       context.Context
	Key       string
	Timestamp interface{}
	Value     float64
	Options   *redis.TSOptions
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		Timestamp interface{}
		Value     float64
		Options   *redis.TSOptions
	}
	mock.lockTSAddWithArgs.RLock()
	calls = mock.calls.TSAddWithArgs
	mock.lockTSAddWithArgs.RUnlock()
	return calls
}

// TSAlter calls TSAlterFunc.
func (mock *GoRedisClientMock) TSAlter(ctx context.Context, key string, options *redis.TSAlterOptions) *redis.StatusCmd {
	if mock.TSAlterFunc == nil {
		panic("GoRedisClientMock.TSAlterFunc: method is nil but GoRedisClient.TSAlter was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Options *redis.TSAlterOptions
	}{
		Ctx:     ctx,
		Key:     key,
		Options: options,
	}
	mock.lockTSAlter.Lock()
	mock.calls.TSAlter = append(mock.calls.TSAlter, callInfo)
	mock.lockTSAlter.Unlock()
	return mock.TSAlterFunc(ctx, key, options)
}

// TSAlterCalls gets all the calls that were made to TSAlter.
// Check the length with:
//
//	len(mockedGoRedisClient.TSAlterCalls())
func (mock *GoRedisClientMock) TSAlterCalls() []struct {
	Ctx     context.Context
	Key     string
	Options *redis.TSAlterOptions
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Options *redis.TSAlterOptions
	}
	mock.lockTSAlter.RLock()
	calls = mock.calls.TSAlter
	mock.lockTSAlter.RUnlock()
	return calls
}

// TSCreate calls TSCreateFunc.
func (mock *GoRedisClientMock) TSCreate(ctx context.Context, key string) *redis.StatusCmd {
	if mock.TSCreateFunc == nil {
		panic("GoRedisClientMock.TSCreateFunc: method is nil but GoRedisClient.TSCreate was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTSCreate.Lock()
	mock.calls.TSCreate = append(mock.calls.TSCreate, callInfo)
	mock.lockTSCreate.Unlock()
	return mock.TSCreateFunc(ctx, key)
}

// TSCreateCalls gets all the calls that were made to TSCreate.
// Check the length with:
//
//	len(mockedGoRedisClient.TSCreateCalls())
func (mock *GoRedisClientMock) TSCreateCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTSCreate.RLock()
	calls = mock.calls.TSCreate
	mock.lockTSCreate.RUnlock()
	return calls
}

// TSCreateRule calls TSCreateRuleFunc.
func (mock *GoRedisClientMock) TSCreateRule(ctx context.Context, sourceKey string, destKey string, aggregator redis.Aggregator, bucketDuration int) *redis.StatusCmd {
	if mock.TSCreateRuleFunc == nil {
		panic("GoRedisClientMock.TSCreateRuleFunc: method is nil but GoRedisClient.TSCreateRule was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		SourceKey      string
		DestKey        string
		Aggregator     redis.Aggregator
		BucketDuration int
	}{
		Ctx:            ctx,
		SourceKey:      sourceKey,
		DestKey:        destKey,
		Aggregator:     aggregator,
		BucketDuration: bucketDuration,
	}
	mock.lockTSCreateRule.Lock()
	mock.calls.TSCreateRule = append(mock.calls.TSCreateRule, callInfo)
	mock.lockTSCreateRule.Unlock()
	return mock.TSCreateRuleFunc(ctx, sourceKey, destKey, aggregator, bucketDuration)
}

// TSCreateRuleCalls gets all the calls that were made to TSCreateRule.
// Check the length with:
//
//	len(mockedGoRedisClient.TSCreateRuleCalls())
func (mock *GoRedisClientMock) TSCreateRuleCalls() []struct {
	Ctx            context.Context
	SourceKey      string
	DestKey        string
	Aggregator     redis.Aggregator
	BucketDuration int
} {
	var calls []struct {
		Ctx            context.Context
		SourceKey      string
		DestKey        string
		Aggregator     redis.Aggregator
		BucketDuration int
	}
	mock.lockTSCreateRule.RLock()
	calls = mock.calls.TSCreateRule
	mock.lockTSCreateRule.RUnlock()
	return calls
}

// TSCreateRuleWithArgs calls TSCreateRuleWithArgsFunc.
func (mock *GoRedisClientMock) TSCreateRuleWithArgs(ctx context.Context, sourceKey string, destKey string, aggregator redis.Aggregator, bucketDuration int, options *redis.TSCreateRuleOptions) *redis.StatusCmd {
	if mock.TSCreateRuleWithArgsFunc == nil {
		panic("GoRedisClientMock.TSCreateRuleWithArgsFunc: method is nil but GoRedisClient.TSCreateRuleWithArgs was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		SourceKey      string
		DestKey        string
		Aggregator     redis.Aggregator
		BucketDuration int
		Options        *redis.TSCreateRuleOptions
	}{
		Ctx:            ctx,
		SourceKey:      sourceKey,
		DestKey:        destKey,
		Aggregator:     aggregator,
		BucketDuration: bucketDuration,
		Options:        options,
	}
	mock.lockTSCreateRuleWithArgs.Lock()
	mock.calls.TSCreateRuleWithArgs = append(mock.calls.TSCreateRuleWithArgs, callInfo)
	mock.lockTSCreateRuleWithArgs.Unlock()
	return mock.TSCreateRuleWithArgsFunc(ctx, sourceKey, destKey, aggregator, bucketDuration, options)
}

// TSCreateRuleWithArgsCalls gets all the calls that were made to TSCreateRuleWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.TSCreateRuleWithArgsCalls())
func (mock *GoRedisClientMock) TSCreateRuleWithArgsCalls() []struct {
	Ctx            context.Context
	SourceKey      string
	DestKey        string
	Aggregator     redis.Aggregator
	BucketDuration int
	Options        *redis.TSCreateRuleOptions
} {
	var calls []struct {
		Ctx            context.Context
		SourceKey      string
		DestKey        string
		Aggregator     redis.Aggregator
		BucketDuration int
		Options        *redis.TSCreateRuleOptions
	}
	mock.lockTSCreateRuleWithArgs.RLock()
	calls = mock.calls.TSCreateRuleWithArgs
	mock.lockTSCreateRuleWithArgs.RUnlock()
	return calls
}

// TSCreateWithArgs calls TSCreateWithArgsFunc.
func (mock *GoRedisClientMock) TSCreateWithArgs(ctx context.Context, key string, options *redis.TSOptions) *redis.StatusCmd {
	if mock.TSCreateWithArgsFunc == nil {
		panic("GoRedisClientMock.TSCreateWithArgsFunc: method is nil but GoRedisClient.TSCreateWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Options *redis.TSOptions
	}{
		Ctx:     ctx,
		Key:     key,
		Options: options,
	}
	mock.lockTSCreateWithArgs.Lock()
	mock.calls.TSCreateWithArgs = append(mock.calls.TSCreateWithArgs, callInfo)
	mock.lockTSCreateWithArgs.Unlock()
	return mock.TSCreateWithArgsFunc(ctx, key, options)
}

// TSCreateWithArgsCalls gets all the calls that were made to TSCreateWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.TSCreateWithArgsCalls())
func (mock *GoRedisClientMock) TSCreateWithArgsCalls() []struct {
	Ctx     context.Context
	Key     string
	Options *redis.TSOptions
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Options *redis.TSOptions
	}
	mock.lockTSCreateWithArgs.RLock()
	calls = mock.calls.TSCreateWithArgs
	mock.lockTSCreateWithArgs.RUnlock()
	return calls
}

// TSDecrBy calls TSDecrByFunc.
func (mock *GoRedisClientMock) TSDecrBy(ctx context.Context, Key string, timestamp float64) *redis.IntCmd {
	if mock.TSDecrByFunc == nil {
		panic("GoRedisClientMock.TSDecrByFunc: method is nil but GoRedisClient.TSDecrBy was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		Timestamp float64
	}{
		Ctx:       ctx,
		Key:       Key,
		Timestamp: timestamp,
	}
	mock.lockTSDecrBy.Lock()
	mock.calls.TSDecrBy = append(mock.calls.TSDecrBy, callInfo)
	mock.lockTSDecrBy.Unlock()
	return mock.TSDecrByFunc(ctx, Key, timestamp)
}

// TSDecrByCalls gets all the calls that were made to TSDecrBy.
// Check the length with:
//
//	len(mockedGoRedisClient.TSDecrByCalls())
func (mock *GoRedisClientMock) TSDecrByCalls() []struct {
	Ctx       context.Context
	Key       string
	Timestamp float64
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		Timestamp float64
	}
	mock.lockTSDecrBy.RLock()
	calls = mock.calls.TSDecrBy
	mock.lockTSDecrBy.RUnlock()
	return calls
}

// TSDecrByWithArgs calls TSDecrByWithArgsFunc.
func (mock *GoRedisClientMock) TSDecrByWithArgs(ctx context.Context, key string, timestamp float64, options *redis.TSIncrDecrOptions) *redis.IntCmd {
	if mock.TSDecrByWithArgsFunc == nil {
		panic("GoRedisClientMock.TSDecrByWithArgsFunc: method is nil but GoRedisClient.TSDecrByWithArgs was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		Timestamp float64
		Options   *redis.TSIncrDecrOptions
	}{
		Ctx:       ctx,
		Key:       key,
		Timestamp: timestamp,
		Options:   options,
	}
	mock.lockTSDecrByWithArgs.Lock()
	mock.calls.TSDecrByWithArgs = append(mock.calls.TSDecrByWithArgs, callInfo)
	mock.lockTSDecrByWithArgs.Unlock()
	return mock.TSDecrByWithArgsFunc(ctx, key, timestamp, options)
}

// TSDecrByWithArgsCalls gets all the calls that were made to TSDecrByWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.TSDecrByWithArgsCalls())
func (mock *GoRedisClientMock) TSDecrByWithArgsCalls() []struct {
	Ctx       context.Context
	Key       string
	Timestamp float64
	Options   *redis.TSIncrDecrOptions
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		Timestamp float64
		Options   *redis.TSIncrDecrOptions
	}
	mock.lockTSDecrByWithArgs.RLock()
	calls = mock.calls.TSDecrByWithArgs
	mock.lockTSDecrByWithArgs.RUnlock()
	return calls
}

// TSDel calls TSDelFunc.
func (mock *GoRedisClientMock) TSDel(ctx context.Context, Key string, fromTimestamp int, toTimestamp int) *redis.IntCmd {
	if mock.TSDelFunc == nil {
		panic("GoRedisClientMock.TSDelFunc: method is nil but GoRedisClient.TSDel was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Key           string
		FromTimestamp int
		ToTimestamp   int
	}{
		Ctx:           ctx,
		Key:           Key,
		FromTimestamp: fromTimestamp,
		ToTimestamp:   toTimestamp,
	}
	mock.lockTSDel.Lock()
	mock.calls.TSDel = append(mock.calls.TSDel, callInfo)
	mock.lockTSDel.Unlock()
	return mock.TSDelFunc(ctx, Key, fromTimestamp, toTimestamp)
}

// TSDelCalls gets all the calls that were made to TSDel.
// Check the length with:
//
//	len(mockedGoRedisClient.TSDelCalls())
func (mock *GoRedisClientMock) TSDelCalls() []struct {
	Ctx           context.Context
	Key           string
	FromTimestamp int
	ToTimestamp   int
} {
	var calls []struct {
		Ctx           context.Context
		Key           string
		FromTimestamp int
		ToTimestamp   int
	}
	mock.lockTSDel.RLock()
	calls = mock.calls.TSDel
	mock.lockTSDel.RUnlock()
	return calls
}

// TSDeleteRule calls TSDeleteRuleFunc.
func (mock *GoRedisClientMock) TSDeleteRule(ctx context.Context, sourceKey string, destKey string) *redis.StatusCmd {
	if mock.TSDeleteRuleFunc == nil {
		panic("GoRedisClientMock.TSDeleteRuleFunc: method is nil but GoRedisClient.TSDeleteRule was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		SourceKey string
		DestKey   string
	}{
		Ctx:       ctx,
		SourceKey: sourceKey,
		DestKey:   destKey,
	}
	mock.lockTSDeleteRule.Lock()
	mock.calls.TSDeleteRule = append(mock.calls.TSDeleteRule, callInfo)
	mock.lockTSDeleteRule.Unlock()
	return mock.TSDeleteRuleFunc(ctx, sourceKey, destKey)
}

// TSDeleteRuleCalls gets all the calls that were made to TSDeleteRule.
// Check the length with:
//
//	len(mockedGoRedisClient.TSDeleteRuleCalls())
func (mock *GoRedisClientMock) TSDeleteRuleCalls() []struct {
	Ctx       context.Context
	SourceKey string
	DestKey   string
} {
	var calls []struct {
		Ctx       context.Context
		SourceKey string
		DestKey   string
	}
	mock.lockTSDeleteRule.RLock()
	calls = mock.calls.TSDeleteRule
	mock.lockTSDeleteRule.RUnlock()
	return calls
}

// TSGet calls TSGetFunc.
func (mock *GoRedisClientMock) TSGet(ctx context.Context, key string) *redis.TSTimestampValueCmd {
	if mock.TSGetFunc == nil {
		panic("GoRedisClientMock.TSGetFunc: method is nil but GoRedisClient.TSGet was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTSGet.Lock()
	mock.calls.TSGet = append(mock.calls.TSGet, callInfo)
	mock.lockTSGet.Unlock()
	return mock.TSGetFunc(ctx, key)
}

// TSGetCalls gets all the calls that were made to TSGet.
// Check the length with:
//
//	len(mockedGoRedisClient.TSGetCalls())
func (mock *GoRedisClientMock) TSGetCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTSGet.RLock()
	calls = mock.calls.TSGet
	mock.lockTSGet.RUnlock()
	return calls
}

// TSGetWithArgs calls TSGetWithArgsFunc.
func (mock *GoRedisClientMock) TSGetWithArgs(ctx context.Context, key string, options *redis.TSGetOptions) *redis.TSTimestampValueCmd {
	if mock.TSGetWithArgsFunc == nil {
		panic("GoRedisClientMock.TSGetWithArgsFunc: method is nil but GoRedisClient.TSGetWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Options *redis.TSGetOptions
	}{
		Ctx:     ctx,
		Key:     key,
		Options: options,
	}
	mock.lockTSGetWithArgs.Lock()
	mock.calls.TSGetWithArgs = append(mock.calls.TSGetWithArgs, callInfo)
	mock.lockTSGetWithArgs.Unlock()
	return mock.TSGetWithArgsFunc(ctx, key, options)
}

// TSGetWithArgsCalls gets all the calls that were made to TSGetWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.TSGetWithArgsCalls())
func (mock *GoRedisClientMock) TSGetWithArgsCalls() []struct {
	Ctx     context.Context
	Key     string
	Options *redis.TSGetOptions
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Options *redis.TSGetOptions
	}
	mock.lockTSGetWithArgs.RLock()
	calls = mock.calls.TSGetWithArgs
	mock.lockTSGetWithArgs.RUnlock()
	return calls
}

// TSIncrBy calls TSIncrByFunc.
func (mock *GoRedisClientMock) TSIncrBy(ctx context.Context, Key string, timestamp float64) *redis.IntCmd {
	if mock.TSIncrByFunc == nil {
		panic("GoRedisClientMock.TSIncrByFunc: method is nil but GoRedisClient.TSIncrBy was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		Timestamp float64
	}{
		Ctx:       ctx,
		Key:       Key,
		Timestamp: timestamp,
	}
	mock.lockTSIncrBy.Lock()
	mock.calls.TSIncrBy = append(mock.calls.TSIncrBy, callInfo)
	mock.lockTSIncrBy.Unlock()
	return mock.TSIncrByFunc(ctx, Key, timestamp)
}

// TSIncrByCalls gets all the calls that were made to TSIncrBy.
// Check the length with:
//
//	len(mockedGoRedisClient.TSIncrByCalls())
func (mock *GoRedisClientMock) TSIncrByCalls() []struct {
	Ctx       context.Context
	Key       string
	Timestamp float64
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		Timestamp float64
	}
	mock.lockTSIncrBy.RLock()
	calls = mock.calls.TSIncrBy
	mock.lockTSIncrBy.RUnlock()
	return calls
}

// TSIncrByWithArgs calls TSIncrByWithArgsFunc.
func (mock *GoRedisClientMock) TSIncrByWithArgs(ctx context.Context, key string, timestamp float64, options *redis.TSIncrDecrOptions) *redis.IntCmd {
	if mock.TSIncrByWithArgsFunc == nil {
		panic("GoRedisClientMock.TSIncrByWithArgsFunc: method is nil but GoRedisClient.TSIncrByWithArgs was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		Timestamp float64
		Options   *redis.TSIncrDecrOptions
	}{
		Ctx:       ctx,
		Key:       key,
		Timestamp: timestamp,
		Options:   options,
	}
	mock.lockTSIncrByWithArgs.Lock()
	mock.calls.TSIncrByWithArgs = append(mock.calls.TSIncrByWithArgs, callInfo)
	mock.lockTSIncrByWithArgs.Unlock()
	return mock.TSIncrByWithArgsFunc(ctx, key, timestamp, options)
}

// TSIncrByWithArgsCalls gets all the calls that were made to TSIncrByWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.TSIncrByWithArgsCalls())
func (mock *GoRedisClientMock) TSIncrByWithArgsCalls() []struct {
	Ctx       context.Context
	Key       string
	Timestamp float64
	Options   *redis.TSIncrDecrOptions
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		Timestamp float64
		Options   *redis.TSIncrDecrOptions
	}
	mock.lockTSIncrByWithArgs.RLock()
	calls = mock.calls.TSIncrByWithArgs
	mock.lockTSIncrByWithArgs.RUnlock()
	return calls
}

// TSInfo calls TSInfoFunc.
func (mock *GoRedisClientMock) TSInfo(ctx context.Context, key string) *redis.MapStringInterfaceCmd {
	if mock.TSInfoFunc == nil {
		panic("GoRedisClientMock.TSInfoFunc: method is nil but GoRedisClient.TSInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTSInfo.Lock()
	mock.calls.TSInfo = append(mock.calls.TSInfo, callInfo)
	mock.lockTSInfo.Unlock()
	return mock.TSInfoFunc(ctx, key)
}

// TSInfoCalls gets all the calls that were made to TSInfo.
// Check the length with:
//
//	len(mockedGoRedisClient.TSInfoCalls())
func (mock *GoRedisClientMock) TSInfoCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTSInfo.RLock()
	calls = mock.calls.TSInfo
	mock.lockTSInfo.RUnlock()
	return calls
}

// TSInfoWithArgs calls TSInfoWithArgsFunc.
func (mock *GoRedisClientMock) TSInfoWithArgs(ctx context.Context, key string, options *redis.TSInfoOptions) *redis.MapStringInterfaceCmd {
	if mock.TSInfoWithArgsFunc == nil {
		panic("GoRedisClientMock.TSInfoWithArgsFunc: method is nil but GoRedisClient.TSInfoWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Options *redis.TSInfoOptions
	}{
		Ctx:     ctx,
		Key:     key,
		Options: options,
	}
	mock.lockTSInfoWithArgs.Lock()
	mock.calls.TSInfoWithArgs = append(mock.calls.TSInfoWithArgs, callInfo)
	mock.lockTSInfoWithArgs.Unlock()
	return mock.TSInfoWithArgsFunc(ctx, key, options)
}

// TSInfoWithArgsCalls gets all the calls that were made to TSInfoWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.TSInfoWithArgsCalls())
func (mock *GoRedisClientMock) TSInfoWithArgsCalls() []struct {
	Ctx     context.Context
	Key     string
	Options *redis.TSInfoOptions
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Options *redis.TSInfoOptions
	}
	mock.lockTSInfoWithArgs.RLock()
	calls = mock.calls.TSInfoWithArgs
	mock.lockTSInfoWithArgs.RUnlock()
	return calls
}

// TSMAdd calls TSMAddFunc.
func (mock *GoRedisClientMock) TSMAdd(ctx context.Context, ktvSlices [][]interface{}) *redis.IntSliceCmd {
	if mock.TSMAddFunc == nil {
		panic("GoRedisClientMock.TSMAddFunc: method is nil but GoRedisClient.TSMAdd was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		KtvSlices [][]interface{}
	}{
		Ctx:       ctx,
		KtvSlices: ktvSlices,
	}
	mock.lockTSMAdd.Lock()
	mock.calls.TSMAdd = append(mock.calls.TSMAdd, callInfo)
	mock.lockTSMAdd.Unlock()
	return mock.TSMAddFunc(ctx, ktvSlices)
}

// TSMAddCalls gets all the calls that were made to TSMAdd.
// Check the length with:
//
//	len(mockedGoRedisClient.TSMAddCalls())
func (mock *GoRedisClientMock) TSMAddCalls() []struct {
	Ctx       context.Context
	KtvSlices [][]interface{}
} {
	var calls []struct {
		Ctx       context.Context
		KtvSlices [][]interface{}
	}
	mock.lockTSMAdd.RLock()
	calls = mock.calls.TSMAdd
	mock.lockTSMAdd.RUnlock()
	return calls
}

// TSMGet calls TSMGetFunc.
func (mock *GoRedisClientMock) TSMGet(ctx context.Context, filters []string) *redis.MapStringSliceInterfaceCmd {
	if mock.TSMGetFunc == nil {
		panic("GoRedisClientMock.TSMGetFunc: method is nil but GoRedisClient.TSMGet was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Filters []string
	}{
		Ctx:     ctx,
		Filters: filters,
	}
	mock.lockTSMGet.Lock()
	mock.calls.TSMGet = append(mock.calls.TSMGet, callInfo)
	mock.lockTSMGet.Unlock()
	return mock.TSMGetFunc(ctx, filters)
}

// TSMGetCalls gets all the calls that were made to TSMGet.
// Check the length with:
//
//	len(mockedGoRedisClient.TSMGetCalls())
func (mock *GoRedisClientMock) TSMGetCalls() []struct {
	Ctx     context.Context
	Filters []string
} {
	var calls []struct {
		Ctx     context.Context
		Filters []string
	}
	mock.lockTSMGet.RLock()
	calls = mock.calls.TSMGet
	mock.lockTSMGet.RUnlock()
	return calls
}

// TSMGetWithArgs calls TSMGetWithArgsFunc.
func (mock *GoRedisClientMock) TSMGetWithArgs(ctx context.Context, filters []string, options *redis.TSMGetOptions) *redis.MapStringSliceInterfaceCmd {
	if mock.TSMGetWithArgsFunc == nil {
		panic("GoRedisClientMock.TSMGetWithArgsFunc: method is nil but GoRedisClient.TSMGetWithArgs was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Filters []string
		Options *redis.TSMGetOptions
	}{
		Ctx:     ctx,
		Filters: filters,
		Options: options,
	}
	mock.lockTSMGetWithArgs.Lock()
	mock.calls.TSMGetWithArgs = append(mock.calls.TSMGetWithArgs, callInfo)
	mock.lockTSMGetWithArgs.Unlock()
	return mock.TSMGetWithArgsFunc(ctx, filters, options)
}

// TSMGetWithArgsCalls gets all the calls that were made to TSMGetWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.TSMGetWithArgsCalls())
func (mock *GoRedisClientMock) TSMGetWithArgsCalls() []struct {
	Ctx     context.Context
	Filters []string
	Options *redis.TSMGetOptions
} {
	var calls []struct {
		Ctx     context.Context
		Filters []string
		Options *redis.TSMGetOptions
	}
	mock.lockTSMGetWithArgs.RLock()
	calls = mock.calls.TSMGetWithArgs
	mock.lockTSMGetWithArgs.RUnlock()
	return calls
}

// TSMRange calls TSMRangeFunc.
func (mock *GoRedisClientMock) TSMRange(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string) *redis.MapStringSliceInterfaceCmd {
	if mock.TSMRangeFunc == nil {
		panic("GoRedisClientMock.TSMRangeFunc: method is nil but GoRedisClient.TSMRange was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		FromTimestamp int
		ToTimestamp   int
		FilterExpr    []string
	}{
		Ctx:           ctx,
		FromTimestamp: fromTimestamp,
		ToTimestamp:   toTimestamp,
		FilterExpr:    filterExpr,
	}
	mock.lockTSMRange.Lock()
	mock.calls.TSMRange = append(mock.calls.TSMRange, callInfo)
	mock.lockTSMRange.Unlock()
	return mock.TSMRangeFunc(ctx, fromTimestamp, toTimestamp, filterExpr)
}

// TSMRangeCalls gets all the calls that were made to TSMRange.
// Check the length with:
//
//	len(mockedGoRedisClient.TSMRangeCalls())
func (mock *GoRedisClientMock) TSMRangeCalls() []struct {
	Ctx           context.Context
	FromTimestamp int
	ToTimestamp   int
	FilterExpr    []string
} {
	var calls []struct {
		Ctx           context.Context
		FromTimestamp int
		ToTimestamp   int
		FilterExpr    []string
	}
	mock.lockTSMRange.RLock()
	calls = mock.calls.TSMRange
	mock.lockTSMRange.RUnlock()
	return calls
}

// TSMRangeWithArgs calls TSMRangeWithArgsFunc.
func (mock *GoRedisClientMock) TSMRangeWithArgs(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string, options *redis.TSMRangeOptions) *redis.MapStringSliceInterfaceCmd {
	if mock.TSMRangeWithArgsFunc == nil {
		panic("GoRedisClientMock.TSMRangeWithArgsFunc: method is nil but GoRedisClient.TSMRangeWithArgs was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		FromTimestamp int
		ToTimestamp   int
		FilterExpr    []string
		Options       *redis.TSMRangeOptions
	}{
		Ctx:           ctx,
		FromTimestamp: fromTimestamp,
		ToTimestamp:   toTimestamp,
		FilterExpr:    filterExpr,
		Options:       options,
	}
	mock.lockTSMRangeWithArgs.Lock()
	mock.calls.TSMRangeWithArgs = append(mock.calls.TSMRangeWithArgs, callInfo)
	mock.lockTSMRangeWithArgs.Unlock()
	return mock.TSMRangeWithArgsFunc(ctx, fromTimestamp, toTimestamp, filterExpr, options)
}

// TSMRangeWithArgsCalls gets all the calls that were made to TSMRangeWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.TSMRangeWithArgsCalls())
func (mock *GoRedisClientMock) TSMRangeWithArgsCalls() []struct {
	Ctx           context.Context
	FromTimestamp int
	ToTimestamp   int
	FilterExpr    []string
	Options       *redis.TSMRangeOptions
} {
	var calls []struct {
		Ctx           context.Context
		FromTimestamp int
		ToTimestamp   int
		FilterExpr    []string
		Options       *redis.TSMRangeOptions
	}
	mock.lockTSMRangeWithArgs.RLock()
	calls = mock.calls.TSMRangeWithArgs
	mock.lockTSMRangeWithArgs.RUnlock()
	return calls
}

// TSMRevRange calls TSMRevRangeFunc.
func (mock *GoRedisClientMock) TSMRevRange(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string) *redis.MapStringSliceInterfaceCmd {
	if mock.TSMRevRangeFunc == nil {
		panic("GoRedisClientMock.TSMRevRangeFunc: method is nil but GoRedisClient.TSMRevRange was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		FromTimestamp int
		ToTimestamp   int
		FilterExpr    []string
	}{
		Ctx:           ctx,
		FromTimestamp: fromTimestamp,
		ToTimestamp:   toTimestamp,
		FilterExpr:    filterExpr,
	}
	mock.lockTSMRevRange.Lock()
	mock.calls.TSMRevRange = append(mock.calls.TSMRevRange, callInfo)
	mock.lockTSMRevRange.Unlock()
	return mock.TSMRevRangeFunc(ctx, fromTimestamp, toTimestamp, filterExpr)
}

// TSMRevRangeCalls gets all the calls that were made to TSMRevRange.
// Check the length with:
//
//	len(mockedGoRedisClient.TSMRevRangeCalls())
func (mock *GoRedisClientMock) TSMRevRangeCalls() []struct {
	Ctx           context.Context
	FromTimestamp int
	ToTimestamp   int
	FilterExpr    []string
} {
	var calls []struct {
		Ctx           context.Context
		FromTimestamp int
		ToTimestamp   int
		FilterExpr    []string
	}
	mock.lockTSMRevRange.RLock()
	calls = mock.calls.TSMRevRange
	mock.lockTSMRevRange.RUnlock()
	return calls
}

// TSMRevRangeWithArgs calls TSMRevRangeWithArgsFunc.
func (mock *GoRedisClientMock) TSMRevRangeWithArgs(ctx context.Context, fromTimestamp int, toTimestamp int, filterExpr []string, options *redis.TSMRevRangeOptions) *redis.MapStringSliceInterfaceCmd {
	if mock.TSMRevRangeWithArgsFunc == nil {
		panic("GoRedisClientMock.TSMRevRangeWithArgsFunc: method is nil but GoRedisClient.TSMRevRangeWithArgs was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		FromTimestamp int
		ToTimestamp   int
		FilterExpr    []string
		Options       *redis.TSMRevRangeOptions
	}{
		Ctx:           ctx,
		FromTimestamp: fromTimestamp,
		ToTimestamp:   toTimestamp,
		FilterExpr:    filterExpr,
		Options:       options,
	}
	mock.lockTSMRevRangeWithArgs.Lock()
	mock.calls.TSMRevRangeWithArgs = append(mock.calls.TSMRevRangeWithArgs, callInfo)
	mock.lockTSMRevRangeWithArgs.Unlock()
	return mock.TSMRevRangeWithArgsFunc(ctx, fromTimestamp, toTimestamp, filterExpr, options)
}

// TSMRevRangeWithArgsCalls gets all the calls that were made to TSMRevRangeWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.TSMRevRangeWithArgsCalls())
func (mock *GoRedisClientMock) TSMRevRangeWithArgsCalls() []struct {
	Ctx           context.Context
	FromTimestamp int
	ToTimestamp   int
	FilterExpr    []string
	Options       *redis.TSMRevRangeOptions
} {
	var calls []struct {
		Ctx           context.Context
		FromTimestamp int
		ToTimestamp   int
		FilterExpr    []string
		Options       *redis.TSMRevRangeOptions
	}
	mock.lockTSMRevRangeWithArgs.RLock()
	calls = mock.calls.TSMRevRangeWithArgs
	mock.lockTSMRevRangeWithArgs.RUnlock()
	return calls
}

// TSQueryIndex calls TSQueryIndexFunc.
func (mock *GoRedisClientMock) TSQueryIndex(ctx context.Context, filterExpr []string) *redis.StringSliceCmd {
	if mock.TSQueryIndexFunc == nil {
		panic("GoRedisClientMock.TSQueryIndexFunc: method is nil but GoRedisClient.TSQueryIndex was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		FilterExpr []string
	}{
		Ctx:        ctx,
		FilterExpr: filterExpr,
	}
	mock.lockTSQueryIndex.Lock()
	mock.calls.TSQueryIndex = append(mock.calls.TSQueryIndex, callInfo)
	mock.lockTSQueryIndex.Unlock()
	return mock.TSQueryIndexFunc(ctx, filterExpr)
}

// TSQueryIndexCalls gets all the calls that were made to TSQueryIndex.
// Check the length with:
//
//	len(mockedGoRedisClient.TSQueryIndexCalls())
func (mock *GoRedisClientMock) TSQueryIndexCalls() []struct {
	Ctx        context.Context
	FilterExpr []string
} {
	var calls []struct {
		Ctx        context.Context
		FilterExpr []string
	}
	mock.lockTSQueryIndex.RLock()
	calls = mock.calls.TSQueryIndex
	mock.lockTSQueryIndex.RUnlock()
	return calls
}

// TSRange calls TSRangeFunc.
func (mock *GoRedisClientMock) TSRange(ctx context.Context, key string, fromTimestamp int, toTimestamp int) *redis.TSTimestampValueSliceCmd {
	if mock.TSRangeFunc == nil {
		panic("GoRedisClientMock.TSRangeFunc: method is nil but GoRedisClient.TSRange was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Key           string
		FromTimestamp int
		ToTimestamp   int
	}{
		Ctx:           ctx,
		Key:           key,
		FromTimestamp: fromTimestamp,
		ToTimestamp:   toTimestamp,
	}
	mock.lockTSRange.Lock()
	mock.calls.TSRange = append(mock.calls.TSRange, callInfo)
	mock.lockTSRange.Unlock()
	return mock.TSRangeFunc(ctx, key, fromTimestamp, toTimestamp)
}

// TSRangeCalls gets all the calls that were made to TSRange.
// Check the length with:
//
//	len(mockedGoRedisClient.TSRangeCalls())
func (mock *GoRedisClientMock) TSRangeCalls() []struct {
	Ctx           context.Context
	Key           string
	FromTimestamp int
	ToTimestamp   int
} {
	var calls []struct {
		Ctx           context.Context
		Key           string
		FromTimestamp int
		ToTimestamp   int
	}
	mock.lockTSRange.RLock()
	calls = mock.calls.TSRange
	mock.lockTSRange.RUnlock()
	return calls
}

// TSRangeWithArgs calls TSRangeWithArgsFunc.
func (mock *GoRedisClientMock) TSRangeWithArgs(ctx context.Context, key string, fromTimestamp int, toTimestamp int, options *redis.TSRangeOptions) *redis.TSTimestampValueSliceCmd {
	if mock.TSRangeWithArgsFunc == nil {
		panic("GoRedisClientMock.TSRangeWithArgsFunc: method is nil but GoRedisClient.TSRangeWithArgs was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Key           string
		FromTimestamp int
		ToTimestamp   int
		Options       *redis.TSRangeOptions
	}{
		Ctx:           ctx,
		Key:           key,
		FromTimestamp: fromTimestamp,
		ToTimestamp:   toTimestamp,
		Options:       options,
	}
	mock.lockTSRangeWithArgs.Lock()
	mock.calls.TSRangeWithArgs = append(mock.calls.TSRangeWithArgs, callInfo)
	mock.lockTSRangeWithArgs.Unlock()
	return mock.TSRangeWithArgsFunc(ctx, key, fromTimestamp, toTimestamp, options)
}

// TSRangeWithArgsCalls gets all the calls that were made to TSRangeWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.TSRangeWithArgsCalls())
func (mock *GoRedisClientMock) TSRangeWithArgsCalls() []struct {
	Ctx           context.Context
	Key           string
	FromTimestamp int
	ToTimestamp   int
	Options       *redis.TSRangeOptions
} {
	var calls []struct {
		Ctx           context.Context
		Key           string
		FromTimestamp int
		ToTimestamp   int
		Options       *redis.TSRangeOptions
	}
	mock.lockTSRangeWithArgs.RLock()
	calls = mock.calls.TSRangeWithArgs
	mock.lockTSRangeWithArgs.RUnlock()
	return calls
}

// TSRevRange calls TSRevRangeFunc.
func (mock *GoRedisClientMock) TSRevRange(ctx context.Context, key string, fromTimestamp int, toTimestamp int) *redis.TSTimestampValueSliceCmd {
	if mock.TSRevRangeFunc == nil {
		panic("GoRedisClientMock.TSRevRangeFunc: method is nil but GoRedisClient.TSRevRange was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Key           string
		FromTimestamp int
		ToTimestamp   int
	}{
		Ctx:           ctx,
		Key:           key,
		FromTimestamp: fromTimestamp,
		ToTimestamp:   toTimestamp,
	}
	mock.lockTSRevRange.Lock()
	mock.calls.TSRevRange = append(mock.calls.TSRevRange, callInfo)
	mock.lockTSRevRange.Unlock()
	return mock.TSRevRangeFunc(ctx, key, fromTimestamp, toTimestamp)
}

// TSRevRangeCalls gets all the calls that were made to TSRevRange.
// Check the length with:
//
//	len(mockedGoRedisClient.TSRevRangeCalls())
func (mock *GoRedisClientMock) TSRevRangeCalls() []struct {
	Ctx           context.Context
	Key           string
	FromTimestamp int
	ToTimestamp   int
} {
	var calls []struct {
		Ctx           context.Context
		Key           string
		FromTimestamp int
		ToTimestamp   int
	}
	mock.lockTSRevRange.RLock()
	calls = mock.calls.TSRevRange
	mock.lockTSRevRange.RUnlock()
	return calls
}

// TSRevRangeWithArgs calls TSRevRangeWithArgsFunc.
func (mock *GoRedisClientMock) TSRevRangeWithArgs(ctx context.Context, key string, fromTimestamp int, toTimestamp int, options *redis.TSRevRangeOptions) *redis.TSTimestampValueSliceCmd {
	if mock.TSRevRangeWithArgsFunc == nil {
		panic("GoRedisClientMock.TSRevRangeWithArgsFunc: method is nil but GoRedisClient.TSRevRangeWithArgs was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		Key           string
		FromTimestamp int
		ToTimestamp   int
		Options       *redis.TSRevRangeOptions
	}{
		Ctx:           ctx,
		Key:           key,
		FromTimestamp: fromTimestamp,
		ToTimestamp:   toTimestamp,
		Options:       options,
	}
	mock.lockTSRevRangeWithArgs.Lock()
	mock.calls.TSRevRangeWithArgs = append(mock.calls.TSRevRangeWithArgs, callInfo)
	mock.lockTSRevRangeWithArgs.Unlock()
	return mock.TSRevRangeWithArgsFunc(ctx, key, fromTimestamp, toTimestamp, options)
}

// TSRevRangeWithArgsCalls gets all the calls that were made to TSRevRangeWithArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.TSRevRangeWithArgsCalls())
func (mock *GoRedisClientMock) TSRevRangeWithArgsCalls() []struct {
	Ctx           context.Context
	Key           string
	FromTimestamp int
	ToTimestamp   int
	Options       *redis.TSRevRangeOptions
} {
	var calls []struct {
		Ctx           context.Context
		Key           string
		FromTimestamp int
		ToTimestamp   int
		Options       *redis.TSRevRangeOptions
	}
	mock.lockTSRevRangeWithArgs.RLock()
	calls = mock.calls.TSRevRangeWithArgs
	mock.lockTSRevRangeWithArgs.RUnlock()
	return calls
}

// TTL calls TTLFunc.
func (mock *GoRedisClientMock) TTL(ctx context.Context, key string) *redis.DurationCmd {
	if mock.TTLFunc == nil {
		panic("GoRedisClientMock.TTLFunc: method is nil but GoRedisClient.TTL was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTTL.Lock()
	mock.calls.TTL = append(mock.calls.TTL, callInfo)
	mock.lockTTL.Unlock()
	return mock.TTLFunc(ctx, key)
}

// TTLCalls gets all the calls that were made to TTL.
// Check the length with:
//
//	len(mockedGoRedisClient.TTLCalls())
func (mock *GoRedisClientMock) TTLCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTTL.RLock()
	calls = mock.calls.TTL
	mock.lockTTL.RUnlock()
	return calls
}

// Time calls TimeFunc.
func (mock *GoRedisClientMock) Time(ctx context.Context) *redis.TimeCmd {
	if mock.TimeFunc == nil {
		panic("GoRedisClientMock.TimeFunc: method is nil but GoRedisClient.Time was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockTime.Lock()
	mock.calls.Time = append(mock.calls.Time, callInfo)
	mock.lockTime.Unlock()
	return mock.TimeFunc(ctx)
}

// TimeCalls gets all the calls that were made to Time.
// Check the length with:
//
//	len(mockedGoRedisClient.TimeCalls())
func (mock *GoRedisClientMock) TimeCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockTime.RLock()
	calls = mock.calls.Time
	mock.lockTime.RUnlock()
	return calls
}

// TopKAdd calls TopKAddFunc.
func (mock *GoRedisClientMock) TopKAdd(ctx context.Context, key string, elements ...interface{}) *redis.StringSliceCmd {
	if mock.TopKAddFunc == nil {
		panic("GoRedisClientMock.TopKAddFunc: method is nil but GoRedisClient.TopKAdd was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockTopKAdd.Lock()
	mock.calls.TopKAdd = append(mock.calls.TopKAdd, callInfo)
	mock.lockTopKAdd.Unlock()
	return mock.TopKAddFunc(ctx, key, elements...)
}

// TopKAddCalls gets all the calls that were made to TopKAdd.
// Check the length with:
//
//	len(mockedGoRedisClient.TopKAddCalls())
func (mock *GoRedisClientMock) TopKAddCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}
	mock.lockTopKAdd.RLock()
	calls = mock.calls.TopKAdd
	mock.lockTopKAdd.RUnlock()
	return calls
}

// TopKCount calls TopKCountFunc.
func (mock *GoRedisClientMock) TopKCount(ctx context.Context, key string, elements ...interface{}) *redis.IntSliceCmd {
	if mock.TopKCountFunc == nil {
		panic("GoRedisClientMock.TopKCountFunc: method is nil but GoRedisClient.TopKCount was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockTopKCount.Lock()
	mock.calls.TopKCount = append(mock.calls.TopKCount, callInfo)
	mock.lockTopKCount.Unlock()
	return mock.TopKCountFunc(ctx, key, elements...)
}

// TopKCountCalls gets all the calls that were made to TopKCount.
// Check the length with:
//
//	len(mockedGoRedisClient.TopKCountCalls())
func (mock *GoRedisClientMock) TopKCountCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}
	mock.lockTopKCount.RLock()
	calls = mock.calls.TopKCount
	mock.lockTopKCount.RUnlock()
	return calls
}

// TopKIncrBy calls TopKIncrByFunc.
func (mock *GoRedisClientMock) TopKIncrBy(ctx context.Context, key string, elements ...interface{}) *redis.StringSliceCmd {
	if mock.TopKIncrByFunc == nil {
		panic("GoRedisClientMock.TopKIncrByFunc: method is nil but GoRedisClient.TopKIncrBy was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockTopKIncrBy.Lock()
	mock.calls.TopKIncrBy = append(mock.calls.TopKIncrBy, callInfo)
	mock.lockTopKIncrBy.Unlock()
	return mock.TopKIncrByFunc(ctx, key, elements...)
}

// TopKIncrByCalls gets all the calls that were made to TopKIncrBy.
// Check the length with:
//
//	len(mockedGoRedisClient.TopKIncrByCalls())
func (mock *GoRedisClientMock) TopKIncrByCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}
	mock.lockTopKIncrBy.RLock()
	calls = mock.calls.TopKIncrBy
	mock.lockTopKIncrBy.RUnlock()
	return calls
}

// TopKInfo calls TopKInfoFunc.
func (mock *GoRedisClientMock) TopKInfo(ctx context.Context, key string) *redis.TopKInfoCmd {
	if mock.TopKInfoFunc == nil {
		panic("GoRedisClientMock.TopKInfoFunc: method is nil but GoRedisClient.TopKInfo was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTopKInfo.Lock()
	mock.calls.TopKInfo = append(mock.calls.TopKInfo, callInfo)
	mock.lockTopKInfo.Unlock()
	return mock.TopKInfoFunc(ctx, key)
}

// TopKInfoCalls gets all the calls that were made to TopKInfo.
// Check the length with:
//
//	len(mockedGoRedisClient.TopKInfoCalls())
func (mock *GoRedisClientMock) TopKInfoCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTopKInfo.RLock()
	calls = mock.calls.TopKInfo
	mock.lockTopKInfo.RUnlock()
	return calls
}

// TopKList calls TopKListFunc.
func (mock *GoRedisClientMock) TopKList(ctx context.Context, key string) *redis.StringSliceCmd {
	if mock.TopKListFunc == nil {
		panic("GoRedisClientMock.TopKListFunc: method is nil but GoRedisClient.TopKList was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTopKList.Lock()
	mock.calls.TopKList = append(mock.calls.TopKList, callInfo)
	mock.lockTopKList.Unlock()
	return mock.TopKListFunc(ctx, key)
}

// TopKListCalls gets all the calls that were made to TopKList.
// Check the length with:
//
//	len(mockedGoRedisClient.TopKListCalls())
func (mock *GoRedisClientMock) TopKListCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTopKList.RLock()
	calls = mock.calls.TopKList
	mock.lockTopKList.RUnlock()
	return calls
}

// TopKListWithCount calls TopKListWithCountFunc.
func (mock *GoRedisClientMock) TopKListWithCount(ctx context.Context, key string) *redis.MapStringIntCmd {
	if mock.TopKListWithCountFunc == nil {
		panic("GoRedisClientMock.TopKListWithCountFunc: method is nil but GoRedisClient.TopKListWithCount was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockTopKListWithCount.Lock()
	mock.calls.TopKListWithCount = append(mock.calls.TopKListWithCount, callInfo)
	mock.lockTopKListWithCount.Unlock()
	return mock.TopKListWithCountFunc(ctx, key)
}

// TopKListWithCountCalls gets all the calls that were made to TopKListWithCount.
// Check the length with:
//
//	len(mockedGoRedisClient.TopKListWithCountCalls())
func (mock *GoRedisClientMock) TopKListWithCountCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockTopKListWithCount.RLock()
	calls = mock.calls.TopKListWithCount
	mock.lockTopKListWithCount.RUnlock()
	return calls
}

// TopKQuery calls TopKQueryFunc.
func (mock *GoRedisClientMock) TopKQuery(ctx context.Context, key string, elements ...interface{}) *redis.BoolSliceCmd {
	if mock.TopKQueryFunc == nil {
		panic("GoRedisClientMock.TopKQueryFunc: method is nil but GoRedisClient.TopKQuery was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}{
		Ctx:      ctx,
		Key:      key,
		Elements: elements,
	}
	mock.lockTopKQuery.Lock()
	mock.calls.TopKQuery = append(mock.calls.TopKQuery, callInfo)
	mock.lockTopKQuery.Unlock()
	return mock.TopKQueryFunc(ctx, key, elements...)
}

// TopKQueryCalls gets all the calls that were made to TopKQuery.
// Check the length with:
//
//	len(mockedGoRedisClient.TopKQueryCalls())
func (mock *GoRedisClientMock) TopKQueryCalls() []struct {
	Ctx      context.Context
	Key      string
	Elements []interface{}
} {
	var calls []struct {
		Ctx      context.Context
		Key      string
		Elements []interface{}
	}
	mock.lockTopKQuery.RLock()
	calls = mock.calls.TopKQuery
	mock.lockTopKQuery.RUnlock()
	return calls
}

// TopKReserve calls TopKReserveFunc.
func (mock *GoRedisClientMock) TopKReserve(ctx context.Context, key string, k int64) *redis.StatusCmd {
	if mock.TopKReserveFunc == nil {
		panic("GoRedisClientMock.TopKReserveFunc: method is nil but GoRedisClient.TopKReserve was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		K   int64
	}{
		Ctx: ctx,
		Key: key,
		K:   k,
	}
	mock.lockTopKReserve.Lock()
	mock.calls.TopKReserve = append(mock.calls.TopKReserve, callInfo)
	mock.lockTopKReserve.Unlock()
	return mock.TopKReserveFunc(ctx, key, k)
}

// TopKReserveCalls gets all the calls that were made to TopKReserve.
// Check the length with:
//
//	len(mockedGoRedisClient.TopKReserveCalls())
func (mock *GoRedisClientMock) TopKReserveCalls() []struct {
	Ctx context.Context
	Key string
	K   int64
} {
	var calls []struct {
		Ctx context.Context
		Key string
		K   int64
	}
	mock.lockTopKReserve.RLock()
	calls = mock.calls.TopKReserve
	mock.lockTopKReserve.RUnlock()
	return calls
}

// TopKReserveWithOptions calls TopKReserveWithOptionsFunc.
func (mock *GoRedisClientMock) TopKReserveWithOptions(ctx context.Context, key string, k int64, width int64, depth int64, decay float64) *redis.StatusCmd {
	if mock.TopKReserveWithOptionsFunc == nil {
		panic("GoRedisClientMock.TopKReserveWithOptionsFunc: method is nil but GoRedisClient.TopKReserveWithOptions was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		K     int64
		Width int64
		Depth int64
		Decay float64
	}{
		Ctx:   ctx,
		Key:   key,
		K:     k,
		Width: width,
		Depth: depth,
		Decay: decay,
	}
	mock.lockTopKReserveWithOptions.Lock()
	mock.calls.TopKReserveWithOptions = append(mock.calls.TopKReserveWithOptions, callInfo)
	mock.lockTopKReserveWithOptions.Unlock()
	return mock.TopKReserveWithOptionsFunc(ctx, key, k, width, depth, decay)
}

// TopKReserveWithOptionsCalls gets all the calls that were made to TopKReserveWithOptions.
// Check the length with:
//
//	len(mockedGoRedisClient.TopKReserveWithOptionsCalls())
func (mock *GoRedisClientMock) TopKReserveWithOptionsCalls() []struct {
	Ctx   context.Context
	Key   string
	K     int64
	Width int64
	Depth int64
	Decay float64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		K     int64
		Width int64
		Depth int64
		Decay float64
	}
	mock.lockTopKReserveWithOptions.RLock()
	calls = mock.calls.TopKReserveWithOptions
	mock.lockTopKReserveWithOptions.RUnlock()
	return calls
}

// Touch calls TouchFunc.
func (mock *GoRedisClientMock) Touch(ctx context.Context, keys ...string) *redis.IntCmd {
	if mock.TouchFunc == nil {
		panic("GoRedisClientMock.TouchFunc: method is nil but GoRedisClient.Touch was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockTouch.Lock()
	mock.calls.Touch = append(mock.calls.Touch, callInfo)
	mock.lockTouch.Unlock()
	return mock.TouchFunc(ctx, keys...)
}

// TouchCalls gets all the calls that were made to Touch.
// Check the length with:
//
//	len(mockedGoRedisClient.TouchCalls())
func (mock *GoRedisClientMock) TouchCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockTouch.RLock()
	calls = mock.calls.Touch
	mock.lockTouch.RUnlock()
	return calls
}

// TxPipeline calls TxPipelineFunc.
func (mock *GoRedisClientMock) TxPipeline() redis.Pipeliner {
	if mock.TxPipelineFunc == nil {
		panic("GoRedisClientMock.TxPipelineFunc: method is nil but GoRedisClient.TxPipeline was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTxPipeline.Lock()
	mock.calls.TxPipeline = append(mock.calls.TxPipeline, callInfo)
	mock.lockTxPipeline.Unlock()
	return mock.TxPipelineFunc()
}

// TxPipelineCalls gets all the calls that were made to TxPipeline.
// Check the length with:
//
//	len(mockedGoRedisClient.TxPipelineCalls())
func (mock *GoRedisClientMock) TxPipelineCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTxPipeline.RLock()
	calls = mock.calls.TxPipeline
	mock.lockTxPipeline.RUnlock()
	return calls
}

// TxPipelined calls TxPipelinedFunc.
func (mock *GoRedisClientMock) TxPipelined(ctx context.Context, fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
	if mock.TxPipelinedFunc == nil {
		panic("GoRedisClientMock.TxPipelinedFunc: method is nil but GoRedisClient.TxPipelined was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Fn  func(redis.Pipeliner) error
	}{
		Ctx: ctx,
		Fn:  fn,
	}
	mock.lockTxPipelined.Lock()
	mock.calls.TxPipelined = append(mock.calls.TxPipelined, callInfo)
	mock.lockTxPipelined.Unlock()
	return mock.TxPipelinedFunc(ctx, fn)
}

// TxPipelinedCalls gets all the calls that were made to TxPipelined.
// Check the length with:
//
//	len(mockedGoRedisClient.TxPipelinedCalls())
func (mock *GoRedisClientMock) TxPipelinedCalls() []struct {
	Ctx context.Context
	Fn  func(redis.Pipeliner) error
} {
	var calls []struct {
		Ctx context.Context
		Fn  func(redis.Pipeliner) error
	}
	mock.lockTxPipelined.RLock()
	calls = mock.calls.TxPipelined
	mock.lockTxPipelined.RUnlock()
	return calls
}

// Type calls TypeFunc.
func (mock *GoRedisClientMock) Type(ctx context.Context, key string) *redis.StatusCmd {
	if mock.TypeFunc == nil {
		panic("GoRedisClientMock.TypeFunc: method is nil but GoRedisClient.Type was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockType.Lock()
	mock.calls.Type = append(mock.calls.Type, callInfo)
	mock.lockType.Unlock()
	return mock.TypeFunc(ctx, key)
}

// TypeCalls gets all the calls that were made to Type.
// Check the length with:
//
//	len(mockedGoRedisClient.TypeCalls())
func (mock *GoRedisClientMock) TypeCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockType.RLock()
	calls = mock.calls.Type
	mock.lockType.RUnlock()
	return calls
}

// Unlink calls UnlinkFunc.
func (mock *GoRedisClientMock) Unlink(ctx context.Context, keys ...string) *redis.IntCmd {
	if mock.UnlinkFunc == nil {
		panic("GoRedisClientMock.UnlinkFunc: method is nil but GoRedisClient.Unlink was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockUnlink.Lock()
	mock.calls.Unlink = append(mock.calls.Unlink, callInfo)
	mock.lockUnlink.Unlock()
	return mock.UnlinkFunc(ctx, keys...)
}

// UnlinkCalls gets all the calls that were made to Unlink.
// Check the length with:
//
//	len(mockedGoRedisClient.UnlinkCalls())
func (mock *GoRedisClientMock) UnlinkCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockUnlink.RLock()
	calls = mock.calls.Unlink
	mock.lockUnlink.RUnlock()
	return calls
}

// Watch calls WatchFunc.
func (mock *GoRedisClientMock) Watch(ctx context.Context, fn func(*redis.Tx) error, keys ...string) error {
	if mock.WatchFunc == nil {
		panic("GoRedisClientMock.WatchFunc: method is nil but GoRedisClient.Watch was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Fn   func(*redis.Tx) error
		Keys []string
	}{
		Ctx:  ctx,
		Fn:   fn,
		Keys: keys,
	}
	mock.lockWatch.Lock()
	mock.calls.Watch = append(mock.calls.Watch, callInfo)
	mock.lockWatch.Unlock()
	return mock.WatchFunc(ctx, fn, keys...)
}

// WatchCalls gets all the calls that were made to Watch.
// Check the length with:
//
//	len(mockedGoRedisClient.WatchCalls())
func (mock *GoRedisClientMock) WatchCalls() []struct {
	Ctx  context.Context
	Fn   func(*redis.Tx) error
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Fn   func(*redis.Tx) error
		Keys []string
	}
	mock.lockWatch.RLock()
	calls = mock.calls.Watch
	mock.lockWatch.RUnlock()
	return calls
}

// XAck calls XAckFunc.
func (mock *GoRedisClientMock) XAck(ctx context.Context, stream string, group string, ids ...string) *redis.IntCmd {
	if mock.XAckFunc == nil {
		panic("GoRedisClientMock.XAckFunc: method is nil but GoRedisClient.XAck was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Group  string
		Ids    []string
	}{
		Ctx:    ctx,
		Stream: stream,
		Group:  group,
		Ids:    ids,
	}
	mock.lockXAck.Lock()
	mock.calls.XAck = append(mock.calls.XAck, callInfo)
	mock.lockXAck.Unlock()
	return mock.XAckFunc(ctx, stream, group, ids...)
}

// XAckCalls gets all the calls that were made to XAck.
// Check the length with:
//
//	len(mockedGoRedisClient.XAckCalls())
func (mock *GoRedisClientMock) XAckCalls() []struct {
	Ctx    context.Context
	Stream string
	Group  string
	Ids    []string
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Group  string
		Ids    []string
	}
	mock.lockXAck.RLock()
	calls = mock.calls.XAck
	mock.lockXAck.RUnlock()
	return calls
}

// XAdd calls XAddFunc.
func (mock *GoRedisClientMock) XAdd(ctx context.Context, a *redis.XAddArgs) *redis.StringCmd {
	if mock.XAddFunc == nil {
		panic("GoRedisClientMock.XAddFunc: method is nil but GoRedisClient.XAdd was just called")
	}
	callInfo := struct {
		Ctx context.Context
		A   *redis.XAddArgs
	}{
		Ctx: ctx,
		A:   a,
	}
	mock.lockXAdd.Lock()
	mock.calls.XAdd = append(mock.calls.XAdd, callInfo)
	mock.lockXAdd.Unlock()
	return mock.XAddFunc(ctx, a)
}

// XAddCalls gets all the calls that were made to XAdd.
// Check the length with:
//
//	len(mockedGoRedisClient.XAddCalls())
func (mock *GoRedisClientMock) XAddCalls() []struct {
	Ctx context.Context
	A   *redis.XAddArgs
} {
	var calls []struct {
		Ctx context.Context
		A   *redis.XAddArgs
	}
	mock.lockXAdd.RLock()
	calls = mock.calls.XAdd
	mock.lockXAdd.RUnlock()
	return calls
}

// XAutoClaim calls XAutoClaimFunc.
func (mock *GoRedisClientMock) XAutoClaim(ctx context.Context, a *redis.XAutoClaimArgs) *redis.XAutoClaimCmd {
	if mock.XAutoClaimFunc == nil {
		panic("GoRedisClientMock.XAutoClaimFunc: method is nil but GoRedisClient.XAutoClaim was just called")
	}
	callInfo := struct {
		Ctx context.Context
		A   *redis.XAutoClaimArgs
	}{
		Ctx: ctx,
		A:   a,
	}
	mock.lockXAutoClaim.Lock()
	mock.calls.XAutoClaim = append(mock.calls.XAutoClaim, callInfo)
	mock.lockXAutoClaim.Unlock()
	return mock.XAutoClaimFunc(ctx, a)
}

// XAutoClaimCalls gets all the calls that were made to XAutoClaim.
// Check the length with:
//
//	len(mockedGoRedisClient.XAutoClaimCalls())
func (mock *GoRedisClientMock) XAutoClaimCalls() []struct {
	Ctx context.Context
	A   *redis.XAutoClaimArgs
} {
	var calls []struct {
		Ctx context.Context
		A   *redis.XAutoClaimArgs
	}
	mock.lockXAutoClaim.RLock()
	calls = mock.calls.XAutoClaim
	mock.lockXAutoClaim.RUnlock()
	return calls
}

// XAutoClaimJustID calls XAutoClaimJustIDFunc.
func (mock *GoRedisClientMock) XAutoClaimJustID(ctx context.Context, a *redis.XAutoClaimArgs) *redis.XAutoClaimJustIDCmd {
	if mock.XAutoClaimJustIDFunc == nil {
		panic("GoRedisClientMock.XAutoClaimJustIDFunc: method is nil but GoRedisClient.XAutoClaimJustID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		A   *redis.XAutoClaimArgs
	}{
		Ctx: ctx,
		A:   a,
	}
	mock.lockXAutoClaimJustID.Lock()
	mock.calls.XAutoClaimJustID = append(mock.calls.XAutoClaimJustID, callInfo)
	mock.lockXAutoClaimJustID.Unlock()
	return mock.XAutoClaimJustIDFunc(ctx, a)
}

// XAutoClaimJustIDCalls gets all the calls that were made to XAutoClaimJustID.
// Check the length with:
//
//	len(mockedGoRedisClient.XAutoClaimJustIDCalls())
func (mock *GoRedisClientMock) XAutoClaimJustIDCalls() []struct {
	Ctx context.Context
	A   *redis.XAutoClaimArgs
} {
	var calls []struct {
		Ctx context.Context
		A   *redis.XAutoClaimArgs
	}
	mock.lockXAutoClaimJustID.RLock()
	calls = mock.calls.XAutoClaimJustID
	mock.lockXAutoClaimJustID.RUnlock()
	return calls
}

// XClaim calls XClaimFunc.
func (mock *GoRedisClientMock) XClaim(ctx context.Context, a *redis.XClaimArgs) *redis.XMessageSliceCmd {
	if mock.XClaimFunc == nil {
		panic("GoRedisClientMock.XClaimFunc: method is nil but GoRedisClient.XClaim was just called")
	}
	callInfo := struct {
		Ctx context.Context
		A   *redis.XClaimArgs
	}{
		Ctx: ctx,
		A:   a,
	}
	mock.lockXClaim.Lock()
	mock.calls.XClaim = append(mock.calls.XClaim, callInfo)
	mock.lockXClaim.Unlock()
	return mock.XClaimFunc(ctx, a)
}

// XClaimCalls gets all the calls that were made to XClaim.
// Check the length with:
//
//	len(mockedGoRedisClient.XClaimCalls())
func (mock *GoRedisClientMock) XClaimCalls() []struct {
	Ctx context.Context
	A   *redis.XClaimArgs
} {
	var calls []struct {
		Ctx context.Context
		A   *redis.XClaimArgs
	}
	mock.lockXClaim.RLock()
	calls = mock.calls.XClaim
	mock.lockXClaim.RUnlock()
	return calls
}

// XClaimJustID calls XClaimJustIDFunc.
func (mock *GoRedisClientMock) XClaimJustID(ctx context.Context, a *redis.XClaimArgs) *redis.StringSliceCmd {
	if mock.XClaimJustIDFunc == nil {
		panic("GoRedisClientMock.XClaimJustIDFunc: method is nil but GoRedisClient.XClaimJustID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		A   *redis.XClaimArgs
	}{
		Ctx: ctx,
		A:   a,
	}
	mock.lockXClaimJustID.Lock()
	mock.calls.XClaimJustID = append(mock.calls.XClaimJustID, callInfo)
	mock.lockXClaimJustID.Unlock()
	return mock.XClaimJustIDFunc(ctx, a)
}

// XClaimJustIDCalls gets all the calls that were made to XClaimJustID.
// Check the length with:
//
//	len(mockedGoRedisClient.XClaimJustIDCalls())
func (mock *GoRedisClientMock) XClaimJustIDCalls() []struct {
	Ctx context.Context
	A   *redis.XClaimArgs
} {
	var calls []struct {
		Ctx context.Context
		A   *redis.XClaimArgs
	}
	mock.lockXClaimJustID.RLock()
	calls = mock.calls.XClaimJustID
	mock.lockXClaimJustID.RUnlock()
	return calls
}

// XDel calls XDelFunc.
func (mock *GoRedisClientMock) XDel(ctx context.Context, stream string, ids ...string) *redis.IntCmd {
	if mock.XDelFunc == nil {
		panic("GoRedisClientMock.XDelFunc: method is nil but GoRedisClient.XDel was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Ids    []string
	}{
		Ctx:    ctx,
		Stream: stream,
		Ids:    ids,
	}
	mock.lockXDel.Lock()
	mock.calls.XDel = append(mock.calls.XDel, callInfo)
	mock.lockXDel.Unlock()
	return mock.XDelFunc(ctx, stream, ids...)
}

// XDelCalls gets all the calls that were made to XDel.
// Check the length with:
//
//	len(mockedGoRedisClient.XDelCalls())
func (mock *GoRedisClientMock) XDelCalls() []struct {
	Ctx    context.Context
	Stream string
	Ids    []string
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Ids    []string
	}
	mock.lockXDel.RLock()
	calls = mock.calls.XDel
	mock.lockXDel.RUnlock()
	return calls
}

// XGroupCreate calls XGroupCreateFunc.
func (mock *GoRedisClientMock) XGroupCreate(ctx context.Context, stream string, group string, start string) *redis.StatusCmd {
	if mock.XGroupCreateFunc == nil {
		panic("GoRedisClientMock.XGroupCreateFunc: method is nil but GoRedisClient.XGroupCreate was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Group  string
		Start  string
	}{
		Ctx:    ctx,
		Stream: stream,
		Group:  group,
		Start:  start,
	}
	mock.lockXGroupCreate.Lock()
	mock.calls.XGroupCreate = append(mock.calls.XGroupCreate, callInfo)
	mock.lockXGroupCreate.Unlock()
	return mock.XGroupCreateFunc(ctx, stream, group, start)
}

// XGroupCreateCalls gets all the calls that were made to XGroupCreate.
// Check the length with:
//
//	len(mockedGoRedisClient.XGroupCreateCalls())
func (mock *GoRedisClientMock) XGroupCreateCalls() []struct {
	Ctx    context.Context
	Stream string
	Group  string
	Start  string
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Group  string
		Start  string
	}
	mock.lockXGroupCreate.RLock()
	calls = mock.calls.XGroupCreate
	mock.lockXGroupCreate.RUnlock()
	return calls
}

// XGroupCreateConsumer calls XGroupCreateConsumerFunc.
func (mock *GoRedisClientMock) XGroupCreateConsumer(ctx context.Context, stream string, group string, consumer string) *redis.IntCmd {
	if mock.XGroupCreateConsumerFunc == nil {
		panic("GoRedisClientMock.XGroupCreateConsumerFunc: method is nil but GoRedisClient.XGroupCreateConsumer was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Stream   string
		Group    string
		Consumer string
	}{
		Ctx:      ctx,
		Stream:   stream,
		Group:    group,
		Consumer: consumer,
	}
	mock.lockXGroupCreateConsumer.Lock()
	mock.calls.XGroupCreateConsumer = append(mock.calls.XGroupCreateConsumer, callInfo)
	mock.lockXGroupCreateConsumer.Unlock()
	return mock.XGroupCreateConsumerFunc(ctx, stream, group, consumer)
}

// XGroupCreateConsumerCalls gets all the calls that were made to XGroupCreateConsumer.
// Check the length with:
//
//	len(mockedGoRedisClient.XGroupCreateConsumerCalls())
func (mock *GoRedisClientMock) XGroupCreateConsumerCalls() []struct {
	Ctx      context.Context
	Stream   string
	Group    string
	Consumer string
} {
	var calls []struct {
		Ctx      context.Context
		Stream   string
		Group    string
		Consumer string
	}
	mock.lockXGroupCreateConsumer.RLock()
	calls = mock.calls.XGroupCreateConsumer
	mock.lockXGroupCreateConsumer.RUnlock()
	return calls
}

// XGroupCreateMkStream calls XGroupCreateMkStreamFunc.
func (mock *GoRedisClientMock) XGroupCreateMkStream(ctx context.Context, stream string, group string, start string) *redis.StatusCmd {
	if mock.XGroupCreateMkStreamFunc == nil {
		panic("GoRedisClientMock.XGroupCreateMkStreamFunc: method is nil but GoRedisClient.XGroupCreateMkStream was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Group  string
		Start  string
	}{
		Ctx:    ctx,
		Stream: stream,
		Group:  group,
		Start:  start,
	}
	mock.lockXGroupCreateMkStream.Lock()
	mock.calls.XGroupCreateMkStream = append(mock.calls.XGroupCreateMkStream, callInfo)
	mock.lockXGroupCreateMkStream.Unlock()
	return mock.XGroupCreateMkStreamFunc(ctx, stream, group, start)
}

// XGroupCreateMkStreamCalls gets all the calls that were made to XGroupCreateMkStream.
// Check the length with:
//
//	len(mockedGoRedisClient.XGroupCreateMkStreamCalls())
func (mock *GoRedisClientMock) XGroupCreateMkStreamCalls() []struct {
	Ctx    context.Context
	Stream string
	Group  string
	Start  string
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Group  string
		Start  string
	}
	mock.lockXGroupCreateMkStream.RLock()
	calls = mock.calls.XGroupCreateMkStream
	mock.lockXGroupCreateMkStream.RUnlock()
	return calls
}

// XGroupDelConsumer calls XGroupDelConsumerFunc.
func (mock *GoRedisClientMock) XGroupDelConsumer(ctx context.Context, stream string, group string, consumer string) *redis.IntCmd {
	if mock.XGroupDelConsumerFunc == nil {
		panic("GoRedisClientMock.XGroupDelConsumerFunc: method is nil but GoRedisClient.XGroupDelConsumer was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Stream   string
		Group    string
		Consumer string
	}{
		Ctx:      ctx,
		Stream:   stream,
		Group:    group,
		Consumer: consumer,
	}
	mock.lockXGroupDelConsumer.Lock()
	mock.calls.XGroupDelConsumer = append(mock.calls.XGroupDelConsumer, callInfo)
	mock.lockXGroupDelConsumer.Unlock()
	return mock.XGroupDelConsumerFunc(ctx, stream, group, consumer)
}

// XGroupDelConsumerCalls gets all the calls that were made to XGroupDelConsumer.
// Check the length with:
//
//	len(mockedGoRedisClient.XGroupDelConsumerCalls())
func (mock *GoRedisClientMock) XGroupDelConsumerCalls() []struct {
	Ctx      context.Context
	Stream   string
	Group    string
	Consumer string
} {
	var calls []struct {
		Ctx      context.Context
		Stream   string
		Group    string
		Consumer string
	}
	mock.lockXGroupDelConsumer.RLock()
	calls = mock.calls.XGroupDelConsumer
	mock.lockXGroupDelConsumer.RUnlock()
	return calls
}

// XGroupDestroy calls XGroupDestroyFunc.
func (mock *GoRedisClientMock) XGroupDestroy(ctx context.Context, stream string, group string) *redis.IntCmd {
	if mock.XGroupDestroyFunc == nil {
		panic("GoRedisClientMock.XGroupDestroyFunc: method is nil but GoRedisClient.XGroupDestroy was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Group  string
	}{
		Ctx:    ctx,
		Stream: stream,
		Group:  group,
	}
	mock.lockXGroupDestroy.Lock()
	mock.calls.XGroupDestroy = append(mock.calls.XGroupDestroy, callInfo)
	mock.lockXGroupDestroy.Unlock()
	return mock.XGroupDestroyFunc(ctx, stream, group)
}

// XGroupDestroyCalls gets all the calls that were made to XGroupDestroy.
// Check the length with:
//
//	len(mockedGoRedisClient.XGroupDestroyCalls())
func (mock *GoRedisClientMock) XGroupDestroyCalls() []struct {
	Ctx    context.Context
	Stream string
	Group  string
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Group  string
	}
	mock.lockXGroupDestroy.RLock()
	calls = mock.calls.XGroupDestroy
	mock.lockXGroupDestroy.RUnlock()
	return calls
}

// XGroupSetID calls XGroupSetIDFunc.
func (mock *GoRedisClientMock) XGroupSetID(ctx context.Context, stream string, group string, start string) *redis.StatusCmd {
	if mock.XGroupSetIDFunc == nil {
		panic("GoRedisClientMock.XGroupSetIDFunc: method is nil but GoRedisClient.XGroupSetID was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Group  string
		Start  string
	}{
		Ctx:    ctx,
		Stream: stream,
		Group:  group,
		Start:  start,
	}
	mock.lockXGroupSetID.Lock()
	mock.calls.XGroupSetID = append(mock.calls.XGroupSetID, callInfo)
	mock.lockXGroupSetID.Unlock()
	return mock.XGroupSetIDFunc(ctx, stream, group, start)
}

// XGroupSetIDCalls gets all the calls that were made to XGroupSetID.
// Check the length with:
//
//	len(mockedGoRedisClient.XGroupSetIDCalls())
func (mock *GoRedisClientMock) XGroupSetIDCalls() []struct {
	Ctx    context.Context
	Stream string
	Group  string
	Start  string
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Group  string
		Start  string
	}
	mock.lockXGroupSetID.RLock()
	calls = mock.calls.XGroupSetID
	mock.lockXGroupSetID.RUnlock()
	return calls
}

// XInfoConsumers calls XInfoConsumersFunc.
func (mock *GoRedisClientMock) XInfoConsumers(ctx context.Context, key string, group string) *redis.XInfoConsumersCmd {
	if mock.XInfoConsumersFunc == nil {
		panic("GoRedisClientMock.XInfoConsumersFunc: method is nil but GoRedisClient.XInfoConsumers was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Group string
	}{
		Ctx:   ctx,
		Key:   key,
		Group: group,
	}
	mock.lockXInfoConsumers.Lock()
	mock.calls.XInfoConsumers = append(mock.calls.XInfoConsumers, callInfo)
	mock.lockXInfoConsumers.Unlock()
	return mock.XInfoConsumersFunc(ctx, key, group)
}

// XInfoConsumersCalls gets all the calls that were made to XInfoConsumers.
// Check the length with:
//
//	len(mockedGoRedisClient.XInfoConsumersCalls())
func (mock *GoRedisClientMock) XInfoConsumersCalls() []struct {
	Ctx   context.Context
	Key   string
	Group string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Group string
	}
	mock.lockXInfoConsumers.RLock()
	calls = mock.calls.XInfoConsumers
	mock.lockXInfoConsumers.RUnlock()
	return calls
}

// XInfoGroups calls XInfoGroupsFunc.
func (mock *GoRedisClientMock) XInfoGroups(ctx context.Context, key string) *redis.XInfoGroupsCmd {
	if mock.XInfoGroupsFunc == nil {
		panic("GoRedisClientMock.XInfoGroupsFunc: method is nil but GoRedisClient.XInfoGroups was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockXInfoGroups.Lock()
	mock.calls.XInfoGroups = append(mock.calls.XInfoGroups, callInfo)
	mock.lockXInfoGroups.Unlock()
	return mock.XInfoGroupsFunc(ctx, key)
}

// XInfoGroupsCalls gets all the calls that were made to XInfoGroups.
// Check the length with:
//
//	len(mockedGoRedisClient.XInfoGroupsCalls())
func (mock *GoRedisClientMock) XInfoGroupsCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockXInfoGroups.RLock()
	calls = mock.calls.XInfoGroups
	mock.lockXInfoGroups.RUnlock()
	return calls
}

// XInfoStream calls XInfoStreamFunc.
func (mock *GoRedisClientMock) XInfoStream(ctx context.Context, key string) *redis.XInfoStreamCmd {
	if mock.XInfoStreamFunc == nil {
		panic("GoRedisClientMock.XInfoStreamFunc: method is nil but GoRedisClient.XInfoStream was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockXInfoStream.Lock()
	mock.calls.XInfoStream = append(mock.calls.XInfoStream, callInfo)
	mock.lockXInfoStream.Unlock()
	return mock.XInfoStreamFunc(ctx, key)
}

// XInfoStreamCalls gets all the calls that were made to XInfoStream.
// Check the length with:
//
//	len(mockedGoRedisClient.XInfoStreamCalls())
func (mock *GoRedisClientMock) XInfoStreamCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockXInfoStream.RLock()
	calls = mock.calls.XInfoStream
	mock.lockXInfoStream.RUnlock()
	return calls
}

// XInfoStreamFull calls XInfoStreamFullFunc.
func (mock *GoRedisClientMock) XInfoStreamFull(ctx context.Context, key string, count int) *redis.XInfoStreamFullCmd {
	if mock.XInfoStreamFullFunc == nil {
		panic("GoRedisClientMock.XInfoStreamFullFunc: method is nil but GoRedisClient.XInfoStreamFull was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count int
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
	}
	mock.lockXInfoStreamFull.Lock()
	mock.calls.XInfoStreamFull = append(mock.calls.XInfoStreamFull, callInfo)
	mock.lockXInfoStreamFull.Unlock()
	return mock.XInfoStreamFullFunc(ctx, key, count)
}

// XInfoStreamFullCalls gets all the calls that were made to XInfoStreamFull.
// Check the length with:
//
//	len(mockedGoRedisClient.XInfoStreamFullCalls())
func (mock *GoRedisClientMock) XInfoStreamFullCalls() []struct {
	Ctx   context.Context
	Key   string
	Count int
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count int
	}
	mock.lockXInfoStreamFull.RLock()
	calls = mock.calls.XInfoStreamFull
	mock.lockXInfoStreamFull.RUnlock()
	return calls
}

// XLen calls XLenFunc.
func (mock *GoRedisClientMock) XLen(ctx context.Context, stream string) *redis.IntCmd {
	if mock.XLenFunc == nil {
		panic("GoRedisClientMock.XLenFunc: method is nil but GoRedisClient.XLen was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
	}{
		Ctx:    ctx,
		Stream: stream,
	}
	mock.lockXLen.Lock()
	mock.calls.XLen = append(mock.calls.XLen, callInfo)
	mock.lockXLen.Unlock()
	return mock.XLenFunc(ctx, stream)
}

// XLenCalls gets all the calls that were made to XLen.
// Check the length with:
//
//	len(mockedGoRedisClient.XLenCalls())
func (mock *GoRedisClientMock) XLenCalls() []struct {
	Ctx    context.Context
	Stream string
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
	}
	mock.lockXLen.RLock()
	calls = mock.calls.XLen
	mock.lockXLen.RUnlock()
	return calls
}

// XPending calls XPendingFunc.
func (mock *GoRedisClientMock) XPending(ctx context.Context, stream string, group string) *redis.XPendingCmd {
	if mock.XPendingFunc == nil {
		panic("GoRedisClientMock.XPendingFunc: method is nil but GoRedisClient.XPending was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Group  string
	}{
		Ctx:    ctx,
		Stream: stream,
		Group:  group,
	}
	mock.lockXPending.Lock()
	mock.calls.XPending = append(mock.calls.XPending, callInfo)
	mock.lockXPending.Unlock()
	return mock.XPendingFunc(ctx, stream, group)
}

// XPendingCalls gets all the calls that were made to XPending.
// Check the length with:
//
//	len(mockedGoRedisClient.XPendingCalls())
func (mock *GoRedisClientMock) XPendingCalls() []struct {
	Ctx    context.Context
	Stream string
	Group  string
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Group  string
	}
	mock.lockXPending.RLock()
	calls = mock.calls.XPending
	mock.lockXPending.RUnlock()
	return calls
}

// XPendingExt calls XPendingExtFunc.
func (mock *GoRedisClientMock) XPendingExt(ctx context.Context, a *redis.XPendingExtArgs) *redis.XPendingExtCmd {
	if mock.XPendingExtFunc == nil {
		panic("GoRedisClientMock.XPendingExtFunc: method is nil but GoRedisClient.XPendingExt was just called")
	}
	callInfo := struct {
		Ctx context.Context
		A   *redis.XPendingExtArgs
	}{
		Ctx: ctx,
		A:   a,
	}
	mock.lockXPendingExt.Lock()
	mock.calls.XPendingExt = append(mock.calls.XPendingExt, callInfo)
	mock.lockXPendingExt.Unlock()
	return mock.XPendingExtFunc(ctx, a)
}

// XPendingExtCalls gets all the calls that were made to XPendingExt.
// Check the length with:
//
//	len(mockedGoRedisClient.XPendingExtCalls())
func (mock *GoRedisClientMock) XPendingExtCalls() []struct {
	Ctx context.Context
	A   *redis.XPendingExtArgs
} {
	var calls []struct {
		Ctx context.Context
		A   *redis.XPendingExtArgs
	}
	mock.lockXPendingExt.RLock()
	calls = mock.calls.XPendingExt
	mock.lockXPendingExt.RUnlock()
	return calls
}

// XRange calls XRangeFunc.
func (mock *GoRedisClientMock) XRange(ctx context.Context, stream string, start string, stop string) *redis.XMessageSliceCmd {
	if mock.XRangeFunc == nil {
		panic("GoRedisClientMock.XRangeFunc: method is nil but GoRedisClient.XRange was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Start  string
		Stop   string
	}{
		Ctx:    ctx,
		Stream: stream,
		Start:  start,
		Stop:   stop,
	}
	mock.lockXRange.Lock()
	mock.calls.XRange = append(mock.calls.XRange, callInfo)
	mock.lockXRange.Unlock()
	return mock.XRangeFunc(ctx, stream, start, stop)
}

// XRangeCalls gets all the calls that were made to XRange.
// Check the length with:
//
//	len(mockedGoRedisClient.XRangeCalls())
func (mock *GoRedisClientMock) XRangeCalls() []struct {
	Ctx    context.Context
	Stream string
	Start  string
	Stop   string
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Start  string
		Stop   string
	}
	mock.lockXRange.RLock()
	calls = mock.calls.XRange
	mock.lockXRange.RUnlock()
	return calls
}

// XRangeN calls XRangeNFunc.
func (mock *GoRedisClientMock) XRangeN(ctx context.Context, stream string, start string, stop string, count int64) *redis.XMessageSliceCmd {
	if mock.XRangeNFunc == nil {
		panic("GoRedisClientMock.XRangeNFunc: method is nil but GoRedisClient.XRangeN was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Start  string
		Stop   string
		Count  int64
	}{
		Ctx:    ctx,
		Stream: stream,
		Start:  start,
		Stop:   stop,
		Count:  count,
	}
	mock.lockXRangeN.Lock()
	mock.calls.XRangeN = append(mock.calls.XRangeN, callInfo)
	mock.lockXRangeN.Unlock()
	return mock.XRangeNFunc(ctx, stream, start, stop, count)
}

// XRangeNCalls gets all the calls that were made to XRangeN.
// Check the length with:
//
//	len(mockedGoRedisClient.XRangeNCalls())
func (mock *GoRedisClientMock) XRangeNCalls() []struct {
	Ctx    context.Context
	Stream string
	Start  string
	Stop   string
	Count  int64
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Start  string
		Stop   string
		Count  int64
	}
	mock.lockXRangeN.RLock()
	calls = mock.calls.XRangeN
	mock.lockXRangeN.RUnlock()
	return calls
}

// XRead calls XReadFunc.
func (mock *GoRedisClientMock) XRead(ctx context.Context, a *redis.XReadArgs) *redis.XStreamSliceCmd {
	if mock.XReadFunc == nil {
		panic("GoRedisClientMock.XReadFunc: method is nil but GoRedisClient.XRead was just called")
	}
	callInfo := struct {
		Ctx context.Context
		A   *redis.XReadArgs
	}{
		Ctx: ctx,
		A:   a,
	}
	mock.lockXRead.Lock()
	mock.calls.XRead = append(mock.calls.XRead, callInfo)
	mock.lockXRead.Unlock()
	return mock.XReadFunc(ctx, a)
}

// XReadCalls gets all the calls that were made to XRead.
// Check the length with:
//
//	len(mockedGoRedisClient.XReadCalls())
func (mock *GoRedisClientMock) XReadCalls() []struct {
	Ctx context.Context
	A   *redis.XReadArgs
} {
	var calls []struct {
		Ctx context.Context
		A   *redis.XReadArgs
	}
	mock.lockXRead.RLock()
	calls = mock.calls.XRead
	mock.lockXRead.RUnlock()
	return calls
}

// XReadGroup calls XReadGroupFunc.
func (mock *GoRedisClientMock) XReadGroup(ctx context.Context, a *redis.XReadGroupArgs) *redis.XStreamSliceCmd {
	if mock.XReadGroupFunc == nil {
		panic("GoRedisClientMock.XReadGroupFunc: method is nil but GoRedisClient.XReadGroup was just called")
	}
	callInfo := struct {
		Ctx context.Context
		A   *redis.XReadGroupArgs
	}{
		Ctx: ctx,
		A:   a,
	}
	mock.lockXReadGroup.Lock()
	mock.calls.XReadGroup = append(mock.calls.XReadGroup, callInfo)
	mock.lockXReadGroup.Unlock()
	return mock.XReadGroupFunc(ctx, a)
}

// XReadGroupCalls gets all the calls that were made to XReadGroup.
// Check the length with:
//
//	len(mockedGoRedisClient.XReadGroupCalls())
func (mock *GoRedisClientMock) XReadGroupCalls() []struct {
	Ctx context.Context
	A   *redis.XReadGroupArgs
} {
	var calls []struct {
		Ctx context.Context
		A   *redis.XReadGroupArgs
	}
	mock.lockXReadGroup.RLock()
	calls = mock.calls.XReadGroup
	mock.lockXReadGroup.RUnlock()
	return calls
}

// XReadStreams calls XReadStreamsFunc.
func (mock *GoRedisClientMock) XReadStreams(ctx context.Context, streams ...string) *redis.XStreamSliceCmd {
	if mock.XReadStreamsFunc == nil {
		panic("GoRedisClientMock.XReadStreamsFunc: method is nil but GoRedisClient.XReadStreams was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Streams []string
	}{
		Ctx:     ctx,
		Streams: streams,
	}
	mock.lockXReadStreams.Lock()
	mock.calls.XReadStreams = append(mock.calls.XReadStreams, callInfo)
	mock.lockXReadStreams.Unlock()
	return mock.XReadStreamsFunc(ctx, streams...)
}

// XReadStreamsCalls gets all the calls that were made to XReadStreams.
// Check the length with:
//
//	len(mockedGoRedisClient.XReadStreamsCalls())
func (mock *GoRedisClientMock) XReadStreamsCalls() []struct {
	Ctx     context.Context
	Streams []string
} {
	var calls []struct {
		Ctx     context.Context
		Streams []string
	}
	mock.lockXReadStreams.RLock()
	calls = mock.calls.XReadStreams
	mock.lockXReadStreams.RUnlock()
	return calls
}

// XRevRange calls XRevRangeFunc.
func (mock *GoRedisClientMock) XRevRange(ctx context.Context, stream string, start string, stop string) *redis.XMessageSliceCmd {
	if mock.XRevRangeFunc == nil {
		panic("GoRedisClientMock.XRevRangeFunc: method is nil but GoRedisClient.XRevRange was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Start  string
		Stop   string
	}{
		Ctx:    ctx,
		Stream: stream,
		Start:  start,
		Stop:   stop,
	}
	mock.lockXRevRange.Lock()
	mock.calls.XRevRange = append(mock.calls.XRevRange, callInfo)
	mock.lockXRevRange.Unlock()
	return mock.XRevRangeFunc(ctx, stream, start, stop)
}

// XRevRangeCalls gets all the calls that were made to XRevRange.
// Check the length with:
//
//	len(mockedGoRedisClient.XRevRangeCalls())
func (mock *GoRedisClientMock) XRevRangeCalls() []struct {
	Ctx    context.Context
	Stream string
	Start  string
	Stop   string
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Start  string
		Stop   string
	}
	mock.lockXRevRange.RLock()
	calls = mock.calls.XRevRange
	mock.lockXRevRange.RUnlock()
	return calls
}

// XRevRangeN calls XRevRangeNFunc.
func (mock *GoRedisClientMock) XRevRangeN(ctx context.Context, stream string, start string, stop string, count int64) *redis.XMessageSliceCmd {
	if mock.XRevRangeNFunc == nil {
		panic("GoRedisClientMock.XRevRangeNFunc: method is nil but GoRedisClient.XRevRangeN was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Stream string
		Start  string
		Stop   string
		Count  int64
	}{
		Ctx:    ctx,
		Stream: stream,
		Start:  start,
		Stop:   stop,
		Count:  count,
	}
	mock.lockXRevRangeN.Lock()
	mock.calls.XRevRangeN = append(mock.calls.XRevRangeN, callInfo)
	mock.lockXRevRangeN.Unlock()
	return mock.XRevRangeNFunc(ctx, stream, start, stop, count)
}

// XRevRangeNCalls gets all the calls that were made to XRevRangeN.
// Check the length with:
//
//	len(mockedGoRedisClient.XRevRangeNCalls())
func (mock *GoRedisClientMock) XRevRangeNCalls() []struct {
	Ctx    context.Context
	Stream string
	Start  string
	Stop   string
	Count  int64
} {
	var calls []struct {
		Ctx    context.Context
		Stream string
		Start  string
		Stop   string
		Count  int64
	}
	mock.lockXRevRangeN.RLock()
	calls = mock.calls.XRevRangeN
	mock.lockXRevRangeN.RUnlock()
	return calls
}

// XTrimMaxLen calls XTrimMaxLenFunc.
func (mock *GoRedisClientMock) XTrimMaxLen(ctx context.Context, key string, maxLen int64) *redis.IntCmd {
	if mock.XTrimMaxLenFunc == nil {
		panic("GoRedisClientMock.XTrimMaxLenFunc: method is nil but GoRedisClient.XTrimMaxLen was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		MaxLen int64
	}{
		Ctx:    ctx,
		Key:    key,
		MaxLen: maxLen,
	}
	mock.lockXTrimMaxLen.Lock()
	mock.calls.XTrimMaxLen = append(mock.calls.XTrimMaxLen, callInfo)
	mock.lockXTrimMaxLen.Unlock()
	return mock.XTrimMaxLenFunc(ctx, key, maxLen)
}

// XTrimMaxLenCalls gets all the calls that were made to XTrimMaxLen.
// Check the length with:
//
//	len(mockedGoRedisClient.XTrimMaxLenCalls())
func (mock *GoRedisClientMock) XTrimMaxLenCalls() []struct {
	Ctx    context.Context
	Key    string
	MaxLen int64
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		MaxLen int64
	}
	mock.lockXTrimMaxLen.RLock()
	calls = mock.calls.XTrimMaxLen
	mock.lockXTrimMaxLen.RUnlock()
	return calls
}

// XTrimMaxLenApprox calls XTrimMaxLenApproxFunc.
func (mock *GoRedisClientMock) XTrimMaxLenApprox(ctx context.Context, key string, maxLen int64, limit int64) *redis.IntCmd {
	if mock.XTrimMaxLenApproxFunc == nil {
		panic("GoRedisClientMock.XTrimMaxLenApproxFunc: method is nil but GoRedisClient.XTrimMaxLenApprox was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		MaxLen int64
		Limit  int64
	}{
		Ctx:    ctx,
		Key:    key,
		MaxLen: maxLen,
		Limit:  limit,
	}
	mock.lockXTrimMaxLenApprox.Lock()
	mock.calls.XTrimMaxLenApprox = append(mock.calls.XTrimMaxLenApprox, callInfo)
	mock.lockXTrimMaxLenApprox.Unlock()
	return mock.XTrimMaxLenApproxFunc(ctx, key, maxLen, limit)
}

// XTrimMaxLenApproxCalls gets all the calls that were made to XTrimMaxLenApprox.
// Check the length with:
//
//	len(mockedGoRedisClient.XTrimMaxLenApproxCalls())
func (mock *GoRedisClientMock) XTrimMaxLenApproxCalls() []struct {
	Ctx    context.Context
	Key    string
	MaxLen int64
	Limit  int64
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		MaxLen int64
		Limit  int64
	}
	mock.lockXTrimMaxLenApprox.RLock()
	calls = mock.calls.XTrimMaxLenApprox
	mock.lockXTrimMaxLenApprox.RUnlock()
	return calls
}

// XTrimMinID calls XTrimMinIDFunc.
func (mock *GoRedisClientMock) XTrimMinID(ctx context.Context, key string, minID string) *redis.IntCmd {
	if mock.XTrimMinIDFunc == nil {
		panic("GoRedisClientMock.XTrimMinIDFunc: method is nil but GoRedisClient.XTrimMinID was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		MinID string
	}{
		Ctx:   ctx,
		Key:   key,
		MinID: minID,
	}
	mock.lockXTrimMinID.Lock()
	mock.calls.XTrimMinID = append(mock.calls.XTrimMinID, callInfo)
	mock.lockXTrimMinID.Unlock()
	return mock.XTrimMinIDFunc(ctx, key, minID)
}

// XTrimMinIDCalls gets all the calls that were made to XTrimMinID.
// Check the length with:
//
//	len(mockedGoRedisClient.XTrimMinIDCalls())
func (mock *GoRedisClientMock) XTrimMinIDCalls() []struct {
	Ctx   context.Context
	Key   string
	MinID string
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		MinID string
	}
	mock.lockXTrimMinID.RLock()
	calls = mock.calls.XTrimMinID
	mock.lockXTrimMinID.RUnlock()
	return calls
}

// XTrimMinIDApprox calls XTrimMinIDApproxFunc.
func (mock *GoRedisClientMock) XTrimMinIDApprox(ctx context.Context, key string, minID string, limit int64) *redis.IntCmd {
	if mock.XTrimMinIDApproxFunc == nil {
		panic("GoRedisClientMock.XTrimMinIDApproxFunc: method is nil but GoRedisClient.XTrimMinIDApprox was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		MinID string
		Limit int64
	}{
		Ctx:   ctx,
		Key:   key,
		MinID: minID,
		Limit: limit,
	}
	mock.lockXTrimMinIDApprox.Lock()
	mock.calls.XTrimMinIDApprox = append(mock.calls.XTrimMinIDApprox, callInfo)
	mock.lockXTrimMinIDApprox.Unlock()
	return mock.XTrimMinIDApproxFunc(ctx, key, minID, limit)
}

// XTrimMinIDApproxCalls gets all the calls that were made to XTrimMinIDApprox.
// Check the length with:
//
//	len(mockedGoRedisClient.XTrimMinIDApproxCalls())
func (mock *GoRedisClientMock) XTrimMinIDApproxCalls() []struct {
	Ctx   context.Context
	Key   string
	MinID string
	Limit int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		MinID string
		Limit int64
	}
	mock.lockXTrimMinIDApprox.RLock()
	calls = mock.calls.XTrimMinIDApprox
	mock.lockXTrimMinIDApprox.RUnlock()
	return calls
}

// ZAdd calls ZAddFunc.
func (mock *GoRedisClientMock) ZAdd(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
	if mock.ZAddFunc == nil {
		panic("GoRedisClientMock.ZAddFunc: method is nil but GoRedisClient.ZAdd was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []redis.Z
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockZAdd.Lock()
	mock.calls.ZAdd = append(mock.calls.ZAdd, callInfo)
	mock.lockZAdd.Unlock()
	return mock.ZAddFunc(ctx, key, members...)
}

// ZAddCalls gets all the calls that were made to ZAdd.
// Check the length with:
//
//	len(mockedGoRedisClient.ZAddCalls())
func (mock *GoRedisClientMock) ZAddCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []redis.Z
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []redis.Z
	}
	mock.lockZAdd.RLock()
	calls = mock.calls.ZAdd
	mock.lockZAdd.RUnlock()
	return calls
}

// ZAddArgs calls ZAddArgsFunc.
func (mock *GoRedisClientMock) ZAddArgs(ctx context.Context, key string, args redis.ZAddArgs) *redis.IntCmd {
	if mock.ZAddArgsFunc == nil {
		panic("GoRedisClientMock.ZAddArgsFunc: method is nil but GoRedisClient.ZAddArgs was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Args redis.ZAddArgs
	}{
		Ctx:  ctx,
		Key:  key,
		Args: args,
	}
	mock.lockZAddArgs.Lock()
	mock.calls.ZAddArgs = append(mock.calls.ZAddArgs, callInfo)
	mock.lockZAddArgs.Unlock()
	return mock.ZAddArgsFunc(ctx, key, args)
}

// ZAddArgsCalls gets all the calls that were made to ZAddArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.ZAddArgsCalls())
func (mock *GoRedisClientMock) ZAddArgsCalls() []struct {
	Ctx  context.Context
	Key  string
	Args redis.ZAddArgs
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Args redis.ZAddArgs
	}
	mock.lockZAddArgs.RLock()
	calls = mock.calls.ZAddArgs
	mock.lockZAddArgs.RUnlock()
	return calls
}

// ZAddArgsIncr calls ZAddArgsIncrFunc.
func (mock *GoRedisClientMock) ZAddArgsIncr(ctx context.Context, key string, args redis.ZAddArgs) *redis.FloatCmd {
	if mock.ZAddArgsIncrFunc == nil {
		panic("GoRedisClientMock.ZAddArgsIncrFunc: method is nil but GoRedisClient.ZAddArgsIncr was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Key  string
		Args redis.ZAddArgs
	}{
		Ctx:  ctx,
		Key:  key,
		Args: args,
	}
	mock.lockZAddArgsIncr.Lock()
	mock.calls.ZAddArgsIncr = append(mock.calls.ZAddArgsIncr, callInfo)
	mock.lockZAddArgsIncr.Unlock()
	return mock.ZAddArgsIncrFunc(ctx, key, args)
}

// ZAddArgsIncrCalls gets all the calls that were made to ZAddArgsIncr.
// Check the length with:
//
//	len(mockedGoRedisClient.ZAddArgsIncrCalls())
func (mock *GoRedisClientMock) ZAddArgsIncrCalls() []struct {
	Ctx  context.Context
	Key  string
	Args redis.ZAddArgs
} {
	var calls []struct {
		Ctx  context.Context
		Key  string
		Args redis.ZAddArgs
	}
	mock.lockZAddArgsIncr.RLock()
	calls = mock.calls.ZAddArgsIncr
	mock.lockZAddArgsIncr.RUnlock()
	return calls
}

// ZAddGT calls ZAddGTFunc.
func (mock *GoRedisClientMock) ZAddGT(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
	if mock.ZAddGTFunc == nil {
		panic("GoRedisClientMock.ZAddGTFunc: method is nil but GoRedisClient.ZAddGT was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []redis.Z
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockZAddGT.Lock()
	mock.calls.ZAddGT = append(mock.calls.ZAddGT, callInfo)
	mock.lockZAddGT.Unlock()
	return mock.ZAddGTFunc(ctx, key, members...)
}

// ZAddGTCalls gets all the calls that were made to ZAddGT.
// Check the length with:
//
//	len(mockedGoRedisClient.ZAddGTCalls())
func (mock *GoRedisClientMock) ZAddGTCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []redis.Z
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []redis.Z
	}
	mock.lockZAddGT.RLock()
	calls = mock.calls.ZAddGT
	mock.lockZAddGT.RUnlock()
	return calls
}

// ZAddLT calls ZAddLTFunc.
func (mock *GoRedisClientMock) ZAddLT(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
	if mock.ZAddLTFunc == nil {
		panic("GoRedisClientMock.ZAddLTFunc: method is nil but GoRedisClient.ZAddLT was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []redis.Z
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockZAddLT.Lock()
	mock.calls.ZAddLT = append(mock.calls.ZAddLT, callInfo)
	mock.lockZAddLT.Unlock()
	return mock.ZAddLTFunc(ctx, key, members...)
}

// ZAddLTCalls gets all the calls that were made to ZAddLT.
// Check the length with:
//
//	len(mockedGoRedisClient.ZAddLTCalls())
func (mock *GoRedisClientMock) ZAddLTCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []redis.Z
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []redis.Z
	}
	mock.lockZAddLT.RLock()
	calls = mock.calls.ZAddLT
	mock.lockZAddLT.RUnlock()
	return calls
}

// ZAddNX calls ZAddNXFunc.
func (mock *GoRedisClientMock) ZAddNX(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
	if mock.ZAddNXFunc == nil {
		panic("GoRedisClientMock.ZAddNXFunc: method is nil but GoRedisClient.ZAddNX was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []redis.Z
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockZAddNX.Lock()
	mock.calls.ZAddNX = append(mock.calls.ZAddNX, callInfo)
	mock.lockZAddNX.Unlock()
	return mock.ZAddNXFunc(ctx, key, members...)
}

// ZAddNXCalls gets all the calls that were made to ZAddNX.
// Check the length with:
//
//	len(mockedGoRedisClient.ZAddNXCalls())
func (mock *GoRedisClientMock) ZAddNXCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []redis.Z
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []redis.Z
	}
	mock.lockZAddNX.RLock()
	calls = mock.calls.ZAddNX
	mock.lockZAddNX.RUnlock()
	return calls
}

// ZAddXX calls ZAddXXFunc.
func (mock *GoRedisClientMock) ZAddXX(ctx context.Context, key string, members ...redis.Z) *redis.IntCmd {
	if mock.ZAddXXFunc == nil {
		panic("GoRedisClientMock.ZAddXXFunc: method is nil but GoRedisClient.ZAddXX was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []redis.Z
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockZAddXX.Lock()
	mock.calls.ZAddXX = append(mock.calls.ZAddXX, callInfo)
	mock.lockZAddXX.Unlock()
	return mock.ZAddXXFunc(ctx, key, members...)
}

// ZAddXXCalls gets all the calls that were made to ZAddXX.
// Check the length with:
//
//	len(mockedGoRedisClient.ZAddXXCalls())
func (mock *GoRedisClientMock) ZAddXXCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []redis.Z
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []redis.Z
	}
	mock.lockZAddXX.RLock()
	calls = mock.calls.ZAddXX
	mock.lockZAddXX.RUnlock()
	return calls
}

// ZCard calls ZCardFunc.
func (mock *GoRedisClientMock) ZCard(ctx context.Context, key string) *redis.IntCmd {
	if mock.ZCardFunc == nil {
		panic("GoRedisClientMock.ZCardFunc: method is nil but GoRedisClient.ZCard was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
	}{
		Ctx: ctx,
		Key: key,
	}
	mock.lockZCard.Lock()
	mock.calls.ZCard = append(mock.calls.ZCard, callInfo)
	mock.lockZCard.Unlock()
	return mock.ZCardFunc(ctx, key)
}

// ZCardCalls gets all the calls that were made to ZCard.
// Check the length with:
//
//	len(mockedGoRedisClient.ZCardCalls())
func (mock *GoRedisClientMock) ZCardCalls() []struct {
	Ctx context.Context
	Key string
} {
	var calls []struct {
		Ctx context.Context
		Key string
	}
	mock.lockZCard.RLock()
	calls = mock.calls.ZCard
	mock.lockZCard.RUnlock()
	return calls
}

// ZCount calls ZCountFunc.
func (mock *GoRedisClientMock) ZCount(ctx context.Context, key string, min string, max string) *redis.IntCmd {
	if mock.ZCountFunc == nil {
		panic("GoRedisClientMock.ZCountFunc: method is nil but GoRedisClient.ZCount was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Min string
		Max string
	}{
		Ctx: ctx,
		Key: key,
		Min: min,
		Max: max,
	}
	mock.lockZCount.Lock()
	mock.calls.ZCount = append(mock.calls.ZCount, callInfo)
	mock.lockZCount.Unlock()
	return mock.ZCountFunc(ctx, key, min, max)
}

// ZCountCalls gets all the calls that were made to ZCount.
// Check the length with:
//
//	len(mockedGoRedisClient.ZCountCalls())
func (mock *GoRedisClientMock) ZCountCalls() []struct {
	Ctx context.Context
	Key string
	Min string
	Max string
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Min string
		Max string
	}
	mock.lockZCount.RLock()
	calls = mock.calls.ZCount
	mock.lockZCount.RUnlock()
	return calls
}

// ZDiff calls ZDiffFunc.
func (mock *GoRedisClientMock) ZDiff(ctx context.Context, keys ...string) *redis.StringSliceCmd {
	if mock.ZDiffFunc == nil {
		panic("GoRedisClientMock.ZDiffFunc: method is nil but GoRedisClient.ZDiff was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockZDiff.Lock()
	mock.calls.ZDiff = append(mock.calls.ZDiff, callInfo)
	mock.lockZDiff.Unlock()
	return mock.ZDiffFunc(ctx, keys...)
}

// ZDiffCalls gets all the calls that were made to ZDiff.
// Check the length with:
//
//	len(mockedGoRedisClient.ZDiffCalls())
func (mock *GoRedisClientMock) ZDiffCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockZDiff.RLock()
	calls = mock.calls.ZDiff
	mock.lockZDiff.RUnlock()
	return calls
}

// ZDiffStore calls ZDiffStoreFunc.
func (mock *GoRedisClientMock) ZDiffStore(ctx context.Context, destination string, keys ...string) *redis.IntCmd {
	if mock.ZDiffStoreFunc == nil {
		panic("GoRedisClientMock.ZDiffStoreFunc: method is nil but GoRedisClient.ZDiffStore was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Destination string
		Keys        []string
	}{
		Ctx:         ctx,
		Destination: destination,
		Keys:        keys,
	}
	mock.lockZDiffStore.Lock()
	mock.calls.ZDiffStore = append(mock.calls.ZDiffStore, callInfo)
	mock.lockZDiffStore.Unlock()
	return mock.ZDiffStoreFunc(ctx, destination, keys...)
}

// ZDiffStoreCalls gets all the calls that were made to ZDiffStore.
// Check the length with:
//
//	len(mockedGoRedisClient.ZDiffStoreCalls())
func (mock *GoRedisClientMock) ZDiffStoreCalls() []struct {
	Ctx         context.Context
	Destination string
	Keys        []string
} {
	var calls []struct {
		Ctx         context.Context
		Destination string
		Keys        []string
	}
	mock.lockZDiffStore.RLock()
	calls = mock.calls.ZDiffStore
	mock.lockZDiffStore.RUnlock()
	return calls
}

// ZDiffWithScores calls ZDiffWithScoresFunc.
func (mock *GoRedisClientMock) ZDiffWithScores(ctx context.Context, keys ...string) *redis.ZSliceCmd {
	if mock.ZDiffWithScoresFunc == nil {
		panic("GoRedisClientMock.ZDiffWithScoresFunc: method is nil but GoRedisClient.ZDiffWithScores was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Keys []string
	}{
		Ctx:  ctx,
		Keys: keys,
	}
	mock.lockZDiffWithScores.Lock()
	mock.calls.ZDiffWithScores = append(mock.calls.ZDiffWithScores, callInfo)
	mock.lockZDiffWithScores.Unlock()
	return mock.ZDiffWithScoresFunc(ctx, keys...)
}

// ZDiffWithScoresCalls gets all the calls that were made to ZDiffWithScores.
// Check the length with:
//
//	len(mockedGoRedisClient.ZDiffWithScoresCalls())
func (mock *GoRedisClientMock) ZDiffWithScoresCalls() []struct {
	Ctx  context.Context
	Keys []string
} {
	var calls []struct {
		Ctx  context.Context
		Keys []string
	}
	mock.lockZDiffWithScores.RLock()
	calls = mock.calls.ZDiffWithScores
	mock.lockZDiffWithScores.RUnlock()
	return calls
}

// ZIncrBy calls ZIncrByFunc.
func (mock *GoRedisClientMock) ZIncrBy(ctx context.Context, key string, increment float64, member string) *redis.FloatCmd {
	if mock.ZIncrByFunc == nil {
		panic("GoRedisClientMock.ZIncrByFunc: method is nil but GoRedisClient.ZIncrBy was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Key       string
		Increment float64
		Member    string
	}{
		Ctx:       ctx,
		Key:       key,
		Increment: increment,
		Member:    member,
	}
	mock.lockZIncrBy.Lock()
	mock.calls.ZIncrBy = append(mock.calls.ZIncrBy, callInfo)
	mock.lockZIncrBy.Unlock()
	return mock.ZIncrByFunc(ctx, key, increment, member)
}

// ZIncrByCalls gets all the calls that were made to ZIncrBy.
// Check the length with:
//
//	len(mockedGoRedisClient.ZIncrByCalls())
func (mock *GoRedisClientMock) ZIncrByCalls() []struct {
	Ctx       context.Context
	Key       string
	Increment float64
	Member    string
} {
	var calls []struct {
		Ctx       context.Context
		Key       string
		Increment float64
		Member    string
	}
	mock.lockZIncrBy.RLock()
	calls = mock.calls.ZIncrBy
	mock.lockZIncrBy.RUnlock()
	return calls
}

// ZInter calls ZInterFunc.
func (mock *GoRedisClientMock) ZInter(ctx context.Context, store *redis.ZStore) *redis.StringSliceCmd {
	if mock.ZInterFunc == nil {
		panic("GoRedisClientMock.ZInterFunc: method is nil but GoRedisClient.ZInter was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Store *redis.ZStore
	}{
		Ctx:   ctx,
		Store: store,
	}
	mock.lockZInter.Lock()
	mock.calls.ZInter = append(mock.calls.ZInter, callInfo)
	mock.lockZInter.Unlock()
	return mock.ZInterFunc(ctx, store)
}

// ZInterCalls gets all the calls that were made to ZInter.
// Check the length with:
//
//	len(mockedGoRedisClient.ZInterCalls())
func (mock *GoRedisClientMock) ZInterCalls() []struct {
	Ctx   context.Context
	Store *redis.ZStore
} {
	var calls []struct {
		Ctx   context.Context
		Store *redis.ZStore
	}
	mock.lockZInter.RLock()
	calls = mock.calls.ZInter
	mock.lockZInter.RUnlock()
	return calls
}

// ZInterCard calls ZInterCardFunc.
func (mock *GoRedisClientMock) ZInterCard(ctx context.Context, limit int64, keys ...string) *redis.IntCmd {
	if mock.ZInterCardFunc == nil {
		panic("GoRedisClientMock.ZInterCardFunc: method is nil but GoRedisClient.ZInterCard was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Limit int64
		Keys  []string
	}{
		Ctx:   ctx,
		Limit: limit,
		Keys:  keys,
	}
	mock.lockZInterCard.Lock()
	mock.calls.ZInterCard = append(mock.calls.ZInterCard, callInfo)
	mock.lockZInterCard.Unlock()
	return mock.ZInterCardFunc(ctx, limit, keys...)
}

// ZInterCardCalls gets all the calls that were made to ZInterCard.
// Check the length with:
//
//	len(mockedGoRedisClient.ZInterCardCalls())
func (mock *GoRedisClientMock) ZInterCardCalls() []struct {
	Ctx   context.Context
	Limit int64
	Keys  []string
} {
	var calls []struct {
		Ctx   context.Context
		Limit int64
		Keys  []string
	}
	mock.lockZInterCard.RLock()
	calls = mock.calls.ZInterCard
	mock.lockZInterCard.RUnlock()
	return calls
}

// ZInterStore calls ZInterStoreFunc.
func (mock *GoRedisClientMock) ZInterStore(ctx context.Context, destination string, store *redis.ZStore) *redis.IntCmd {
	if mock.ZInterStoreFunc == nil {
		panic("GoRedisClientMock.ZInterStoreFunc: method is nil but GoRedisClient.ZInterStore was just called")
	}
	callInfo := struct {
		Ctx         context.Context
		Destination string
		Store       *redis.ZStore
	}{
		Ctx:         ctx,
		Destination: destination,
		Store:       store,
	}
	mock.lockZInterStore.Lock()
	mock.calls.ZInterStore = append(mock.calls.ZInterStore, callInfo)
	mock.lockZInterStore.Unlock()
	return mock.ZInterStoreFunc(ctx, destination, store)
}

// ZInterStoreCalls gets all the calls that were made to ZInterStore.
// Check the length with:
//
//	len(mockedGoRedisClient.ZInterStoreCalls())
func (mock *GoRedisClientMock) ZInterStoreCalls() []struct {
	Ctx         context.Context
	Destination string
	Store       *redis.ZStore
} {
	var calls []struct {
		Ctx         context.Context
		Destination string
		Store       *redis.ZStore
	}
	mock.lockZInterStore.RLock()
	calls = mock.calls.ZInterStore
	mock.lockZInterStore.RUnlock()
	return calls
}

// ZInterWithScores calls ZInterWithScoresFunc.
func (mock *GoRedisClientMock) ZInterWithScores(ctx context.Context, store *redis.ZStore) *redis.ZSliceCmd {
	if mock.ZInterWithScoresFunc == nil {
		panic("GoRedisClientMock.ZInterWithScoresFunc: method is nil but GoRedisClient.ZInterWithScores was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Store *redis.ZStore
	}{
		Ctx:   ctx,
		Store: store,
	}
	mock.lockZInterWithScores.Lock()
	mock.calls.ZInterWithScores = append(mock.calls.ZInterWithScores, callInfo)
	mock.lockZInterWithScores.Unlock()
	return mock.ZInterWithScoresFunc(ctx, store)
}

// ZInterWithScoresCalls gets all the calls that were made to ZInterWithScores.
// Check the length with:
//
//	len(mockedGoRedisClient.ZInterWithScoresCalls())
func (mock *GoRedisClientMock) ZInterWithScoresCalls() []struct {
	Ctx   context.Context
	Store *redis.ZStore
} {
	var calls []struct {
		Ctx   context.Context
		Store *redis.ZStore
	}
	mock.lockZInterWithScores.RLock()
	calls = mock.calls.ZInterWithScores
	mock.lockZInterWithScores.RUnlock()
	return calls
}

// ZLexCount calls ZLexCountFunc.
func (mock *GoRedisClientMock) ZLexCount(ctx context.Context, key string, min string, max string) *redis.IntCmd {
	if mock.ZLexCountFunc == nil {
		panic("GoRedisClientMock.ZLexCountFunc: method is nil but GoRedisClient.ZLexCount was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Min string
		Max string
	}{
		Ctx: ctx,
		Key: key,
		Min: min,
		Max: max,
	}
	mock.lockZLexCount.Lock()
	mock.calls.ZLexCount = append(mock.calls.ZLexCount, callInfo)
	mock.lockZLexCount.Unlock()
	return mock.ZLexCountFunc(ctx, key, min, max)
}

// ZLexCountCalls gets all the calls that were made to ZLexCount.
// Check the length with:
//
//	len(mockedGoRedisClient.ZLexCountCalls())
func (mock *GoRedisClientMock) ZLexCountCalls() []struct {
	Ctx context.Context
	Key string
	Min string
	Max string
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Min string
		Max string
	}
	mock.lockZLexCount.RLock()
	calls = mock.calls.ZLexCount
	mock.lockZLexCount.RUnlock()
	return calls
}

// ZMPop calls ZMPopFunc.
func (mock *GoRedisClientMock) ZMPop(ctx context.Context, order string, count int64, keys ...string) *redis.ZSliceWithKeyCmd {
	if mock.ZMPopFunc == nil {
		panic("GoRedisClientMock.ZMPopFunc: method is nil but GoRedisClient.ZMPop was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Order string
		Count int64
		Keys  []string
	}{
		Ctx:   ctx,
		Order: order,
		Count: count,
		Keys:  keys,
	}
	mock.lockZMPop.Lock()
	mock.calls.ZMPop = append(mock.calls.ZMPop, callInfo)
	mock.lockZMPop.Unlock()
	return mock.ZMPopFunc(ctx, order, count, keys...)
}

// ZMPopCalls gets all the calls that were made to ZMPop.
// Check the length with:
//
//	len(mockedGoRedisClient.ZMPopCalls())
func (mock *GoRedisClientMock) ZMPopCalls() []struct {
	Ctx   context.Context
	Order string
	Count int64
	Keys  []string
} {
	var calls []struct {
		Ctx   context.Context
		Order string
		Count int64
		Keys  []string
	}
	mock.lockZMPop.RLock()
	calls = mock.calls.ZMPop
	mock.lockZMPop.RUnlock()
	return calls
}

// ZMScore calls ZMScoreFunc.
func (mock *GoRedisClientMock) ZMScore(ctx context.Context, key string, members ...string) *redis.FloatSliceCmd {
	if mock.ZMScoreFunc == nil {
		panic("GoRedisClientMock.ZMScoreFunc: method is nil but GoRedisClient.ZMScore was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []string
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockZMScore.Lock()
	mock.calls.ZMScore = append(mock.calls.ZMScore, callInfo)
	mock.lockZMScore.Unlock()
	return mock.ZMScoreFunc(ctx, key, members...)
}

// ZMScoreCalls gets all the calls that were made to ZMScore.
// Check the length with:
//
//	len(mockedGoRedisClient.ZMScoreCalls())
func (mock *GoRedisClientMock) ZMScoreCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []string
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []string
	}
	mock.lockZMScore.RLock()
	calls = mock.calls.ZMScore
	mock.lockZMScore.RUnlock()
	return calls
}

// ZPopMax calls ZPopMaxFunc.
func (mock *GoRedisClientMock) ZPopMax(ctx context.Context, key string, count ...int64) *redis.ZSliceCmd {
	if mock.ZPopMaxFunc == nil {
		panic("GoRedisClientMock.ZPopMaxFunc: method is nil but GoRedisClient.ZPopMax was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count []int64
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
	}
	mock.lockZPopMax.Lock()
	mock.calls.ZPopMax = append(mock.calls.ZPopMax, callInfo)
	mock.lockZPopMax.Unlock()
	return mock.ZPopMaxFunc(ctx, key, count...)
}

// ZPopMaxCalls gets all the calls that were made to ZPopMax.
// Check the length with:
//
//	len(mockedGoRedisClient.ZPopMaxCalls())
func (mock *GoRedisClientMock) ZPopMaxCalls() []struct {
	Ctx   context.Context
	Key   string
	Count []int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count []int64
	}
	mock.lockZPopMax.RLock()
	calls = mock.calls.ZPopMax
	mock.lockZPopMax.RUnlock()
	return calls
}

// ZPopMin calls ZPopMinFunc.
func (mock *GoRedisClientMock) ZPopMin(ctx context.Context, key string, count ...int64) *redis.ZSliceCmd {
	if mock.ZPopMinFunc == nil {
		panic("GoRedisClientMock.ZPopMinFunc: method is nil but GoRedisClient.ZPopMin was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count []int64
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
	}
	mock.lockZPopMin.Lock()
	mock.calls.ZPopMin = append(mock.calls.ZPopMin, callInfo)
	mock.lockZPopMin.Unlock()
	return mock.ZPopMinFunc(ctx, key, count...)
}

// ZPopMinCalls gets all the calls that were made to ZPopMin.
// Check the length with:
//
//	len(mockedGoRedisClient.ZPopMinCalls())
func (mock *GoRedisClientMock) ZPopMinCalls() []struct {
	Ctx   context.Context
	Key   string
	Count []int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count []int64
	}
	mock.lockZPopMin.RLock()
	calls = mock.calls.ZPopMin
	mock.lockZPopMin.RUnlock()
	return calls
}

// ZRandMember calls ZRandMemberFunc.
func (mock *GoRedisClientMock) ZRandMember(ctx context.Context, key string, count int) *redis.StringSliceCmd {
	if mock.ZRandMemberFunc == nil {
		panic("GoRedisClientMock.ZRandMemberFunc: method is nil but GoRedisClient.ZRandMember was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count int
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
	}
	mock.lockZRandMember.Lock()
	mock.calls.ZRandMember = append(mock.calls.ZRandMember, callInfo)
	mock.lockZRandMember.Unlock()
	return mock.ZRandMemberFunc(ctx, key, count)
}

// ZRandMemberCalls gets all the calls that were made to ZRandMember.
// Check the length with:
//
//	len(mockedGoRedisClient.ZRandMemberCalls())
func (mock *GoRedisClientMock) ZRandMemberCalls() []struct {
	Ctx   context.Context
	Key   string
	Count int
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count int
	}
	mock.lockZRandMember.RLock()
	calls = mock.calls.ZRandMember
	mock.lockZRandMember.RUnlock()
	return calls
}

// ZRandMemberWithScores calls ZRandMemberWithScoresFunc.
func (mock *GoRedisClientMock) ZRandMemberWithScores(ctx context.Context, key string, count int) *redis.ZSliceCmd {
	if mock.ZRandMemberWithScoresFunc == nil {
		panic("GoRedisClientMock.ZRandMemberWithScoresFunc: method is nil but GoRedisClient.ZRandMemberWithScores was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Count int
	}{
		Ctx:   ctx,
		Key:   key,
		Count: count,
	}
	mock.lockZRandMemberWithScores.Lock()
	mock.calls.ZRandMemberWithScores = append(mock.calls.ZRandMemberWithScores, callInfo)
	mock.lockZRandMemberWithScores.Unlock()
	return mock.ZRandMemberWithScoresFunc(ctx, key, count)
}

// ZRandMemberWithScoresCalls gets all the calls that were made to ZRandMemberWithScores.
// Check the length with:
//
//	len(mockedGoRedisClient.ZRandMemberWithScoresCalls())
func (mock *GoRedisClientMock) ZRandMemberWithScoresCalls() []struct {
	Ctx   context.Context
	Key   string
	Count int
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Count int
	}
	mock.lockZRandMemberWithScores.RLock()
	calls = mock.calls.ZRandMemberWithScores
	mock.lockZRandMemberWithScores.RUnlock()
	return calls
}

// ZRange calls ZRangeFunc.
func (mock *GoRedisClientMock) ZRange(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd {
	if mock.ZRangeFunc == nil {
		panic("GoRedisClientMock.ZRangeFunc: method is nil but GoRedisClient.ZRange was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}{
		Ctx:   ctx,
		Key:   key,
		Start: start,
		Stop:  stop,
	}
	mock.lockZRange.Lock()
	mock.calls.ZRange = append(mock.calls.ZRange, callInfo)
	mock.lockZRange.Unlock()
	return mock.ZRangeFunc(ctx, key, start, stop)
}

// ZRangeCalls gets all the calls that were made to ZRange.
// Check the length with:
//
//	len(mockedGoRedisClient.ZRangeCalls())
func (mock *GoRedisClientMock) ZRangeCalls() []struct {
	Ctx   context.Context
	Key   string
	Start int64
	Stop  int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}
	mock.lockZRange.RLock()
	calls = mock.calls.ZRange
	mock.lockZRange.RUnlock()
	return calls
}

// ZRangeArgs calls ZRangeArgsFunc.
func (mock *GoRedisClientMock) ZRangeArgs(ctx context.Context, z redis.ZRangeArgs) *redis.StringSliceCmd {
	if mock.ZRangeArgsFunc == nil {
		panic("GoRedisClientMock.ZRangeArgsFunc: method is nil but GoRedisClient.ZRangeArgs was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Z   redis.ZRangeArgs
	}{
		Ctx: ctx,
		Z:   z,
	}
	mock.lockZRangeArgs.Lock()
	mock.calls.ZRangeArgs = append(mock.calls.ZRangeArgs, callInfo)
	mock.lockZRangeArgs.Unlock()
	return mock.ZRangeArgsFunc(ctx, z)
}

// ZRangeArgsCalls gets all the calls that were made to ZRangeArgs.
// Check the length with:
//
//	len(mockedGoRedisClient.ZRangeArgsCalls())
func (mock *GoRedisClientMock) ZRangeArgsCalls() []struct {
	Ctx context.Context
	Z   redis.ZRangeArgs
} {
	var calls []struct {
		Ctx context.Context
		Z   redis.ZRangeArgs
	}
	mock.lockZRangeArgs.RLock()
	calls = mock.calls.ZRangeArgs
	mock.lockZRangeArgs.RUnlock()
	return calls
}

// ZRangeArgsWithScores calls ZRangeArgsWithScoresFunc.
func (mock *GoRedisClientMock) ZRangeArgsWithScores(ctx context.Context, z redis.ZRangeArgs) *redis.ZSliceCmd {
	if mock.ZRangeArgsWithScoresFunc == nil {
		panic("GoRedisClientMock.ZRangeArgsWithScoresFunc: method is nil but GoRedisClient.ZRangeArgsWithScores was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Z   redis.ZRangeArgs
	}{
		Ctx: ctx,
		Z:   z,
	}
	mock.lockZRangeArgsWithScores.Lock()
	mock.calls.ZRangeArgsWithScores = append(mock.calls.ZRangeArgsWithScores, callInfo)
	mock.lockZRangeArgsWithScores.Unlock()
	return mock.ZRangeArgsWithScoresFunc(ctx, z)
}

// ZRangeArgsWithScoresCalls gets all the calls that were made to ZRangeArgsWithScores.
// Check the length with:
//
//	len(mockedGoRedisClient.ZRangeArgsWithScoresCalls())
func (mock *GoRedisClientMock) ZRangeArgsWithScoresCalls() []struct {
	Ctx context.Context
	Z   redis.ZRangeArgs
} {
	var calls []struct {
		Ctx context.Context
		Z   redis.ZRangeArgs
	}
	mock.lockZRangeArgsWithScores.RLock()
	calls = mock.calls.ZRangeArgsWithScores
	mock.lockZRangeArgsWithScores.RUnlock()
	return calls
}

// ZRangeByLex calls ZRangeByLexFunc.
func (mock *GoRedisClientMock) ZRangeByLex(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	if mock.ZRangeByLexFunc == nil {
		panic("GoRedisClientMock.ZRangeByLexFunc: method is nil but GoRedisClient.ZRangeByLex was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}{
		Ctx: ctx,
		Key: key,
		Opt: opt,
	}
	mock.lockZRangeByLex.Lock()
	mock.calls.ZRangeByLex = append(mock.calls.ZRangeByLex, callInfo)
	mock.lockZRangeByLex.Unlock()
	return mock.ZRangeByLexFunc(ctx, key, opt)
}

// ZRangeByLexCalls gets all the calls that were made to ZRangeByLex.
// Check the length with:
//
//	len(mockedGoRedisClient.ZRangeByLexCalls())
func (mock *GoRedisClientMock) ZRangeByLexCalls() []struct {
	Ctx context.Context
	Key string
	Opt *redis.ZRangeBy
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}
	mock.lockZRangeByLex.RLock()
	calls = mock.calls.ZRangeByLex
	mock.lockZRangeByLex.RUnlock()
	return calls
}

// ZRangeByScore calls ZRangeByScoreFunc.
func (mock *GoRedisClientMock) ZRangeByScore(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	if mock.ZRangeByScoreFunc == nil {
		panic("GoRedisClientMock.ZRangeByScoreFunc: method is nil but GoRedisClient.ZRangeByScore was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}{
		Ctx: ctx,
		Key: key,
		Opt: opt,
	}
	mock.lockZRangeByScore.Lock()
	mock.calls.ZRangeByScore = append(mock.calls.ZRangeByScore, callInfo)
	mock.lockZRangeByScore.Unlock()
	return mock.ZRangeByScoreFunc(ctx, key, opt)
}

// ZRangeByScoreCalls gets all the calls that were made to ZRangeByScore.
// Check the length with:
//
//	len(mockedGoRedisClient.ZRangeByScoreCalls())
func (mock *GoRedisClientMock) ZRangeByScoreCalls() []struct {
	Ctx context.Context
	Key string
	Opt *redis.ZRangeBy
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}
	mock.lockZRangeByScore.RLock()
	calls = mock.calls.ZRangeByScore
	mock.lockZRangeByScore.RUnlock()
	return calls
}

// ZRangeByScoreWithScores calls ZRangeByScoreWithScoresFunc.
func (mock *GoRedisClientMock) ZRangeByScoreWithScores(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.ZSliceCmd {
	if mock.ZRangeByScoreWithScoresFunc == nil {
		panic("GoRedisClientMock.ZRangeByScoreWithScoresFunc: method is nil but GoRedisClient.ZRangeByScoreWithScores was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}{
		Ctx: ctx,
		Key: key,
		Opt: opt,
	}
	mock.lockZRangeByScoreWithScores.Lock()
	mock.calls.ZRangeByScoreWithScores = append(mock.calls.ZRangeByScoreWithScores, callInfo)
	mock.lockZRangeByScoreWithScores.Unlock()
	return mock.ZRangeByScoreWithScoresFunc(ctx, key, opt)
}

// ZRangeByScoreWithScoresCalls gets all the calls that were made to ZRangeByScoreWithScores.
// Check the length with:
//
//	len(mockedGoRedisClient.ZRangeByScoreWithScoresCalls())
func (mock *GoRedisClientMock) ZRangeByScoreWithScoresCalls() []struct {
	Ctx context.Context
	Key string
	Opt *redis.ZRangeBy
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}
	mock.lockZRangeByScoreWithScores.RLock()
	calls = mock.calls.ZRangeByScoreWithScores
	mock.lockZRangeByScoreWithScores.RUnlock()
	return calls
}

// ZRangeStore calls ZRangeStoreFunc.
func (mock *GoRedisClientMock) ZRangeStore(ctx context.Context, dst string, z redis.ZRangeArgs) *redis.IntCmd {
	if mock.ZRangeStoreFunc == nil {
		panic("GoRedisClientMock.ZRangeStoreFunc: method is nil but GoRedisClient.ZRangeStore was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Dst string
		Z   redis.ZRangeArgs
	}{
		Ctx: ctx,
		Dst: dst,
		Z:   z,
	}
	mock.lockZRangeStore.Lock()
	mock.calls.ZRangeStore = append(mock.calls.ZRangeStore, callInfo)
	mock.lockZRangeStore.Unlock()
	return mock.ZRangeStoreFunc(ctx, dst, z)
}

// ZRangeStoreCalls gets all the calls that were made to ZRangeStore.
// Check the length with:
//
//	len(mockedGoRedisClient.ZRangeStoreCalls())
func (mock *GoRedisClientMock) ZRangeStoreCalls() []struct {
	Ctx context.Context
	Dst string
	Z   redis.ZRangeArgs
} {
	var calls []struct {
		Ctx context.Context
		Dst string
		Z   redis.ZRangeArgs
	}
	mock.lockZRangeStore.RLock()
	calls = mock.calls.ZRangeStore
	mock.lockZRangeStore.RUnlock()
	return calls
}

// ZRangeWithScores calls ZRangeWithScoresFunc.
func (mock *GoRedisClientMock) ZRangeWithScores(ctx context.Context, key string, start int64, stop int64) *redis.ZSliceCmd {
	if mock.ZRangeWithScoresFunc == nil {
		panic("GoRedisClientMock.ZRangeWithScoresFunc: method is nil but GoRedisClient.ZRangeWithScores was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}{
		Ctx:   ctx,
		Key:   key,
		Start: start,
		Stop:  stop,
	}
	mock.lockZRangeWithScores.Lock()
	mock.calls.ZRangeWithScores = append(mock.calls.ZRangeWithScores, callInfo)
	mock.lockZRangeWithScores.Unlock()
	return mock.ZRangeWithScoresFunc(ctx, key, start, stop)
}

// ZRangeWithScoresCalls gets all the calls that were made to ZRangeWithScores.
// Check the length with:
//
//	len(mockedGoRedisClient.ZRangeWithScoresCalls())
func (mock *GoRedisClientMock) ZRangeWithScoresCalls() []struct {
	Ctx   context.Context
	Key   string
	Start int64
	Stop  int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}
	mock.lockZRangeWithScores.RLock()
	calls = mock.calls.ZRangeWithScores
	mock.lockZRangeWithScores.RUnlock()
	return calls
}

// ZRank calls ZRankFunc.
func (mock *GoRedisClientMock) ZRank(ctx context.Context, key string, member string) *redis.IntCmd {
	if mock.ZRankFunc == nil {
		panic("GoRedisClientMock.ZRankFunc: method is nil but GoRedisClient.ZRank was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Member string
	}{
		Ctx:    ctx,
		Key:    key,
		Member: member,
	}
	mock.lockZRank.Lock()
	mock.calls.ZRank = append(mock.calls.ZRank, callInfo)
	mock.lockZRank.Unlock()
	return mock.ZRankFunc(ctx, key, member)
}

// ZRankCalls gets all the calls that were made to ZRank.
// Check the length with:
//
//	len(mockedGoRedisClient.ZRankCalls())
func (mock *GoRedisClientMock) ZRankCalls() []struct {
	Ctx    context.Context
	Key    string
	Member string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Member string
	}
	mock.lockZRank.RLock()
	calls = mock.calls.ZRank
	mock.lockZRank.RUnlock()
	return calls
}

// ZRankWithScore calls ZRankWithScoreFunc.
func (mock *GoRedisClientMock) ZRankWithScore(ctx context.Context, key string, member string) *redis.RankWithScoreCmd {
	if mock.ZRankWithScoreFunc == nil {
		panic("GoRedisClientMock.ZRankWithScoreFunc: method is nil but GoRedisClient.ZRankWithScore was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Member string
	}{
		Ctx:    ctx,
		Key:    key,
		Member: member,
	}
	mock.lockZRankWithScore.Lock()
	mock.calls.ZRankWithScore = append(mock.calls.ZRankWithScore, callInfo)
	mock.lockZRankWithScore.Unlock()
	return mock.ZRankWithScoreFunc(ctx, key, member)
}

// ZRankWithScoreCalls gets all the calls that were made to ZRankWithScore.
// Check the length with:
//
//	len(mockedGoRedisClient.ZRankWithScoreCalls())
func (mock *GoRedisClientMock) ZRankWithScoreCalls() []struct {
	Ctx    context.Context
	Key    string
	Member string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Member string
	}
	mock.lockZRankWithScore.RLock()
	calls = mock.calls.ZRankWithScore
	mock.lockZRankWithScore.RUnlock()
	return calls
}

// ZRem calls ZRemFunc.
func (mock *GoRedisClientMock) ZRem(ctx context.Context, key string, members ...interface{}) *redis.IntCmd {
	if mock.ZRemFunc == nil {
		panic("GoRedisClientMock.ZRemFunc: method is nil but GoRedisClient.ZRem was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Key     string
		Members []interface{}
	}{
		Ctx:     ctx,
		Key:     key,
		Members: members,
	}
	mock.lockZRem.Lock()
	mock.calls.ZRem = append(mock.calls.ZRem, callInfo)
	mock.lockZRem.Unlock()
	return mock.ZRemFunc(ctx, key, members...)
}

// ZRemCalls gets all the calls that were made to ZRem.
// Check the length with:
//
//	len(mockedGoRedisClient.ZRemCalls())
func (mock *GoRedisClientMock) ZRemCalls() []struct {
	Ctx     context.Context
	Key     string
	Members []interface{}
} {
	var calls []struct {
		Ctx     context.Context
		Key     string
		Members []interface{}
	}
	mock.lockZRem.RLock()
	calls = mock.calls.ZRem
	mock.lockZRem.RUnlock()
	return calls
}

// ZRemRangeByLex calls ZRemRangeByLexFunc.
func (mock *GoRedisClientMock) ZRemRangeByLex(ctx context.Context, key string, min string, max string) *redis.IntCmd {
	if mock.ZRemRangeByLexFunc == nil {
		panic("GoRedisClientMock.ZRemRangeByLexFunc: method is nil but GoRedisClient.ZRemRangeByLex was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Min string
		Max string
	}{
		Ctx: ctx,
		Key: key,
		Min: min,
		Max: max,
	}
	mock.lockZRemRangeByLex.Lock()
	mock.calls.ZRemRangeByLex = append(mock.calls.ZRemRangeByLex, callInfo)
	mock.lockZRemRangeByLex.Unlock()
	return mock.ZRemRangeByLexFunc(ctx, key, min, max)
}

// ZRemRangeByLexCalls gets all the calls that were made to ZRemRangeByLex.
// Check the length with:
//
//	len(mockedGoRedisClient.ZRemRangeByLexCalls())
func (mock *GoRedisClientMock) ZRemRangeByLexCalls() []struct {
	Ctx context.Context
	Key string
	Min string
	Max string
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Min string
		Max string
	}
	mock.lockZRemRangeByLex.RLock()
	calls = mock.calls.ZRemRangeByLex
	mock.lockZRemRangeByLex.RUnlock()
	return calls
}

// ZRemRangeByRank calls ZRemRangeByRankFunc.
func (mock *GoRedisClientMock) ZRemRangeByRank(ctx context.Context, key string, start int64, stop int64) *redis.IntCmd {
	if mock.ZRemRangeByRankFunc == nil {
		panic("GoRedisClientMock.ZRemRangeByRankFunc: method is nil but GoRedisClient.ZRemRangeByRank was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}{
		Ctx:   ctx,
		Key:   key,
		Start: start,
		Stop:  stop,
	}
	mock.lockZRemRangeByRank.Lock()
	mock.calls.ZRemRangeByRank = append(mock.calls.ZRemRangeByRank, callInfo)
	mock.lockZRemRangeByRank.Unlock()
	return mock.ZRemRangeByRankFunc(ctx, key, start, stop)
}

// ZRemRangeByRankCalls gets all the calls that were made to ZRemRangeByRank.
// Check the length with:
//
//	len(mockedGoRedisClient.ZRemRangeByRankCalls())
func (mock *GoRedisClientMock) ZRemRangeByRankCalls() []struct {
	Ctx   context.Context
	Key   string
	Start int64
	Stop  int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}
	mock.lockZRemRangeByRank.RLock()
	calls = mock.calls.ZRemRangeByRank
	mock.lockZRemRangeByRank.RUnlock()
	return calls
}

// ZRemRangeByScore calls ZRemRangeByScoreFunc.
func (mock *GoRedisClientMock) ZRemRangeByScore(ctx context.Context, key string, min string, max string) *redis.IntCmd {
	if mock.ZRemRangeByScoreFunc == nil {
		panic("GoRedisClientMock.ZRemRangeByScoreFunc: method is nil but GoRedisClient.ZRemRangeByScore was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Min string
		Max string
	}{
		Ctx: ctx,
		Key: key,
		Min: min,
		Max: max,
	}
	mock.lockZRemRangeByScore.Lock()
	mock.calls.ZRemRangeByScore = append(mock.calls.ZRemRangeByScore, callInfo)
	mock.lockZRemRangeByScore.Unlock()
	return mock.ZRemRangeByScoreFunc(ctx, key, min, max)
}

// ZRemRangeByScoreCalls gets all the calls that were made to ZRemRangeByScore.
// Check the length with:
//
//	len(mockedGoRedisClient.ZRemRangeByScoreCalls())
func (mock *GoRedisClientMock) ZRemRangeByScoreCalls() []struct {
	Ctx context.Context
	Key string
	Min string
	Max string
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Min string
		Max string
	}
	mock.lockZRemRangeByScore.RLock()
	calls = mock.calls.ZRemRangeByScore
	mock.lockZRemRangeByScore.RUnlock()
	return calls
}

// ZRevRange calls ZRevRangeFunc.
func (mock *GoRedisClientMock) ZRevRange(ctx context.Context, key string, start int64, stop int64) *redis.StringSliceCmd {
	if mock.ZRevRangeFunc == nil {
		panic("GoRedisClientMock.ZRevRangeFunc: method is nil but GoRedisClient.ZRevRange was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}{
		Ctx:   ctx,
		Key:   key,
		Start: start,
		Stop:  stop,
	}
	mock.lockZRevRange.Lock()
	mock.calls.ZRevRange = append(mock.calls.ZRevRange, callInfo)
	mock.lockZRevRange.Unlock()
	return mock.ZRevRangeFunc(ctx, key, start, stop)
}

// ZRevRangeCalls gets all the calls that were made to ZRevRange.
// Check the length with:
//
//	len(mockedGoRedisClient.ZRevRangeCalls())
func (mock *GoRedisClientMock) ZRevRangeCalls() []struct {
	Ctx   context.Context
	Key   string
	Start int64
	Stop  int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}
	mock.lockZRevRange.RLock()
	calls = mock.calls.ZRevRange
	mock.lockZRevRange.RUnlock()
	return calls
}

// ZRevRangeByLex calls ZRevRangeByLexFunc.
func (mock *GoRedisClientMock) ZRevRangeByLex(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	if mock.ZRevRangeByLexFunc == nil {
		panic("GoRedisClientMock.ZRevRangeByLexFunc: method is nil but GoRedisClient.ZRevRangeByLex was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}{
		Ctx: ctx,
		Key: key,
		Opt: opt,
	}
	mock.lockZRevRangeByLex.Lock()
	mock.calls.ZRevRangeByLex = append(mock.calls.ZRevRangeByLex, callInfo)
	mock.lockZRevRangeByLex.Unlock()
	return mock.ZRevRangeByLexFunc(ctx, key, opt)
}

// ZRevRangeByLexCalls gets all the calls that were made to ZRevRangeByLex.
// Check the length with:
//
//	len(mockedGoRedisClient.ZRevRangeByLexCalls())
func (mock *GoRedisClientMock) ZRevRangeByLexCalls() []struct {
	Ctx context.Context
	Key string
	Opt *redis.ZRangeBy
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}
	mock.lockZRevRangeByLex.RLock()
	calls = mock.calls.ZRevRangeByLex
	mock.lockZRevRangeByLex.RUnlock()
	return calls
}

// ZRevRangeByScore calls ZRevRangeByScoreFunc.
func (mock *GoRedisClientMock) ZRevRangeByScore(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.StringSliceCmd {
	if mock.ZRevRangeByScoreFunc == nil {
		panic("GoRedisClientMock.ZRevRangeByScoreFunc: method is nil but GoRedisClient.ZRevRangeByScore was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}{
		Ctx: ctx,
		Key: key,
		Opt: opt,
	}
	mock.lockZRevRangeByScore.Lock()
	mock.calls.ZRevRangeByScore = append(mock.calls.ZRevRangeByScore, callInfo)
	mock.lockZRevRangeByScore.Unlock()
	return mock.ZRevRangeByScoreFunc(ctx, key, opt)
}

// ZRevRangeByScoreCalls gets all the calls that were made to ZRevRangeByScore.
// Check the length with:
//
//	len(mockedGoRedisClient.ZRevRangeByScoreCalls())
func (mock *GoRedisClientMock) ZRevRangeByScoreCalls() []struct {
	Ctx context.Context
	Key string
	Opt *redis.ZRangeBy
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}
	mock.lockZRevRangeByScore.RLock()
	calls = mock.calls.ZRevRangeByScore
	mock.lockZRevRangeByScore.RUnlock()
	return calls
}

// ZRevRangeByScoreWithScores calls ZRevRangeByScoreWithScoresFunc.
func (mock *GoRedisClientMock) ZRevRangeByScoreWithScores(ctx context.Context, key string, opt *redis.ZRangeBy) *redis.ZSliceCmd {
	if mock.ZRevRangeByScoreWithScoresFunc == nil {
		panic("GoRedisClientMock.ZRevRangeByScoreWithScoresFunc: method is nil but GoRedisClient.ZRevRangeByScoreWithScores was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}{
		Ctx: ctx,
		Key: key,
		Opt: opt,
	}
	mock.lockZRevRangeByScoreWithScores.Lock()
	mock.calls.ZRevRangeByScoreWithScores = append(mock.calls.ZRevRangeByScoreWithScores, callInfo)
	mock.lockZRevRangeByScoreWithScores.Unlock()
	return mock.ZRevRangeByScoreWithScoresFunc(ctx, key, opt)
}

// ZRevRangeByScoreWithScoresCalls gets all the calls that were made to ZRevRangeByScoreWithScores.
// Check the length with:
//
//	len(mockedGoRedisClient.ZRevRangeByScoreWithScoresCalls())
func (mock *GoRedisClientMock) ZRevRangeByScoreWithScoresCalls() []struct {
	Ctx context.Context
	Key string
	Opt *redis.ZRangeBy
} {
	var calls []struct {
		Ctx context.Context
		Key string
		Opt *redis.ZRangeBy
	}
	mock.lockZRevRangeByScoreWithScores.RLock()
	calls = mock.calls.ZRevRangeByScoreWithScores
	mock.lockZRevRangeByScoreWithScores.RUnlock()
	return calls
}

// ZRevRangeWithScores calls ZRevRangeWithScoresFunc.
func (mock *GoRedisClientMock) ZRevRangeWithScores(ctx context.Context, key string, start int64, stop int64) *redis.ZSliceCmd {
	if mock.ZRevRangeWithScoresFunc == nil {
		panic("GoRedisClientMock.ZRevRangeWithScoresFunc: method is nil but GoRedisClient.ZRevRangeWithScores was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}{
		Ctx:   ctx,
		Key:   key,
		Start: start,
		Stop:  stop,
	}
	mock.lockZRevRangeWithScores.Lock()
	mock.calls.ZRevRangeWithScores = append(mock.calls.ZRevRangeWithScores, callInfo)
	mock.lockZRevRangeWithScores.Unlock()
	return mock.ZRevRangeWithScoresFunc(ctx, key, start, stop)
}

// ZRevRangeWithScoresCalls gets all the calls that were made to ZRevRangeWithScores.
// Check the length with:
//
//	len(mockedGoRedisClient.ZRevRangeWithScoresCalls())
func (mock *GoRedisClientMock) ZRevRangeWithScoresCalls() []struct {
	Ctx   context.Context
	Key   string
	Start int64
	Stop  int64
} {
	var calls []struct {
		Ctx   context.Context
		Key   string
		Start int64
		Stop  int64
	}
	mock.lockZRevRangeWithScores.RLock()
	calls = mock.calls.ZRevRangeWithScores
	mock.lockZRevRangeWithScores.RUnlock()
	return calls
}

// ZRevRank calls ZRevRankFunc.
func (mock *GoRedisClientMock) ZRevRank(ctx context.Context, key string, member string) *redis.IntCmd {
	if mock.ZRevRankFunc == nil {
		panic("GoRedisClientMock.ZRevRankFunc: method is nil but GoRedisClient.ZRevRank was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Member string
	}{
		Ctx:    ctx,
		Key:    key,
		Member: member,
	}
	mock.lockZRevRank.Lock()
	mock.calls.ZRevRank = append(mock.calls.ZRevRank, callInfo)
	mock.lockZRevRank.Unlock()
	return mock.ZRevRankFunc(ctx, key, member)
}

// ZRevRankCalls gets all the calls that were made to ZRevRank.
// Check the length with:
//
//	len(mockedGoRedisClient.ZRevRankCalls())
func (mock *GoRedisClientMock) ZRevRankCalls() []struct {
	Ctx    context.Context
	Key    string
	Member string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Member string
	}
	mock.lockZRevRank.RLock()
	calls = mock.calls.ZRevRank
	mock.lockZRevRank.RUnlock()
	return calls
}

// ZRevRankWithScore calls ZRevRankWithScoreFunc.
func (mock *GoRedisClientMock) ZRevRankWithScore(ctx context.Context, key string, member string) *redis.RankWithScoreCmd {
	if mock.ZRevRankWithScoreFunc == nil {
		panic("GoRedisClientMock.ZRevRankWithScoreFunc: method is nil but GoRedisClient.ZRevRankWithScore was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Member string
	}{
		Ctx:    ctx,
		Key:    key,
		Member: member,
	}
	mock.lockZRevRankWithScore.Lock()
	mock.calls.ZRevRankWithScore = append(mock.calls.ZRevRankWithScore, callInfo)
	mock.lockZRevRankWithScore.Unlock()
	return mock.ZRevRankWithScoreFunc(ctx, key, member)
}

// ZRevRankWithScoreCalls gets all the calls that were made to ZRevRankWithScore.
// Check the length with:
//
//	len(mockedGoRedisClient.ZRevRankWithScoreCalls())
func (mock *GoRedisClientMock) ZRevRankWithScoreCalls() []struct {
	Ctx    context.Context
	Key    string
	Member string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Member string
	}
	mock.lockZRevRankWithScore.RLock()
	calls = mock.calls.ZRevRankWithScore
	mock.lockZRevRankWithScore.RUnlock()
	return calls
}

// ZScan calls ZScanFunc.
func (mock *GoRedisClientMock) ZScan(ctx context.Context, key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	if mock.ZScanFunc == nil {
		panic("GoRedisClientMock.ZScanFunc: method is nil but GoRedisClient.ZScan was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Cursor uint64
		Match  string
		Count  int64
	}{
		Ctx:    ctx,
		Key:    key,
		Cursor: cursor,
		Match:  match,
		Count:  count,
	}
	mock.lockZScan.Lock()
	mock.calls.ZScan = append(mock.calls.ZScan, callInfo)
	mock.lockZScan.Unlock()
	return mock.ZScanFunc(ctx, key, cursor, match, count)
}

// ZScanCalls gets all the calls that were made to ZScan.
// Check the length with:
//
//	len(mockedGoRedisClient.ZScanCalls())
func (mock *GoRedisClientMock) ZScanCalls() []struct {
	Ctx    context.Context
	Key    string
	Cursor uint64
	Match  string
	Count  int64
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Cursor uint64
		Match  string
		Count  int64
	}
	mock.lockZScan.RLock()
	calls = mock.calls.ZScan
	mock.lockZScan.RUnlock()
	return calls
}

// ZScore calls ZScoreFunc.
func (mock *GoRedisClientMock) ZScore(ctx context.Context, key string, member string) *redis.FloatCmd {
	if mock.ZScoreFunc == nil {
		panic("GoRedisClientMock.ZScoreFunc: method is nil but GoRedisClient.ZScore was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Key    string
		Member string
	}{
		Ctx:    ctx,
		Key:    key,
		Member: member,
	}
	mock.lockZScore.Lock()
	mock.calls.ZScore = append(mock.calls.ZScore, callInfo)
	mock.lockZScore.Unlock()
	return mock.ZScoreFunc(ctx, key, member)
}

// ZScoreCalls gets all the calls that were made to ZScore.
// Check the length with:
//
//	len(mockedGoRedisClient.ZScoreCalls())
func (mock *GoRedisClientMock) ZScoreCalls() []struct {
	Ctx    context.Context
	Key    string
	Member string
} {
	var calls []struct {
		Ctx    context.Context
		Key    string
		Member string
	}
	mock.lockZScore.RLock()
	calls = mock.calls.ZScore
	mock.lockZScore.RUnlock()
	return calls
}

// ZUnion calls ZUnionFunc.
func (mock *GoRedisClientMock) ZUnion(ctx context.Context, store redis.ZStore) *redis.StringSliceCmd {
	if mock.ZUnionFunc == nil {
		panic("GoRedisClientMock.ZUnionFunc: method is nil but GoRedisClient.ZUnion was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Store redis.ZStore
	}{
		Ctx:   ctx,
		Store: store,
	}
	mock.lockZUnion.Lock()
	mock.calls.ZUnion = append(mock.calls.ZUnion, callInfo)
	mock.lockZUnion.Unlock()
	return mock.ZUnionFunc(ctx, store)
}

// ZUnionCalls gets all the calls that were made to ZUnion.
// Check the length with:
//
//	len(mockedGoRedisClient.ZUnionCalls())
func (mock *GoRedisClientMock) ZUnionCalls() []struct {
	Ctx   context.Context
	Store redis.ZStore
} {
	var calls []struct {
		Ctx   context.Context
		Store redis.ZStore
	}
	mock.lockZUnion.RLock()
	calls = mock.calls.ZUnion
	mock.lockZUnion.RUnlock()
	return calls
}

// ZUnionStore calls ZUnionStoreFunc.
func (mock *GoRedisClientMock) ZUnionStore(ctx context.Context, dest string, store *redis.ZStore) *redis.IntCmd {
	if mock.ZUnionStoreFunc == nil {
		panic("GoRedisClientMock.ZUnionStoreFunc: method is nil but GoRedisClient.ZUnionStore was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Dest  string
		Store *redis.ZStore
	}{
		Ctx:   ctx,
		Dest:  dest,
		Store: store,
	}
	mock.lockZUnionStore.Lock()
	mock.calls.ZUnionStore = append(mock.calls.ZUnionStore, callInfo)
	mock.lockZUnionStore.Unlock()
	return mock.ZUnionStoreFunc(ctx, dest, store)
}

// ZUnionStoreCalls gets all the calls that were made to ZUnionStore.
// Check the length with:
//
//	len(mockedGoRedisClient.ZUnionStoreCalls())
func (mock *GoRedisClientMock) ZUnionStoreCalls() []struct {
	Ctx   context.Context
	Dest  string
	Store *redis.ZStore
} {
	var calls []struct {
		Ctx   context.Context
		Dest  string
		Store *redis.ZStore
	}
	mock.lockZUnionStore.RLock()
	calls = mock.calls.ZUnionStore
	mock.lockZUnionStore.RUnlock()
	return calls
}

// ZUnionWithScores calls ZUnionWithScoresFunc.
func (mock *GoRedisClientMock) ZUnionWithScores(ctx context.Context, store redis.ZStore) *redis.ZSliceCmd {
	if mock.ZUnionWithScoresFunc == nil {
		panic("GoRedisClientMock.ZUnionWithScoresFunc: method is nil but GoRedisClient.ZUnionWithScores was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Store redis.ZStore
	}{
		Ctx:   ctx,
		Store: store,
	}
	mock.lockZUnionWithScores.Lock()
	mock.calls.ZUnionWithScores = append(mock.calls.ZUnionWithScores, callInfo)
	mock.lockZUnionWithScores.Unlock()
	return mock.ZUnionWithScoresFunc(ctx, store)
}

// ZUnionWithScoresCalls gets all the calls that were made to ZUnionWithScores.
// Check the length with:
//
//	len(mockedGoRedisClient.ZUnionWithScoresCalls())
func (mock *GoRedisClientMock) ZUnionWithScoresCalls() []struct {
	Ctx   context.Context
	Store redis.ZStore
} {
	var calls []struct {
		Ctx   context.Context
		Store redis.ZStore
	}
	mock.lockZUnionWithScores.RLock()
	calls = mock.calls.ZUnionWithScores
	mock.lockZUnionWithScores.RUnlock()
	return calls
}
